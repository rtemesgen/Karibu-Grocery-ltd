/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.2
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!(function (t) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = t(); else if (typeof define === 'function' && define.amd)define([], t); else { (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).Chart = t(); } }(() => (function t(e, i, n) { function a(r, s) { if (!i[r]) { if (!e[r]) { const l = typeof require === 'function' && require; if (!s && l) return l(r, !0); if (o) return o(r, !0); const u = new Error(`Cannot find module '${r}'`); throw u.code = 'MODULE_NOT_FOUND', u; } const d = i[r] = { exports: {} }; e[r][0].call(d.exports, (t) => { const i = e[r][1][t]; return a(i || t); }, d, d.exports, t, e, i, n); } return i[r].exports; } for (var o = typeof require === 'function' && require, r = 0; r < n.length; r++)a(n[r]); return a; }({
  1: [function (t, e, i) {}, {}],
  2: [function (t, e, i) {
    const n = t(6); function a(t) { if (t) { let e = [0, 0, 0]; let i = 1; let a = t.match(/^#([a-fA-F0-9]{3})$/i); if (a) { a = a[1]; for (var o = 0; o < e.length; o++)e[o] = parseInt(a[o] + a[o], 16); } else if (a = t.match(/^#([a-fA-F0-9]{6})$/i)) { a = a[1]; for (o = 0; o < e.length; o++)e[o] = parseInt(a.slice(2 * o, 2 * o + 2), 16); } else if (a = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = parseInt(a[o + 1]); i = parseFloat(a[4]); } else if (a = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = Math.round(2.55 * parseFloat(a[o + 1])); i = parseFloat(a[4]); } else if (a = t.match(/(\w+)/)) { if (a[1] == 'transparent') return [0, 0, 0, 0]; if (!(e = n[a[1]])) return; } for (o = 0; o < e.length; o++)e[o] = d(e[o], 0, 255); return i = i || i == 0 ? d(i, 0, 1) : 1, e[3] = i, e; } } function o(t) { if (t) { const e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const i = parseFloat(e[4]); return [d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(i) ? 1 : i, 0, 1)]; } } } function r(t) { if (t) { const e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const i = parseFloat(e[4]); return [d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(i) ? 1 : i, 0, 1)]; } } } function s(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `rgba(${t[0]}, ${t[1]}, ${t[2]}, ${e})`; } function l(t, e) { return `rgba(${Math.round(t[0] / 255 * 100)}%, ${Math.round(t[1] / 255 * 100)}%, ${Math.round(t[2] / 255 * 100)}%, ${e || t[3] || 1})`; } function u(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${e})`; } function d(t, e, i) { return Math.min(Math.max(e, t), i); } function c(t) { const e = t.toString(16).toUpperCase(); return e.length < 2 ? `0${e}` : e; }e.exports = {
      getRgba: a, getHsla: o, getRgb(t) { const e = a(t); return e && e.slice(0, 3); }, getHsl(t) { const e = o(t); return e && e.slice(0, 3); }, getHwb: r, getAlpha(t) { let e = a(t); { if (e) return e[3]; if (e = o(t)) return e[3]; if (e = r(t)) return e[3]; } }, hexString(t) { return `#${c(t[0])}${c(t[1])}${c(t[2])}`; }, rgbString(t, e) { if (e < 1 || t[3] && t[3] < 1) return s(t, e); return `rgb(${t[0]}, ${t[1]}, ${t[2]})`; }, rgbaString: s, percentString(t, e) { if (e < 1 || t[3] && t[3] < 1) return l(t, e); const i = Math.round(t[0] / 255 * 100); const n = Math.round(t[1] / 255 * 100); const a = Math.round(t[2] / 255 * 100); return `rgb(${i}%, ${n}%, ${a}%)`; }, percentaString: l, hslString(t, e) { if (e < 1 || t[3] && t[3] < 1) return u(t, e); return `hsl(${t[0]}, ${t[1]}%, ${t[2]}%)`; }, hslaString: u, hwbString(t, e) { void 0 === e && (e = void 0 !== t[3] ? t[3] : 1); return `hwb(${t[0]}, ${t[1]}%, ${t[2]}%${void 0 !== e && e !== 1 ? `, ${e}` : ''})`; }, keyword(t) { return h[t.slice(0, 3)]; },
    }; var h = {}; for (const f in n)h[n[f]] = f;
  }, { 6: 6 }],
  3: [function (t, e, i) {
    const n = t(5); const a = t(2); const o = function (t) {
      return t instanceof o ? t : this instanceof o ? (this.valid = !1, this.values = {
        rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1,
      }, void (typeof t === 'string' ? (e = a.getRgba(t)) ? this.setValues('rgb', e) : (e = a.getHsla(t)) ? this.setValues('hsl', e) : (e = a.getHwb(t)) && this.setValues('hwb', e) : typeof t === 'object' && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues('rgb', e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues('hsl', e) : void 0 !== e.v || void 0 !== e.value ? this.setValues('hsv', e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues('hwb', e) : void 0 === e.c && void 0 === e.cyan || this.setValues('cmyk', e)))) : new o(t); let e;
    }; o.prototype = {
      isValid() { return this.valid; }, rgb() { return this.setSpace('rgb', arguments); }, hsl() { return this.setSpace('hsl', arguments); }, hsv() { return this.setSpace('hsv', arguments); }, hwb() { return this.setSpace('hwb', arguments); }, cmyk() { return this.setSpace('cmyk', arguments); }, rgbArray() { return this.values.rgb; }, hslArray() { return this.values.hsl; }, hsvArray() { return this.values.hsv; }, hwbArray() { const t = this.values; return t.alpha !== 1 ? t.hwb.concat([t.alpha]) : t.hwb; }, cmykArray() { return this.values.cmyk; }, rgbaArray() { const t = this.values; return t.rgb.concat([t.alpha]); }, hslaArray() { const t = this.values; return t.hsl.concat([t.alpha]); }, alpha(t) { return void 0 === t ? this.values.alpha : (this.setValues('alpha', t), this); }, red(t) { return this.setChannel('rgb', 0, t); }, green(t) { return this.setChannel('rgb', 1, t); }, blue(t) { return this.setChannel('rgb', 2, t); }, hue(t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel('hsl', 0, t); }, saturation(t) { return this.setChannel('hsl', 1, t); }, lightness(t) { return this.setChannel('hsl', 2, t); }, saturationv(t) { return this.setChannel('hsv', 1, t); }, whiteness(t) { return this.setChannel('hwb', 1, t); }, blackness(t) { return this.setChannel('hwb', 2, t); }, value(t) { return this.setChannel('hsv', 2, t); }, cyan(t) { return this.setChannel('cmyk', 0, t); }, magenta(t) { return this.setChannel('cmyk', 1, t); }, yellow(t) { return this.setChannel('cmyk', 2, t); }, black(t) { return this.setChannel('cmyk', 3, t); }, hexString() { return a.hexString(this.values.rgb); }, rgbString() { return a.rgbString(this.values.rgb, this.values.alpha); }, rgbaString() { return a.rgbaString(this.values.rgb, this.values.alpha); }, percentString() { return a.percentString(this.values.rgb, this.values.alpha); }, hslString() { return a.hslString(this.values.hsl, this.values.alpha); }, hslaString() { return a.hslaString(this.values.hsl, this.values.alpha); }, hwbString() { return a.hwbString(this.values.hwb, this.values.alpha); }, keyword() { return a.keyword(this.values.rgb, this.values.alpha); }, rgbNumber() { const t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2]; }, luminosity() { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) { const n = t[i] / 255; e[i] = n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4; } return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]; }, contrast(t) { const e = this.luminosity(); const i = t.luminosity(); return e > i ? (e + 0.05) / (i + 0.05) : (i + 0.05) / (e + 0.05); }, level(t) { const e = this.contrast(t); return e >= 7.1 ? 'AAA' : e >= 4.5 ? 'AA' : ''; }, dark() { const t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128; }, light() { return !this.dark(); }, negate() { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues('rgb', t), this; }, lighten(t) { const e = this.values.hsl; return e[2] += e[2] * t, this.setValues('hsl', e), this; }, darken(t) { const e = this.values.hsl; return e[2] -= e[2] * t, this.setValues('hsl', e), this; }, saturate(t) { const e = this.values.hsl; return e[1] += e[1] * t, this.setValues('hsl', e), this; }, desaturate(t) { const e = this.values.hsl; return e[1] -= e[1] * t, this.setValues('hsl', e), this; }, whiten(t) { const e = this.values.hwb; return e[1] += e[1] * t, this.setValues('hwb', e), this; }, blacken(t) { const e = this.values.hwb; return e[2] += e[2] * t, this.setValues('hwb', e), this; }, greyscale() { const t = this.values.rgb; const e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2]; return this.setValues('rgb', [e, e, e]), this; }, clearer(t) { const e = this.values.alpha; return this.setValues('alpha', e - e * t), this; }, opaquer(t) { const e = this.values.alpha; return this.setValues('alpha', e + e * t), this; }, rotate(t) { const e = this.values.hsl; const i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues('hsl', e), this; }, mix(t, e) { const i = this; const n = t; const a = void 0 === e ? 0.5 : e; const o = 2 * a - 1; const r = i.alpha() - n.alpha(); const s = ((o * r == -1 ? o : (o + r) / (1 + o * r)) + 1) / 2; const l = 1 - s; return this.rgb(s * i.red() + l * n.red(), s * i.green() + l * n.green(), s * i.blue() + l * n.blue()).alpha(i.alpha() * a + n.alpha() * (1 - a)); }, toJSON() { return this.rgb(); }, clone() { let t; let e; const i = new o(); const n = this.values; const a = i.values; for (const r in n)n.hasOwnProperty(r) && (t = n[r], (e = {}.toString.call(t)) === '[object Array]' ? a[r] = t.slice(0) : e === '[object Number]' ? a[r] = t : console.error('unexpected color value:', t)); return i; },
    }, o.prototype.spaces = {
      rgb: ['red', 'green', 'blue'], hsl: ['hue', 'saturation', 'lightness'], hsv: ['hue', 'saturation', 'value'], hwb: ['hue', 'whiteness', 'blackness'], cmyk: ['cyan', 'magenta', 'yellow', 'black'],
    }, o.prototype.maxes = {
      rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100],
    }, o.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)i[t.charAt(n)] = e[t][n]; return e.alpha !== 1 && (i.a = e.alpha), i; }, o.prototype.setValues = function (t, e) { let i; let a; const o = this.values; const r = this.spaces; const s = this.maxes; let l = 1; if (this.valid = !0, t === 'alpha')l = e; else if (e.length)o[t] = e.slice(0, t.length), l = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (i = 0; i < t.length; i++)o[t][i] = e[t.charAt(i)]; l = e.a; } else if (void 0 !== e[r[t][0]]) { const u = r[t]; for (i = 0; i < t.length; i++)o[t][i] = e[u[i]]; l = e.alpha; } if (o.alpha = Math.max(0, Math.min(1, void 0 === l ? o.alpha : l)), t === 'alpha') return !1; for (i = 0; i < t.length; i++)a = Math.max(0, Math.min(s[t][i], o[t][i])), o[t][i] = Math.round(a); for (const d in r)d !== t && (o[d] = n[t][d](o[t])); return !0; }, o.prototype.setSpace = function (t, e) { let i = e[0]; return void 0 === i ? this.getValues(t) : (typeof i === 'number' && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this); }, o.prototype.setChannel = function (t, e, i) { const n = this.values[t]; return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this); }, typeof window !== 'undefined' && (window.Color = o), e.exports = o;
  }, { 2: 2, 5: 5 }],
  4: [function (t, e, i) {
    function n(t) { let e; let i; const n = t[0] / 255; const a = t[1] / 255; const o = t[2] / 255; const r = Math.min(n, a, o); const s = Math.max(n, a, o); const l = s - r; return s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (r + s) / 2, [e, 100 * (s == r ? 0 : i <= 0.5 ? l / (s + r) : l / (2 - s - r)), 100 * i]; } function a(t) { let e; let i; const n = t[0]; const a = t[1]; const o = t[2]; const r = Math.min(n, a, o); const s = Math.max(n, a, o); const l = s - r; return i = s == 0 ? 0 : l / s * 1e3 / 10, s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10]; } function o(t) { const e = t[0]; const i = t[1]; let a = t[2]; return [n(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(i, a))), 100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(i, a)))]; } function s(t) { let e; const i = t[0] / 255; const n = t[1] / 255; const a = t[2] / 255; return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e]; } function l(t) { return C[JSON.stringify(t)]; } function u(t) { let e = t[0] / 255; let i = t[1] / 255; let n = t[2] / 255; return [100 * (0.4124 * (e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92) + 0.3576 * (i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92) + 0.1805 * (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92)), 100 * (0.2126 * e + 0.7152 * i + 0.0722 * n), 100 * (0.0193 * e + 0.1192 * i + 0.9505 * n)]; } function d(t) { const e = u(t); let i = e[0]; let n = e[1]; let a = e[2]; return n /= 100, a /= 108.883, i = (i /= 95.047) > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > 0.008856 ? a ** (1 / 3) : 7.787 * a + 16 / 116))]; } function c(t) { let e; let i; let n; let a; let o; const r = t[0] / 360; const s = t[1] / 100; const l = t[2] / 100; if (s == 0) return [o = 255 * l, o, o]; e = 2 * l - (i = l < 0.5 ? l * (1 + s) : l + s - l * s), a = [0, 0, 0]; for (let u = 0; u < 3; u++)(n = r + 1 / 3 * -(u - 1)) < 0 && n++, n > 1 && n--, o = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[u] = 255 * o; return a; } function h(t) { const e = t[0] / 60; const i = t[1] / 100; let n = t[2] / 100; const a = Math.floor(e) % 6; const o = e - Math.floor(e); const r = 255 * n * (1 - i); const s = 255 * n * (1 - i * o); const l = 255 * n * (1 - i * (1 - o)); n *= 255; switch (a) { case 0: return [n, l, r]; case 1: return [s, n, r]; case 2: return [r, n, l]; case 3: return [r, s, n]; case 4: return [l, r, n]; case 5: return [n, r, s]; } } function f(t) { let e; let i; let n; let a; const o = t[0] / 360; let s = t[1] / 100; let l = t[2] / 100; const u = s + l; switch (u > 1 && (s /= u, l /= u), n = 6 * o - (e = Math.floor(6 * o)), (1 & e) != 0 && (n = 1 - n), a = s + n * ((i = 1 - l) - s), e) { default: case 6: case 0: r = i, g = a, b = s; break; case 1: r = a, g = i, b = s; break; case 2: r = s, g = i, b = a; break; case 3: r = s, g = a, b = i; break; case 4: r = a, g = s, b = i; break; case 5: r = i, g = s, b = a; } return [255 * r, 255 * g, 255 * b]; } function p(t) { const e = t[0] / 100; const i = t[1] / 100; const n = t[2] / 100; const a = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))]; } function m(t) { let e; let i; let n; const a = t[0] / 100; const o = t[1] / 100; const r = t[2] / 100; return i = -0.9689 * a + 1.8758 * o + 0.0415 * r, n = 0.0557 * a + -0.204 * o + 1.057 * r, e = (e = 3.2406 * a + -1.5372 * o + -0.4986 * r) > 0.0031308 ? 1.055 * e ** (1 / 2.4) - 0.055 : e *= 12.92, i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i *= 12.92, n = n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))]; } function v(t) { let e = t[0]; let i = t[1]; let n = t[2]; return i /= 100, n /= 108.883, e = (e /= 95.047) > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116))]; } function x(t) { let e; let i; let n; let a; const o = t[0]; const r = t[1]; const s = t[2]; return o <= 8 ? a = (i = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * ((o + 16) / 116) ** 3, a = (i / 100) ** (1 / 3)), [e = e / 95.047 <= 0.008856 ? e = 95.047 * (r / 500 + a - 16 / 116) / 7.787 : 95.047 * (r / 500 + a) ** 3, i, n = n / 108.883 <= 0.008859 ? n = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * (a - s / 200) ** 3]; } function y(t) { let e; const i = t[0]; const n = t[1]; const a = t[2]; return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e]; } function k(t) { return m(x(t)); } function M(t) { let e; const i = t[0]; const n = t[1]; return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)]; } function w(t) { return S[t]; }e.exports = {
      rgb2hsl: n, rgb2hsv: a, rgb2hwb: o, rgb2cmyk: s, rgb2keyword: l, rgb2xyz: u, rgb2lab: d, rgb2lch(t) { return y(d(t)); }, hsl2rgb: c, hsl2hsv(t) { const e = t[0]; let i = t[1] / 100; let n = t[2] / 100; if (n === 0) return [0, 0, 0]; return [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)]; }, hsl2hwb(t) { return o(c(t)); }, hsl2cmyk(t) { return s(c(t)); }, hsl2keyword(t) { return l(c(t)); }, hsv2rgb: h, hsv2hsl(t) { let e; let i; const n = t[0]; const a = t[1] / 100; const o = t[2] / 100; return e = a * o, [n, 100 * (e = (e /= (i = (2 - a) * o) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)]; }, hsv2hwb(t) { return o(h(t)); }, hsv2cmyk(t) { return s(h(t)); }, hsv2keyword(t) { return l(h(t)); }, hwb2rgb: f, hwb2hsl(t) { return n(f(t)); }, hwb2hsv(t) { return a(f(t)); }, hwb2cmyk(t) { return s(f(t)); }, hwb2keyword(t) { return l(f(t)); }, cmyk2rgb: p, cmyk2hsl(t) { return n(p(t)); }, cmyk2hsv(t) { return a(p(t)); }, cmyk2hwb(t) { return o(p(t)); }, cmyk2keyword(t) { return l(p(t)); }, keyword2rgb: w, keyword2hsl(t) { return n(w(t)); }, keyword2hsv(t) { return a(w(t)); }, keyword2hwb(t) { return o(w(t)); }, keyword2cmyk(t) { return s(w(t)); }, keyword2lab(t) { return d(w(t)); }, keyword2xyz(t) { return u(w(t)); }, xyz2rgb: m, xyz2lab: v, xyz2lch(t) { return y(v(t)); }, lab2xyz: x, lab2rgb: k, lab2lch: y, lch2lab: M, lch2xyz(t) { return x(M(t)); }, lch2rgb(t) { return k(M(t)); },
    }; var S = {
      aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
    }; var C = {}; for (const _ in S)C[JSON.stringify(S[_])] = _;
  }, {}],
  5: [function (t, e, i) { const n = t(4); const a = function () { return new u(); }; for (const o in n) { a[`${o}Raw`] = (function (t) { return function (e) { return typeof e === 'number' && (e = Array.prototype.slice.call(arguments)), n[t](e); }; }(o)); const r = /(\w+)2(\w+)/.exec(o); const s = r[1]; const l = r[2]; (a[s] = a[s] || {})[l] = a[o] = (function (t) { return function (e) { typeof e === 'number' && (e = Array.prototype.slice.call(arguments)); const i = n[t](e); if (typeof i === 'string' || void 0 === i) return i; for (let a = 0; a < i.length; a++)i[a] = Math.round(i[a]); return i; }; }(o)); } var u = function () { this.convs = {}; }; u.prototype.routeSpace = function (t, e) { let i = e[0]; return void 0 === i ? this.getValues(t) : (typeof i === 'number' && (i = Array.prototype.slice.call(e)), this.setValues(t, i)); }, u.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this; }, u.prototype.getValues = function (t) { let e = this.convs[t]; if (!e) { const i = this.space; const n = this.convs[i]; e = a[i][t](n), this.convs[t] = e; } return e; }, ['rgb', 'hsl', 'hsv', 'cmyk', 'keyword'].forEach((t) => { u.prototype[t] = function (e) { return this.routeSpace(t, arguments); }; }), e.exports = a; }, { 4: 4 }],
  6: [function (t, e, i) {
    'use strict';

    e.exports = {
      aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
    };
  }, {}],
  7: [function (t, e, i) { const n = t(29)(); n.helpers = t(45), t(27)(n), n.defaults = t(25), n.Element = t(26), n.elements = t(40), n.Interaction = t(28), n.layouts = t(30), n.platform = t(48), n.plugins = t(31), n.Ticks = t(34), t(22)(n), t(23)(n), t(24)(n), t(33)(n), t(32)(n), t(35)(n), t(55)(n), t(53)(n), t(54)(n), t(56)(n), t(57)(n), t(58)(n), t(15)(n), t(16)(n), t(17)(n), t(18)(n), t(19)(n), t(20)(n), t(21)(n), t(8)(n), t(9)(n), t(10)(n), t(11)(n), t(12)(n), t(13)(n), t(14)(n); const a = t(49); for (const o in a)a.hasOwnProperty(o) && n.plugins.register(a[o]); n.platform.initialize(), e.exports = n, typeof window !== 'undefined' && (window.Chart = n), n.Legend = a.legend._element, n.Title = a.title._element, n.pluginService = n.plugins, n.PluginBase = n.Element.extend({}), n.canvasHelpers = n.helpers.canvas, n.layoutService = n.layouts; }, {
    10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 40: 40, 45: 45, 48: 48, 49: 49, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 8: 8, 9: 9,
  }],
  8: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Bar = function (e, i) { return i.type = 'bar', new t(e, i); }; };
  }, {}],
  9: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Bubble = function (e, i) { return i.type = 'bubble', new t(e, i); }; };
  }, {}],
  10: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Doughnut = function (e, i) { return i.type = 'doughnut', new t(e, i); }; };
  }, {}],
  11: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Line = function (e, i) { return i.type = 'line', new t(e, i); }; };
  }, {}],
  12: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.PolarArea = function (e, i) { return i.type = 'polarArea', new t(e, i); }; };
  }, {}],
  13: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Radar = function (e, i) { return i.type = 'radar', new t(e, i); }; };
  }, {}],
  14: [function (t, e, i) {
    'use strict';

    e.exports = function (t) { t.Scatter = function (e, i) { return i.type = 'scatter', new t(e, i); }; };
  }, {}],
  15: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('bar', {
      hover: { mode: 'label' },
      scales: {
        xAxes: [{
          type: 'category', categoryPercentage: 0.8, barPercentage: 0.9, offset: !0, gridLines: { offsetGridLines: !0 },
        }],
        yAxes: [{ type: 'linear' }],
      },
    }), n._set('horizontalBar', {
      hover: { mode: 'index', axis: 'y' },
      scales: {
        xAxes: [{ type: 'linear', position: 'bottom' }],
        yAxes: [{
          position: 'left', type: 'category', categoryPercentage: 0.8, barPercentage: 0.9, offset: !0, gridLines: { offsetGridLines: !0 },
        }],
      },
      elements: { rectangle: { borderSkipped: 'left' } },
      tooltips: { callbacks: { title(t, e) { let i = ''; return t.length > 0 && (t[0].yLabel ? i = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (i = e.labels[t[0].index])), i; }, label(t, e) { return `${e.datasets[t.datasetIndex].label || ''}: ${t.xLabel}`; } }, mode: 'index', axis: 'y' },
    }), e.exports = function (t) {
      t.controllers.bar = t.DatasetController.extend({
        dataElementType: a.Rectangle,
        initialize() { let e; t.DatasetController.prototype.initialize.apply(this, arguments), (e = this.getMeta()).stack = this.getDataset().stack, e.bar = !0; },
        update(t) { let e; let i; const n = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e) this.updateElement(n[e], e, t); },
        updateElement(t, e, i) {
          const n = this; const a = n.chart; const r = n.getMeta(); const s = n.getDataset(); const l = t.custom || {}; const u = a.options.elements.rectangle; t._xScale = n.getScaleForId(r.xAxisID), t._yScale = n.getScaleForId(r.yAxisID), t._datasetIndex = n.index, t._index = e, t._model = {
            datasetLabel: s.label, label: a.data.labels[e], borderSkipped: l.borderSkipped ? l.borderSkipped : u.borderSkipped, backgroundColor: l.backgroundColor ? l.backgroundColor : o.valueAtIndexOrDefault(s.backgroundColor, e, u.backgroundColor), borderColor: l.borderColor ? l.borderColor : o.valueAtIndexOrDefault(s.borderColor, e, u.borderColor), borderWidth: l.borderWidth ? l.borderWidth : o.valueAtIndexOrDefault(s.borderWidth, e, u.borderWidth),
          }, n.updateElementGeometry(t, e, i), t.pivot();
        },
        updateElementGeometry(t, e, i) { const n = this; const a = t._model; const o = n.getValueScale(); const r = o.getBasePixel(); const s = o.isHorizontal(); const l = n._ruler || n.getRuler(); const u = n.calculateBarValuePixels(n.index, e); const d = n.calculateBarIndexPixels(n.index, e, l); a.horizontal = s, a.base = i ? r : u.base, a.x = s ? i ? r : u.head : d.center, a.y = s ? d.center : i ? r : u.head, a.height = s ? d.size : void 0, a.width = s ? void 0 : d.size; },
        getValueScaleId() { return this.getMeta().yAxisID; },
        getIndexScaleId() { return this.getMeta().xAxisID; },
        getValueScale() { return this.getScaleForId(this.getValueScaleId()); },
        getIndexScale() { return this.getScaleForId(this.getIndexScaleId()); },
        _getStacks(t) { let e; let i; const n = this.chart; const a = this.getIndexScale().options.stacked; const o = void 0 === t ? n.data.datasets.length : t + 1; const r = []; for (e = 0; e < o; ++e)(i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && r.indexOf(i.stack) === -1 || void 0 === a && (void 0 === i.stack || r.indexOf(i.stack) === -1)) && r.push(i.stack); return r; },
        getStackCount() { return this._getStacks().length; },
        getStackIndex(t, e) { const i = this._getStacks(t); const n = void 0 !== e ? i.indexOf(e) : -1; return n === -1 ? i.length - 1 : n; },
        getRuler() {
          let t; let e; const i = this.getIndexScale(); const n = this.getStackCount(); const a = this.index; const r = i.isHorizontal(); const s = r ? i.left : i.top; const l = s + (r ? i.width : i.height); const u = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)u.push(i.getPixelForValue(null, t, a)); return {
            min: o.isNullOrUndef(i.options.barThickness) ? (function (t, e) { let i; let n; let a; let o; let r = t.isHorizontal() ? t.width : t.height; const s = t.getTicks(); for (a = 1, o = e.length; a < o; ++a)r = Math.min(r, e[a] - e[a - 1]); for (a = 0, o = s.length; a < o; ++a)n = t.getPixelForTick(a), r = a > 0 ? Math.min(r, n - i) : r, i = n; return r; }(i, u)) : -1, pixels: u, start: s, end: l, stackCount: n, scale: i,
          };
        },
        calculateBarValuePixels(t, e) {
          let i; let n; let a; let o; let r; let s; const l = this.chart; const u = this.getMeta(); const d = this.getValueScale(); const c = l.data.datasets; const h = d.getRightValue(c[t].data[e]); const f = d.options.stacked; const g = u.stack; let p = 0; if (f || void 0 === f && void 0 !== g) for (i = 0; i < t; ++i)(n = l.getDatasetMeta(i)).bar && n.stack === g && n.controller.getValueScaleId() === d.id && l.isDatasetVisible(i) && (a = d.getRightValue(c[i].data[e]), (h < 0 && a < 0 || h >= 0 && a > 0) && (p += a)); return o = d.getPixelForValue(p), {
            size: s = ((r = d.getPixelForValue(p + h)) - o) / 2, base: o, head: r, center: r + s / 2,
          };
        },
        calculateBarIndexPixels(t, e, i) {
          let n; let a; let r; let s; let l; let u; let d; let c; let h; let f; let g; let p; let m; let v; let b; let x; let y; const k = i.scale.options; const M = k.barThickness === 'flex' ? (h = e, g = k, m = (f = i).pixels, v = m[h], b = h > 0 ? m[h - 1] : null, x = h < m.length - 1 ? m[h + 1] : null, y = g.categoryPercentage, b === null && (b = v - (x === null ? f.end - v : x - v)), x === null && (x = v + v - b), p = v - (v - b) / 2 * y, { chunk: (x - b) / 2 * y / f.stackCount, ratio: g.barPercentage, start: p }) : (n = e, a = i, u = (r = k).barThickness, d = a.stackCount, c = a.pixels[n], o.isNullOrUndef(u) ? (s = a.min * r.categoryPercentage, l = r.barPercentage) : (s = u * d, l = 1), { chunk: s / d, ratio: l, start: c - s / 2 }); const w = this.getStackIndex(t, this.getMeta().stack); const S = M.start + M.chunk * w + M.chunk / 2; const C = Math.min(o.valueOrDefault(k.maxBarThickness, 1 / 0), M.chunk * M.ratio); return {
            base: S - C / 2, head: S + C / 2, center: S, size: C,
          };
        },
        draw() { const t = this.chart; const e = this.getValueScale(); const i = this.getMeta().data; const n = this.getDataset(); const a = i.length; let r = 0; for (o.canvas.clipArea(t.ctx, t.chartArea); r < a; ++r)isNaN(e.getRightValue(n.data[r])) || i[r].draw(); o.canvas.unclipArea(t.ctx); },
        setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t._index; const n = t.custom || {}; const a = t._model; a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : o.valueAtIndexOrDefault(e.hoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : o.valueAtIndexOrDefault(e.hoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : o.valueAtIndexOrDefault(e.hoverBorderWidth, i, a.borderWidth); },
        removeHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t._index; const n = t.custom || {}; const a = t._model; const r = this.chart.options.elements.rectangle; a.backgroundColor = n.backgroundColor ? n.backgroundColor : o.valueAtIndexOrDefault(e.backgroundColor, i, r.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : o.valueAtIndexOrDefault(e.borderColor, i, r.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : o.valueAtIndexOrDefault(e.borderWidth, i, r.borderWidth); },
      }), t.controllers.horizontalBar = t.controllers.bar.extend({ getValueScaleId() { return this.getMeta().xAxisID; }, getIndexScaleId() { return this.getMeta().yAxisID; } });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  16: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('bubble', { hover: { mode: 'single' }, scales: { xAxes: [{ type: 'linear', position: 'bottom', id: 'x-axis-0' }], yAxes: [{ type: 'linear', position: 'left', id: 'y-axis-0' }] }, tooltips: { callbacks: { title() { return ''; }, label(t, e) { const i = e.datasets[t.datasetIndex].label || ''; const n = e.datasets[t.datasetIndex].data[t.index]; return `${i}: (${t.xLabel}, ${t.yLabel}, ${n.r})`; } } } }), e.exports = function (t) {
      t.controllers.bubble = t.DatasetController.extend({
        dataElementType: a.Point,
        update(t) { const e = this; const i = e.getMeta().data; o.each(i, (i, n) => { e.updateElement(i, n, t); }); },
        updateElement(t, e, i) {
          const n = this; const a = n.getMeta(); const o = t.custom || {}; const r = n.getScaleForId(a.xAxisID); const s = n.getScaleForId(a.yAxisID); const l = n._resolveElementOptions(t, e); const u = n.getDataset().data[e]; const d = n.index; const c = i ? r.getPixelForDecimal(0.5) : r.getPixelForValue(typeof u === 'object' ? u : NaN, e, d); const h = i ? s.getBasePixel() : s.getPixelForValue(u, e, d); t._xScale = r, t._yScale = s, t._options = l, t._datasetIndex = d, t._index = e, t._model = {
            backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, hitRadius: l.hitRadius, pointStyle: l.pointStyle, radius: i ? 0 : l.radius, skip: o.skip || isNaN(c) || isNaN(h), x: c, y: h,
          }, t.pivot();
        },
        setHoverStyle(t) { const e = t._model; const i = t._options; e.backgroundColor = o.valueOrDefault(i.hoverBackgroundColor, o.getHoverColor(i.backgroundColor)), e.borderColor = o.valueOrDefault(i.hoverBorderColor, o.getHoverColor(i.borderColor)), e.borderWidth = o.valueOrDefault(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius; },
        removeHoverStyle(t) { const e = t._model; const i = t._options; e.backgroundColor = i.backgroundColor, e.borderColor = i.borderColor, e.borderWidth = i.borderWidth, e.radius = i.radius; },
        _resolveElementOptions(t, e) {
          let i; let n; let a; const r = this.chart; const s = r.data.datasets[this.index]; const l = t.custom || {}; const u = r.options.elements.point; const d = o.options.resolve; const c = s.data[e]; const h = {}; const f = {
            chart: r, dataIndex: e, dataset: s, datasetIndex: this.index,
          }; const g = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle']; for (i = 0, n = g.length; i < n; ++i)h[a = g[i]] = d([l[a], s[a], u[a]], f, e); return h.radius = d([l.radius, c ? c.r : void 0, s.radius, u.radius], f, e), h;
        },
      });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  17: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('doughnut', {
      animation: { animateRotate: !0, animateScale: !1 },
      hover: { mode: 'single' },
      legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); const i = t.data; const n = i.datasets; const a = i.labels; if (n.length) for (let o = 0; o < n[0].data.length; ++o)e.push(`<li><span style="background-color:${n[0].backgroundColor[o]}"></span>`), a[o] && e.push(a[o]), e.push('</li>'); return e.push('</ul>'), e.join(''); },
      legend: {
        labels: {
          generateLabels(t) {
            const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map((i, n) => {
              const a = t.getDatasetMeta(0); const r = e.datasets[0]; const s = a.data[n]; const l = s && s.custom || {}; const u = o.valueAtIndexOrDefault; const d = t.options.elements.arc; return {
                text: i, fillStyle: l.backgroundColor ? l.backgroundColor : u(r.backgroundColor, n, d.backgroundColor), strokeStyle: l.borderColor ? l.borderColor : u(r.borderColor, n, d.borderColor), lineWidth: l.borderWidth ? l.borderWidth : u(r.borderWidth, n, d.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n,
              };
            }) : [];
          },
        },
        onClick(t, e) { let i; let n; let a; const o = e.index; const r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o] && (a.data[o].hidden = !a.data[o].hidden); r.update(); },
      },
      cutoutPercentage: 50,
      rotation: -0.5 * Math.PI,
      circumference: 2 * Math.PI,
      tooltips: { callbacks: { title() { return ''; }, label(t, e) { let i = e.labels[t.index]; const n = `: ${e.datasets[t.datasetIndex].data[t.index]}`; return o.isArray(i) ? (i = i.slice())[0] += n : i += n, i; } } },
    }), n._set('pie', o.clone(n.doughnut)), n._set('pie', { cutoutPercentage: 0 }), e.exports = function (t) {
      t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({
        dataElementType: a.Arc,
        linkScales: o.noop,
        getRingIndex(t) { for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && ++e; return e; },
        update(t) { const e = this; const i = e.chart; const n = i.chartArea; const a = i.options; const r = a.elements.arc; const s = n.right - n.left - r.borderWidth; const l = n.bottom - n.top - r.borderWidth; let u = Math.min(s, l); let d = { x: 0, y: 0 }; const c = e.getMeta(); const h = a.cutoutPercentage; const f = a.circumference; if (f < 2 * Math.PI) { let g = a.rotation % (2 * Math.PI); const p = (g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0)) + f; const m = Math.cos(g); const v = Math.sin(g); const b = Math.cos(p); const x = Math.sin(p); const y = g <= 0 && p >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= p; const k = g <= 0.5 * Math.PI && 0.5 * Math.PI <= p || g <= 2.5 * Math.PI && 2.5 * Math.PI <= p; const M = g <= -Math.PI && -Math.PI <= p || g <= Math.PI && Math.PI <= p; const w = g <= 0.5 * -Math.PI && 0.5 * -Math.PI <= p || g <= 1.5 * Math.PI && 1.5 * Math.PI <= p; const S = h / 100; const C = M ? -1 : Math.min(m * (m < 0 ? 1 : S), b * (b < 0 ? 1 : S)); const _ = w ? -1 : Math.min(v * (v < 0 ? 1 : S), x * (x < 0 ? 1 : S)); const D = y ? 1 : Math.max(m * (m > 0 ? 1 : S), b * (b > 0 ? 1 : S)); const I = k ? 1 : Math.max(v * (v > 0 ? 1 : S), x * (x > 0 ? 1 : S)); const P = 0.5 * (D - C); const A = 0.5 * (I - _); u = Math.min(s / P, l / A), d = { x: -0.5 * (D + C), y: -0.5 * (I + _) }; }i.borderWidth = e.getMaxBorderWidth(c.data), i.outerRadius = Math.max((u - i.borderWidth) / 2, 0), i.innerRadius = Math.max(h ? i.outerRadius / 100 * h : 0, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = d.x * i.outerRadius, i.offsetY = d.y * i.outerRadius, c.total = e.calculateTotal(), e.outerRadius = i.outerRadius - i.radiusLength * e.getRingIndex(e.index), e.innerRadius = Math.max(e.outerRadius - i.radiusLength, 0), o.each(c.data, (i, n) => { e.updateElement(i, n, t); }); },
        updateElement(t, e, i) {
          const n = this; const a = n.chart; const r = a.chartArea; const s = a.options; const l = s.animation; const u = (r.left + r.right) / 2; const d = (r.top + r.bottom) / 2; const c = s.rotation; const h = s.rotation; const f = n.getDataset(); const g = i && l.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(f.data[e]) * (s.circumference / (2 * Math.PI)); const p = i && l.animateScale ? 0 : n.innerRadius; const m = i && l.animateScale ? 0 : n.outerRadius; const v = o.valueAtIndexOrDefault; o.extend(t, {
            _datasetIndex: n.index,
            _index: e,
            _model: {
              x: u + a.offsetX, y: d + a.offsetY, startAngle: c, endAngle: h, circumference: g, outerRadius: m, innerRadius: p, label: v(f.label, e, a.data.labels[e]),
            },
          }); const b = t._model; this.removeHoverStyle(t), i && l.animateRotate || (b.startAngle = e === 0 ? s.rotation : n.getMeta().data[e - 1]._model.endAngle, b.endAngle = b.startAngle + b.circumference), t.pivot();
        },
        removeHoverStyle(e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc); },
        calculateTotal() { let t; const e = this.getDataset(); const i = this.getMeta(); let n = 0; return o.each(i.data, (i, a) => { t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t)); }), n; },
        calculateCircumference(t) { const e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0; },
        getMaxBorderWidth(t) { for (var e, i, n = 0, a = this.index, o = t.length, r = 0; r < o; r++)e = t[r]._model ? t[r]._model.borderWidth : 0, n = (i = t[r]._chart ? t[r]._chart.config.data.datasets[a].hoverBorderWidth : 0) > (n = e > n ? e : n) ? i : n; return n; },
      });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  18: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('line', {
      showLines: !0, spanGaps: !1, hover: { mode: 'label' }, scales: { xAxes: [{ type: 'category', id: 'x-axis-0' }], yAxes: [{ type: 'linear', id: 'y-axis-0' }] },
    }), e.exports = function (t) {
      function e(t, e) { return o.valueOrDefault(t.showLine, e.showLines); }t.controllers.line = t.DatasetController.extend({
        datasetElementType: a.Line,
        dataElementType: a.Point,
        update(t) {
          let i; let n; let a; const r = this; const s = r.getMeta(); const l = s.dataset; const u = s.data || []; const d = r.chart.options; const c = d.elements.line; const h = r.getScaleForId(s.yAxisID); const f = r.getDataset(); const g = e(f, d); for (g && (a = l.custom || {}, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), l._scale = h, l._datasetIndex = r.index, l._children = u, l._model = {
            spanGaps: f.spanGaps ? f.spanGaps : d.spanGaps, tension: a.tension ? a.tension : o.valueOrDefault(f.lineTension, c.tension), backgroundColor: a.backgroundColor ? a.backgroundColor : f.backgroundColor || c.backgroundColor, borderWidth: a.borderWidth ? a.borderWidth : f.borderWidth || c.borderWidth, borderColor: a.borderColor ? a.borderColor : f.borderColor || c.borderColor, borderCapStyle: a.borderCapStyle ? a.borderCapStyle : f.borderCapStyle || c.borderCapStyle, borderDash: a.borderDash ? a.borderDash : f.borderDash || c.borderDash, borderDashOffset: a.borderDashOffset ? a.borderDashOffset : f.borderDashOffset || c.borderDashOffset, borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : f.borderJoinStyle || c.borderJoinStyle, fill: a.fill ? a.fill : void 0 !== f.fill ? f.fill : c.fill, steppedLine: a.steppedLine ? a.steppedLine : o.valueOrDefault(f.steppedLine, c.stepped), cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : o.valueOrDefault(f.cubicInterpolationMode, c.cubicInterpolationMode),
          }, l.pivot()), i = 0, n = u.length; i < n; ++i)r.updateElement(u[i], i, t); for (g && l._model.tension !== 0 && r.updateBezierControlPoints(), i = 0, n = u.length; i < n; ++i)u[i].pivot();
        },
        getPointBackgroundColor(t, e) { let i = this.chart.options.elements.point.backgroundColor; const n = this.getDataset(); const a = t.custom || {}; return a.backgroundColor ? i = a.backgroundColor : n.pointBackgroundColor ? i = o.valueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i; },
        getPointBorderColor(t, e) { let i = this.chart.options.elements.point.borderColor; const n = this.getDataset(); const a = t.custom || {}; return a.borderColor ? i = a.borderColor : n.pointBorderColor ? i = o.valueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i; },
        getPointBorderWidth(t, e) { let i = this.chart.options.elements.point.borderWidth; const n = this.getDataset(); const a = t.custom || {}; return isNaN(a.borderWidth) ? !isNaN(n.pointBorderWidth) || o.isArray(n.pointBorderWidth) ? i = o.valueAtIndexOrDefault(n.pointBorderWidth, e, i) : isNaN(n.borderWidth) || (i = n.borderWidth) : i = a.borderWidth, i; },
        updateElement(t, e, i) {
          let n; let a; const r = this; const s = r.getMeta(); const l = t.custom || {}; const u = r.getDataset(); const d = r.index; const c = u.data[e]; const h = r.getScaleForId(s.yAxisID); const f = r.getScaleForId(s.xAxisID); const g = r.chart.options.elements.point; void 0 !== u.radius && void 0 === u.pointRadius && (u.pointRadius = u.radius), void 0 !== u.hitRadius && void 0 === u.pointHitRadius && (u.pointHitRadius = u.hitRadius), n = f.getPixelForValue(typeof c === 'object' ? c : NaN, e, d), a = i ? h.getBasePixel() : r.calculatePointY(c, e, d), t._xScale = f, t._yScale = h, t._datasetIndex = d, t._index = e, t._model = {
            x: n, y: a, skip: l.skip || isNaN(n) || isNaN(a), radius: l.radius || o.valueAtIndexOrDefault(u.pointRadius, e, g.radius), pointStyle: l.pointStyle || o.valueAtIndexOrDefault(u.pointStyle, e, g.pointStyle), backgroundColor: r.getPointBackgroundColor(t, e), borderColor: r.getPointBorderColor(t, e), borderWidth: r.getPointBorderWidth(t, e), tension: s.dataset._model ? s.dataset._model.tension : 0, steppedLine: !!s.dataset._model && s.dataset._model.steppedLine, hitRadius: l.hitRadius || o.valueAtIndexOrDefault(u.pointHitRadius, e, g.hitRadius),
          };
        },
        calculatePointY(t, e, i) { let n; let a; let o; const r = this.chart; const s = this.getMeta(); const l = this.getScaleForId(s.yAxisID); let u = 0; let d = 0; if (l.options.stacked) { for (n = 0; n < i; n++) if (a = r.data.datasets[n], (o = r.getDatasetMeta(n)).type === 'line' && o.yAxisID === l.id && r.isDatasetVisible(n)) { const c = Number(l.getRightValue(a.data[e])); c < 0 ? d += c || 0 : u += c || 0; } const h = Number(l.getRightValue(t)); return h < 0 ? l.getPixelForValue(d + h) : l.getPixelForValue(u + h); } return l.getPixelForValue(t); },
        updateBezierControlPoints() { let t; let e; let i; let n; const a = this.getMeta(); const r = this.chart.chartArea; let s = a.data || []; function l(t, e, i) { return Math.max(Math.min(t, i), e); } if (a.dataset._model.spanGaps && (s = s.filter((t) => !t._model.skip)), a.dataset._model.cubicInterpolationMode === 'monotone')o.splineCurveMonotone(s); else for (t = 0, e = s.length; t < e; ++t)i = s[t]._model, n = o.splineCurve(o.previousItem(s, t)._model, i, o.nextItem(s, t)._model, a.dataset._model.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y; if (this.chart.options.elements.line.capBezierPoints) for (t = 0, e = s.length; t < e; ++t)(i = s[t]._model).controlPointPreviousX = l(i.controlPointPreviousX, r.left, r.right), i.controlPointPreviousY = l(i.controlPointPreviousY, r.top, r.bottom), i.controlPointNextX = l(i.controlPointNextX, r.left, r.right), i.controlPointNextY = l(i.controlPointNextY, r.top, r.bottom); },
        draw() { const t = this.chart; const i = this.getMeta(); const n = i.data || []; const a = t.chartArea; const r = n.length; let s = 0; for (o.canvas.clipArea(t.ctx, a), e(this.getDataset(), t.options) && i.dataset.draw(), o.canvas.unclipArea(t.ctx); s < r; ++s)n[s].draw(a); },
        setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t._index; const n = t.custom || {}; const a = t._model; a.radius = n.hoverRadius || o.valueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor || o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor || o.valueAtIndexOrDefault(e.pointHoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth || o.valueAtIndexOrDefault(e.pointHoverBorderWidth, i, a.borderWidth); },
        removeHoverStyle(t) { const e = this; const i = e.chart.data.datasets[t._datasetIndex]; const n = t._index; const a = t.custom || {}; const r = t._model; void 0 !== i.radius && void 0 === i.pointRadius && (i.pointRadius = i.radius), r.radius = a.radius || o.valueAtIndexOrDefault(i.pointRadius, n, e.chart.options.elements.point.radius), r.backgroundColor = e.getPointBackgroundColor(t, n), r.borderColor = e.getPointBorderColor(t, n), r.borderWidth = e.getPointBorderWidth(t, n); },
      });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  19: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('polarArea', {
      scale: {
        type: 'radialLinear', angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 },
      },
      animation: { animateRotate: !0, animateScale: !0 },
      startAngle: -0.5 * Math.PI,
      legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); const i = t.data; const n = i.datasets; const a = i.labels; if (n.length) for (let o = 0; o < n[0].data.length; ++o)e.push(`<li><span style="background-color:${n[0].backgroundColor[o]}"></span>`), a[o] && e.push(a[o]), e.push('</li>'); return e.push('</ul>'), e.join(''); },
      legend: {
        labels: {
          generateLabels(t) {
            const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map((i, n) => {
              const a = t.getDatasetMeta(0); const r = e.datasets[0]; const s = a.data[n].custom || {}; const l = o.valueAtIndexOrDefault; const u = t.options.elements.arc; return {
                text: i, fillStyle: s.backgroundColor ? s.backgroundColor : l(r.backgroundColor, n, u.backgroundColor), strokeStyle: s.borderColor ? s.borderColor : l(r.borderColor, n, u.borderColor), lineWidth: s.borderWidth ? s.borderWidth : l(r.borderWidth, n, u.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n,
              };
            }) : [];
          },
        },
        onClick(t, e) { let i; let n; let a; const o = e.index; const r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o].hidden = !a.data[o].hidden; r.update(); },
      },
      tooltips: { callbacks: { title() { return ''; }, label(t, e) { return `${e.labels[t.index]}: ${t.yLabel}`; } } },
    }), e.exports = function (t) {
      t.controllers.polarArea = t.DatasetController.extend({
        dataElementType: a.Arc,
        linkScales: o.noop,
        update(t) { const e = this; const i = e.chart; const n = i.chartArea; const a = e.getMeta(); const r = i.options; const s = r.elements.arc; const l = Math.min(n.right - n.left, n.bottom - n.top); i.outerRadius = Math.max((l - s.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(r.cutoutPercentage ? i.outerRadius / 100 * r.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), e.outerRadius = i.outerRadius - i.radiusLength * e.index, e.innerRadius = e.outerRadius - i.radiusLength, a.count = e.countVisibleElements(), o.each(a.data, (i, n) => { e.updateElement(i, n, t); }); },
        updateElement(t, e, i) {
          for (var n = this, a = n.chart, r = n.getDataset(), s = a.options, l = s.animation, u = a.scale, d = a.data.labels, c = n.calculateCircumference(r.data[e]), h = u.xCenter, f = u.yCenter, g = 0, p = n.getMeta(), m = 0; m < e; ++m)isNaN(r.data[m]) || p.data[m].hidden || ++g; const v = s.startAngle; const b = t.hidden ? 0 : u.getDistanceFromCenterForValue(r.data[e]); const x = v + c * g; const y = x + (t.hidden ? 0 : c); const k = l.animateScale ? 0 : u.getDistanceFromCenterForValue(r.data[e]); o.extend(t, {
            _datasetIndex: n.index,
            _index: e,
            _scale: u,
            _model: {
              x: h, y: f, innerRadius: 0, outerRadius: i ? k : b, startAngle: i && l.animateRotate ? v : x, endAngle: i && l.animateRotate ? v : y, label: o.valueAtIndexOrDefault(d, e, d[e]),
            },
          }), n.removeHoverStyle(t), t.pivot();
        },
        removeHoverStyle(e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc); },
        countVisibleElements() { const t = this.getDataset(); const e = this.getMeta(); let i = 0; return o.each(e.data, (e, n) => { isNaN(t.data[n]) || e.hidden || i++; }), i; },
        calculateCircumference(t) { const e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0; },
      });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  20: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('radar', { scale: { type: 'radialLinear' }, elements: { line: { tension: 0 } } }), e.exports = function (t) {
      t.controllers.radar = t.DatasetController.extend({
        datasetElementType: a.Line,
        dataElementType: a.Point,
        linkScales: o.noop,
        update(t) {
          const e = this; const i = e.getMeta(); const n = i.dataset; const a = i.data; const r = n.custom || {}; const s = e.getDataset(); const l = e.chart.options.elements.line; const u = e.chart.scale; void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), o.extend(i.dataset, {
            _datasetIndex: e.index,
            _scale: u,
            _children: a,
            _loop: !0,
            _model: {
              tension: r.tension ? r.tension : o.valueOrDefault(s.lineTension, l.tension), backgroundColor: r.backgroundColor ? r.backgroundColor : s.backgroundColor || l.backgroundColor, borderWidth: r.borderWidth ? r.borderWidth : s.borderWidth || l.borderWidth, borderColor: r.borderColor ? r.borderColor : s.borderColor || l.borderColor, fill: r.fill ? r.fill : void 0 !== s.fill ? s.fill : l.fill, borderCapStyle: r.borderCapStyle ? r.borderCapStyle : s.borderCapStyle || l.borderCapStyle, borderDash: r.borderDash ? r.borderDash : s.borderDash || l.borderDash, borderDashOffset: r.borderDashOffset ? r.borderDashOffset : s.borderDashOffset || l.borderDashOffset, borderJoinStyle: r.borderJoinStyle ? r.borderJoinStyle : s.borderJoinStyle || l.borderJoinStyle,
            },
          }), i.dataset.pivot(), o.each(a, (i, n) => { e.updateElement(i, n, t); }, e), e.updateBezierControlPoints();
        },
        updateElement(t, e, i) {
          const n = this; const a = t.custom || {}; const r = n.getDataset(); const s = n.chart.scale; const l = n.chart.options.elements.point; const u = s.getPointPositionForValue(e, r.data[e]); void 0 !== r.radius && void 0 === r.pointRadius && (r.pointRadius = r.radius), void 0 !== r.hitRadius && void 0 === r.pointHitRadius && (r.pointHitRadius = r.hitRadius), o.extend(t, {
            _datasetIndex: n.index,
            _index: e,
            _scale: s,
            _model: {
              x: i ? s.xCenter : u.x, y: i ? s.yCenter : u.y, tension: a.tension ? a.tension : o.valueOrDefault(r.lineTension, n.chart.options.elements.line.tension), radius: a.radius ? a.radius : o.valueAtIndexOrDefault(r.pointRadius, e, l.radius), backgroundColor: a.backgroundColor ? a.backgroundColor : o.valueAtIndexOrDefault(r.pointBackgroundColor, e, l.backgroundColor), borderColor: a.borderColor ? a.borderColor : o.valueAtIndexOrDefault(r.pointBorderColor, e, l.borderColor), borderWidth: a.borderWidth ? a.borderWidth : o.valueAtIndexOrDefault(r.pointBorderWidth, e, l.borderWidth), pointStyle: a.pointStyle ? a.pointStyle : o.valueAtIndexOrDefault(r.pointStyle, e, l.pointStyle), hitRadius: a.hitRadius ? a.hitRadius : o.valueAtIndexOrDefault(r.pointHitRadius, e, l.hitRadius),
            },
          }), t._model.skip = a.skip ? a.skip : isNaN(t._model.x) || isNaN(t._model.y);
        },
        updateBezierControlPoints() { const t = this.chart.chartArea; const e = this.getMeta(); o.each(e.data, (i, n) => { const a = i._model; const r = o.splineCurve(o.previousItem(e.data, n, !0)._model, a, o.nextItem(e.data, n, !0)._model, a.tension); a.controlPointPreviousX = Math.max(Math.min(r.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(r.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(r.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(r.next.y, t.bottom), t.top), i.pivot(); }); },
        setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t.custom || {}; const n = t._index; const a = t._model; a.radius = i.hoverRadius ? i.hoverRadius : o.valueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, n, o.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor ? i.hoverBorderColor : o.valueAtIndexOrDefault(e.pointHoverBorderColor, n, o.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : o.valueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth); },
        removeHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t.custom || {}; const n = t._index; const a = t._model; const r = this.chart.options.elements.point; a.radius = i.radius ? i.radius : o.valueAtIndexOrDefault(e.pointRadius, n, r.radius), a.backgroundColor = i.backgroundColor ? i.backgroundColor : o.valueAtIndexOrDefault(e.pointBackgroundColor, n, r.backgroundColor), a.borderColor = i.borderColor ? i.borderColor : o.valueAtIndexOrDefault(e.pointBorderColor, n, r.borderColor), a.borderWidth = i.borderWidth ? i.borderWidth : o.valueAtIndexOrDefault(e.pointBorderWidth, n, r.borderWidth); },
      });
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  21: [function (t, e, i) {
    'use strict';

    t(25)._set('scatter', {
      hover: { mode: 'single' }, scales: { xAxes: [{ id: 'x-axis-1', type: 'linear', position: 'bottom' }], yAxes: [{ id: 'y-axis-1', type: 'linear', position: 'left' }] }, showLines: !1, tooltips: { callbacks: { title() { return ''; }, label(t) { return `(${t.xLabel}, ${t.yLabel})`; } } },
    }), e.exports = function (t) { t.controllers.scatter = t.controllers.line; };
  }, { 25: 25 }],
  22: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); n._set('global', {
      animation: {
        duration: 1e3, easing: 'easeOutQuart', onProgress: o.noop, onComplete: o.noop,
      },
    }), e.exports = function (t) {
      t.Animation = a.extend({
        chart: null, currentStep: 0, numSteps: 60, easing: '', render: null, onAnimationProgress: null, onAnimationComplete: null,
      }), t.animationService = {
        frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation(t, e, i, n) { let a; let o; const r = this.animations; for (e.chart = t, n || (t.animating = !0), a = 0, o = r.length; a < o; ++a) if (r[a].chart === t) return void (r[a] = e); r.push(e), r.length === 1 && this.requestAnimationFrame(); }, cancelAnimation(t) { const e = o.findIndex(this.animations, (e) => e.chart === t); e !== -1 && (this.animations.splice(e, 1), t.animating = !1); }, requestAnimationFrame() { const t = this; t.request === null && (t.request = o.requestAnimFrame.call(window, () => { t.request = null, t.startDigest(); })); }, startDigest() { const t = this; const e = Date.now(); let i = 0; t.dropFrames > 1 && (i = Math.floor(t.dropFrames), t.dropFrames %= 1), t.advance(1 + i); const n = Date.now(); t.dropFrames += (n - e) / t.frameDuration, t.animations.length > 0 && t.requestAnimationFrame(); }, advance(t) { for (var e, i, n = this.animations, a = 0; a < n.length;)i = (e = n[a]).chart, e.currentStep = (e.currentStep || 0) + t, e.currentStep = Math.min(e.currentStep, e.numSteps), o.callback(e.render, [i, e], i), o.callback(e.onAnimationProgress, [e], i), e.currentStep >= e.numSteps ? (o.callback(e.onAnimationComplete, [e], i), i.animating = !1, n.splice(a, 1)) : ++a; },
      }, Object.defineProperty(t.Animation.prototype, 'animationObject', { get() { return this; } }), Object.defineProperty(t.Animation.prototype, 'chartInstance', { get() { return this.chart; }, set(t) { this.chart = t; } });
    };
  }, { 25: 25, 26: 26, 45: 45 }],
  23: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(45); const o = t(28); const r = t(30); const s = t(48); const l = t(31); e.exports = function (t) {
      function e(t) { return t === 'top' || t === 'bottom'; }t.types = {}, t.instances = {}, t.controllers = {}, a.extend(t.prototype, {
        construct(e, i) { let o; let r; const l = this; (r = (o = (o = i) || {}).data = o.data || {}).datasets = r.datasets || [], r.labels = r.labels || [], o.options = a.configMerge(n.global, n[o.type], o.options || {}), i = o; const u = s.acquireContext(e, i); const d = u && u.canvas; const c = d && d.height; const h = d && d.width; l.id = a.uid(), l.ctx = u, l.canvas = d, l.config = i, l.width = h, l.height = c, l.aspectRatio = c ? h / c : null, l.options = i.options, l._bufferedRender = !1, l.chart = l, l.controller = l, t.instances[l.id] = l, Object.defineProperty(l, 'data', { get() { return l.config.data; }, set(t) { l.config.data = t; } }), u && d ? (l.initialize(), l.update()) : console.error("Failed to create chart: can't acquire context from the given item"); },
        initialize() { const t = this; return l.notify(t, 'beforeInit'), a.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), l.notify(t, 'afterInit'), t; },
        clear() { return a.canvas.clear(this), this; },
        stop() { return t.animationService.cancelAnimation(this), this; },
        resize(t) { const e = this; const i = e.options; const n = e.canvas; const o = i.maintainAspectRatio && e.aspectRatio || null; const r = Math.max(0, Math.floor(a.getMaximumWidth(n))); const s = Math.max(0, Math.floor(o ? r / o : a.getMaximumHeight(n))); if ((e.width !== r || e.height !== s) && (n.width = e.width = r, n.height = e.height = s, n.style.width = `${r}px`, n.style.height = `${s}px`, a.retinaScale(e, i.devicePixelRatio), !t)) { const u = { width: r, height: s }; l.notify(e, 'resize', [u]), e.options.onResize && e.options.onResize(e, u), e.stop(), e.update(e.options.responsiveAnimationDuration); } },
        ensureScalesHaveIDs() { const t = this.options; const e = t.scales || {}; const i = t.scale; a.each(e.xAxes, (t, e) => { t.id = t.id || `x-axis-${e}`; }), a.each(e.yAxes, (t, e) => { t.id = t.id || `y-axis-${e}`; }), i && (i.id = i.id || 'scale'); },
        buildOrUpdateScales() {
          const i = this; const n = i.options; const o = i.scales || {}; let r = []; const s = Object.keys(o).reduce((t, e) => (t[e] = !1, t), {}); n.scales && (r = r.concat((n.scales.xAxes || []).map((t) => ({ options: t, dtype: 'category', dposition: 'bottom' })), (n.scales.yAxes || []).map((t) => ({ options: t, dtype: 'linear', dposition: 'left' })))), n.scale && r.push({
            options: n.scale, dtype: 'radialLinear', isDefault: !0, dposition: 'chartArea',
          }), a.each(r, (n) => {
            const r = n.options; const l = r.id; const u = a.valueOrDefault(r.type, n.dtype); e(r.position) !== e(n.dposition) && (r.position = n.dposition), s[l] = !0; let d = null; if (l in o && o[l].type === u)(d = o[l]).options = r, d.ctx = i.ctx, d.chart = i; else {
              const c = t.scaleService.getScaleConstructor(u); if (!c) return; d = new c({
                id: l, type: u, options: r, ctx: i.ctx, chart: i,
              }), o[d.id] = d;
            }d.mergeTicksOptions(), n.isDefault && (i.scale = d);
          }), a.each(s, (t, e) => { t || delete o[e]; }), i.scales = o, t.scaleService.addScalesToLayout(this);
        },
        buildOrUpdateControllers() { const e = this; const i = []; const n = []; return a.each(e.data.datasets, (a, o) => { let r = e.getDatasetMeta(o); const s = a.type || e.config.type; if (r.type && r.type !== s && (e.destroyDatasetMeta(o), r = e.getDatasetMeta(o)), r.type = s, i.push(r.type), r.controller)r.controller.updateIndex(o), r.controller.linkScales(); else { const l = t.controllers[r.type]; if (void 0 === l) throw new Error(`"${r.type}" is not a chart type.`); r.controller = new l(e, o), n.push(r.controller); } }, e), n; },
        resetElements() { const t = this; a.each(t.data.datasets, (e, i) => { t.getDatasetMeta(i).controller.reset(); }, t); },
        reset() { this.resetElements(), this.tooltip.initialize(); },
        update(e) { let i; let n; const o = this; if (e && typeof e === 'object' || (e = { duration: e, lazy: arguments[1] }), n = (i = o).options, a.each(i.scales, (t) => { r.removeBox(i, t); }), n = a.configMerge(t.defaults.global, t.defaults[i.config.type], n), i.options = i.config.options = n, i.ensureScalesHaveIDs(), i.buildOrUpdateScales(), i.tooltip._options = n.tooltips, i.tooltip.initialize(), l._invalidate(o), !1 !== l.notify(o, 'beforeUpdate')) { o.tooltip._data = o.data; const s = o.buildOrUpdateControllers(); a.each(o.data.datasets, (t, e) => { o.getDatasetMeta(e).controller.buildOrUpdateElements(); }, o), o.updateLayout(), o.options.animation && o.options.animation.duration && a.each(s, (t) => { t.reset(); }), o.updateDatasets(), o.tooltip.initialize(), o.lastActive = [], l.notify(o, 'afterUpdate'), o._bufferedRender ? o._bufferedRequest = { duration: e.duration, easing: e.easing, lazy: e.lazy } : o.render(e); } },
        updateLayout() { !1 !== l.notify(this, 'beforeLayout') && (r.update(this, this.width, this.height), l.notify(this, 'afterScaleUpdate'), l.notify(this, 'afterLayout')); },
        updateDatasets() { if (!1 !== l.notify(this, 'beforeDatasetsUpdate')) { for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.updateDataset(t); l.notify(this, 'afterDatasetsUpdate'); } },
        updateDataset(t) { const e = this.getDatasetMeta(t); const i = { meta: e, index: t }; !1 !== l.notify(this, 'beforeDatasetUpdate', [i]) && (e.controller.update(), l.notify(this, 'afterDatasetUpdate', [i])); },
        render(e) {
          const i = this; e && typeof e === 'object' || (e = { duration: e, lazy: arguments[1] }); const n = e.duration; const o = e.lazy; if (!1 !== l.notify(i, 'beforeRender')) {
            const r = i.options.animation; const s = function (t) { l.notify(i, 'afterRender'), a.callback(r && r.onComplete, [t], i); }; if (r && (void 0 !== n && n !== 0 || void 0 === n && r.duration !== 0)) {
              const u = new t.Animation({
                numSteps: (n || r.duration) / 16.66, easing: e.easing || r.easing, render(t, e) { const i = a.easing.effects[e.easing]; const n = e.currentStep; const o = n / e.numSteps; t.draw(i(o), o, n); }, onAnimationProgress: r.onProgress, onAnimationComplete: s,
              }); t.animationService.addAnimation(i, u, n, o);
            } else i.draw(), s(new t.Animation({ numSteps: 0, chart: i })); return i;
          }
        },
        draw(t) { const e = this; e.clear(), a.isNullOrUndef(t) && (t = 1), e.transition(t), !1 !== l.notify(e, 'beforeDraw', [t]) && (a.each(e.boxes, (t) => { t.draw(e.chartArea); }, e), e.scale && e.scale.draw(), e.drawDatasets(t), e._drawTooltip(t), l.notify(e, 'afterDraw', [t])); },
        transition(t) { for (let e = 0, i = (this.data.datasets || []).length; e < i; ++e) this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t); },
        drawDatasets(t) { const e = this; if (!1 !== l.notify(e, 'beforeDatasetsDraw', [t])) { for (let i = (e.data.datasets || []).length - 1; i >= 0; --i)e.isDatasetVisible(i) && e.drawDataset(i, t); l.notify(e, 'afterDatasetsDraw', [t]); } },
        drawDataset(t, e) { const i = this.getDatasetMeta(t); const n = { meta: i, index: t, easingValue: e }; !1 !== l.notify(this, 'beforeDatasetDraw', [n]) && (i.controller.draw(e), l.notify(this, 'afterDatasetDraw', [n])); },
        _drawTooltip(t) { const e = this.tooltip; const i = { tooltip: e, easingValue: t }; !1 !== l.notify(this, 'beforeTooltipDraw', [i]) && (e.draw(), l.notify(this, 'afterTooltipDraw', [i])); },
        getElementAtEvent(t) { return o.modes.single(this, t); },
        getElementsAtEvent(t) { return o.modes.label(this, t, { intersect: !0 }); },
        getElementsAtXAxis(t) { return o.modes['x-axis'](this, t, { intersect: !0 }); },
        getElementsAtEventForMode(t, e, i) { const n = o.modes[e]; return typeof n === 'function' ? n(this, t, i) : []; },
        getDatasetAtEvent(t) { return o.modes.dataset(this, t, { intersect: !0 }); },
        getDatasetMeta(t) {
          const e = this.data.datasets[t]; e._meta || (e._meta = {}); let i = e._meta[this.id]; return i || (i = e._meta[this.id] = {
            type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null,
          }), i;
        },
        getVisibleDatasetCount() { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e) this.isDatasetVisible(e) && t++; return t; },
        isDatasetVisible(t) { const e = this.getDatasetMeta(t); return typeof e.hidden === 'boolean' ? !e.hidden : !this.data.datasets[t].hidden; },
        generateLegend() { return this.options.legendCallback(this); },
        destroyDatasetMeta(t) { const e = this.id; const i = this.data.datasets[t]; const n = i._meta && i._meta[e]; n && (n.controller.destroy(), delete i._meta[e]); },
        destroy() { let e; let i; const n = this; const o = n.canvas; for (n.stop(), e = 0, i = n.data.datasets.length; e < i; ++e)n.destroyDatasetMeta(e); o && (n.unbindEvents(), a.canvas.clear(n), s.releaseContext(n.ctx), n.canvas = null, n.ctx = null), l.notify(n, 'destroy'), delete t.instances[n.id]; },
        toBase64Image() { return this.canvas.toDataURL.apply(this.canvas, arguments); },
        initToolTip() {
          const e = this; e.tooltip = new t.Tooltip({
            _chart: e, _chartInstance: e, _data: e.data, _options: e.options.tooltips,
          }, e);
        },
        bindEvents() { const t = this; const e = t._listeners = {}; let i = function () { t.eventHandler.apply(t, arguments); }; a.each(t.options.events, (n) => { s.addEventListener(t, n, i), e[n] = i; }), t.options.responsive && (i = function () { t.resize(); }, s.addEventListener(t, 'resize', i), e.resize = i); },
        unbindEvents() { const t = this; const e = t._listeners; e && (delete t._listeners, a.each(e, (e, i) => { s.removeEventListener(t, i, e); })); },
        updateHoverStyle(t, e, i) { let n; let a; let o; const r = i ? 'setHoverStyle' : 'removeHoverStyle'; for (a = 0, o = t.length; a < o; ++a)(n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[r](n); },
        eventHandler(t) { const e = this; const i = e.tooltip; if (!1 !== l.notify(e, 'beforeEvent', [t])) { e._bufferedRender = !0, e._bufferedRequest = null; let n = e.handleEvent(t); i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), l.notify(e, 'afterEvent', [t]); const a = e._bufferedRequest; return a ? e.render(a) : n && !e.animating && (e.stop(), e.render(e.options.hover.animationDuration, !0)), e._bufferedRender = !1, e._bufferedRequest = null, e; } },
        handleEvent(t) { let e; const i = this; const n = i.options || {}; const o = n.hover; return i.lastActive = i.lastActive || [], t.type === 'mouseout' ? i.active = [] : i.active = i.getElementsAtEventForMode(t, o.mode, o), a.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), t.type !== 'mouseup' && t.type !== 'click' || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, o.mode, !1), i.active.length && o.mode && i.updateHoverStyle(i.active, o.mode, !0), e = !a.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e; },
      }), t.Controller = t;
    };
  }, {
    25: 25, 28: 28, 30: 30, 31: 31, 45: 45, 48: 48,
  }],
  24: [function (t, e, i) {
    'use strict';

    const n = t(45); e.exports = function (t) {
      const e = ['push', 'pop', 'shift', 'splice', 'unshift']; function i(t, i) { const n = t._chartjs; if (n) { const a = n.listeners; const o = a.indexOf(i); o !== -1 && a.splice(o, 1), a.length > 0 || (e.forEach((e) => { delete t[e]; }), delete t._chartjs); } }t.DatasetController = function (t, e) { this.initialize(t, e); }, n.extend(t.DatasetController.prototype, {
        datasetElementType: null, dataElementType: null, initialize(t, e) { this.chart = t, this.index = e, this.linkScales(), this.addElements(); }, updateIndex(t) { this.index = t; }, linkScales() { const t = this; const e = t.getMeta(); const i = t.getDataset(); e.xAxisID !== null && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), e.yAxisID !== null && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id); }, getDataset() { return this.chart.data.datasets[this.index]; }, getMeta() { return this.chart.getDatasetMeta(this.index); }, getScaleForId(t) { return this.chart.scales[t]; }, reset() { this.update(!0); }, destroy() { this._data && i(this._data, this); }, createMetaDataset() { const t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }); }, createMetaData(t) { const e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }); }, addElements() { let t; let e; const i = this.getMeta(); const n = this.getDataset().data || []; const a = i.data; for (t = 0, e = n.length; t < e; ++t)a[t] = a[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset(); }, addElementAndReset(t) { const e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0); }, buildOrUpdateElements() { let t; let a; const o = this; const r = o.getDataset(); const s = r.data || (r.data = []); o._data !== s && (o._data && i(o._data, o), a = o, (t = s)._chartjs ? t._chartjs.listeners.push(a) : (Object.defineProperty(t, '_chartjs', { configurable: !0, enumerable: !1, value: { listeners: [a] } }), e.forEach((e) => { const i = `onData${e.charAt(0).toUpperCase()}${e.slice(1)}`; const a = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value() { const e = Array.prototype.slice.call(arguments); const o = a.apply(this, e); return n.each(t._chartjs.listeners, (t) => { typeof t[i] === 'function' && t[i].apply(t, e); }), o; } }); })), o._data = s), o.resyncElements(); }, update: n.noop, transition(t) { for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a)i[a].transition(t); e.dataset && e.dataset.transition(t); }, draw() { const t = this.getMeta(); const e = t.data || []; const i = e.length; let n = 0; for (t.dataset && t.dataset.draw(); n < i; ++n)e[n].draw(); }, removeHoverStyle(t, e) { const i = this.chart.data.datasets[t._datasetIndex]; const a = t._index; const o = t.custom || {}; const r = n.valueAtIndexOrDefault; const s = t._model; s.backgroundColor = o.backgroundColor ? o.backgroundColor : r(i.backgroundColor, a, e.backgroundColor), s.borderColor = o.borderColor ? o.borderColor : r(i.borderColor, a, e.borderColor), s.borderWidth = o.borderWidth ? o.borderWidth : r(i.borderWidth, a, e.borderWidth); }, setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t._index; const a = t.custom || {}; const o = n.valueAtIndexOrDefault; const r = n.getHoverColor; const s = t._model; s.backgroundColor = a.hoverBackgroundColor ? a.hoverBackgroundColor : o(e.hoverBackgroundColor, i, r(s.backgroundColor)), s.borderColor = a.hoverBorderColor ? a.hoverBorderColor : o(e.hoverBorderColor, i, r(s.borderColor)), s.borderWidth = a.hoverBorderWidth ? a.hoverBorderWidth : o(e.hoverBorderWidth, i, s.borderWidth); }, resyncElements() { const t = this.getMeta(); const e = this.getDataset().data; const i = t.data.length; const n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i); }, insertElements(t, e) { for (let i = 0; i < e; ++i) this.addElementAndReset(t + i); }, onDataPush() { this.insertElements(this.getDataset().data.length - 1, arguments.length); }, onDataPop() { this.getMeta().data.pop(); }, onDataShift() { this.getMeta().data.shift(); }, onDataSplice(t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2); }, onDataUnshift() { this.insertElements(0, arguments.length); },
      }), t.DatasetController.extend = n.inherits;
    };
  }, { 45: 45 }],
  25: [function (t, e, i) {
    'use strict';

    const n = t(45); e.exports = { _set(t, e) { return n.merge(this[t] || (this[t] = {}), e); } };
  }, { 45: 45 }],
  26: [function (t, e, i) {
    'use strict';

    const n = t(3); const a = t(45); const o = function (t) { a.extend(this, t), this.initialize.apply(this, arguments); }; a.extend(o.prototype, {
      initialize() { this.hidden = !1; }, pivot() { const t = this; return t._view || (t._view = a.clone(t._model)), t._start = {}, t; }, transition(t) { const e = this; const i = e._model; let a = e._start; let o = e._view; return i && t !== 1 ? (o || (o = e._view = {}), a || (a = e._start = {}), (function (t, e, i, a) { let o; let r; let s; let l; let u; let d; let c; let h; let f; const g = Object.keys(i); for (o = 0, r = g.length; o < r; ++o) if (d = i[s = g[o]], e.hasOwnProperty(s) || (e[s] = d), (l = e[s]) !== d && s[0] !== '_') { if (t.hasOwnProperty(s) || (t[s] = l), (c = typeof d) === typeof (u = t[s])) if (c === 'string') { if ((h = n(u)).valid && (f = n(d)).valid) { e[s] = f.mix(h, a).rgbString(); continue; } } else if (c === 'number' && isFinite(u) && isFinite(d)) { e[s] = u + (d - u) * a; continue; }e[s] = d; } }(a, o, i, t)), e) : (e._view = i, e._start = null, e); }, tooltipPosition() { return { x: this._model.x, y: this._model.y }; }, hasValue() { return a.isNumber(this._model.x) && a.isNumber(this._model.y); },
    }), o.extend = a.inherits, e.exports = o;
  }, { 3: 3, 45: 45 }],
  27: [function (t, e, i) {
    'use strict';

    const n = t(3); const a = t(25); const o = t(45); e.exports = function (t) { function e(t, e, i) { let n; return typeof t === 'string' ? (n = parseInt(t, 10), t.indexOf('%') !== -1 && (n = n / 100 * e.parentNode[i])) : n = t, n; } function i(t) { return t != null && t !== 'none'; } function r(t, n, a) { const o = document.defaultView; const r = t.parentNode; const s = o.getComputedStyle(t)[n]; const l = o.getComputedStyle(r)[n]; const u = i(s); const d = i(l); const c = Number.POSITIVE_INFINITY; return u || d ? Math.min(u ? e(s, t, a) : c, d ? e(l, r, a) : c) : 'none'; }o.configMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger(e, i, n, a) { const r = i[e] || {}; const s = n[e]; e === 'scales' ? i[e] = o.scaleMerge(r, s) : e === 'scale' ? i[e] = o.merge(r, [t.scaleService.getScaleDefaults(s.type), s]) : o._merger(e, i, n, a); } }); }, o.scaleMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger(e, i, n, a) { if (e === 'xAxes' || e === 'yAxes') { let r; let s; let l; const u = n[e].length; for (i[e] || (i[e] = []), r = 0; r < u; ++r)l = n[e][r], s = o.valueOrDefault(l.type, e === 'xAxes' ? 'category' : 'linear'), r >= i[e].length && i[e].push({}), !i[e][r].type || l.type && l.type !== i[e][r].type ? o.merge(i[e][r], [t.scaleService.getScaleDefaults(s), l]) : o.merge(i[e][r], l); } else o._merger(e, i, n, a); } }); }, o.where = function (t, e) { if (o.isArray(t) && Array.prototype.filter) return t.filter(e); const i = []; return o.each(t, (t) => { e(t) && i.push(t); }), i; }, o.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i); } : function (t, e, i) { i = void 0 === i ? t : i; for (let n = 0, a = t.length; n < a; ++n) if (e.call(i, t[n], n, t)) return n; return -1; }, o.findNextWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = -1); for (let n = i + 1; n < t.length; n++) { const a = t[n]; if (e(a)) return a; } }, o.findPreviousWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = t.length); for (let n = i - 1; n >= 0; n--) { const a = t[n]; if (e(a)) return a; } }, o.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t); }, o.almostEquals = function (t, e, i) { return Math.abs(t - e) < i; }, o.almostWhole = function (t, e) { const i = Math.round(t); return i - e < t && i + e > t; }, o.max = function (t) { return t.reduce((t, e) => (isNaN(e) ? t : Math.max(t, e)), Number.NEGATIVE_INFINITY); }, o.min = function (t) { return t.reduce((t, e) => (isNaN(e) ? t : Math.min(t, e)), Number.POSITIVE_INFINITY); }, o.sign = Math.sign ? function (t) { return Math.sign(t); } : function (t) { return (t = +t) === 0 || isNaN(t) ? t : t > 0 ? 1 : -1; }, o.log10 = Math.log10 ? function (t) { return Math.log10(t); } : function (t) { const e = Math.log(t) * Math.LOG10E; const i = Math.round(e); return t === 10 ** i ? i : e; }, o.toRadians = function (t) { return t * (Math.PI / 180); }, o.toDegrees = function (t) { return t * (180 / Math.PI); }, o.getAngleFromPoint = function (t, e) { const i = e.x - t.x; const n = e.y - t.y; const a = Math.sqrt(i * i + n * n); let o = Math.atan2(n, i); return o < -0.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: a }; }, o.distanceBetweenPoints = function (t, e) { return Math.sqrt((e.x - t.x) ** 2 + (e.y - t.y) ** 2); }, o.aliasPixel = function (t) { return t % 2 == 0 ? 0 : 0.5; }, o.splineCurve = function (t, e, i, n) { const a = t.skip ? e : t; const o = e; const r = i.skip ? e : i; const s = Math.sqrt((o.x - a.x) ** 2 + (o.y - a.y) ** 2); const l = Math.sqrt((r.x - o.x) ** 2 + (r.y - o.y) ** 2); let u = s / (s + l); let d = l / (s + l); const c = n * (u = isNaN(u) ? 0 : u); const h = n * (d = isNaN(d) ? 0 : d); return { previous: { x: o.x - c * (r.x - a.x), y: o.y - c * (r.y - a.y) }, next: { x: o.x + h * (r.x - a.x), y: o.y + h * (r.y - a.y) } }; }, o.EPSILON = Number.EPSILON || 1e-14, o.splineCurveMonotone = function (t) { let e; let i; let n; let a; let r; let s; let l; let u; let d; const c = (t || []).map((t) => ({ model: t._model, deltaK: 0, mK: 0 })); const h = c.length; for (e = 0; e < h; ++e) if (!(n = c[e]).model.skip) { if (i = e > 0 ? c[e - 1] : null, (a = e < h - 1 ? c[e + 1] : null) && !a.model.skip) { const f = a.model.x - n.model.x; n.deltaK = f !== 0 ? (a.model.y - n.model.y) / f : 0; }!i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2; } for (e = 0; e < h - 1; ++e)n = c[e], a = c[e + 1], n.model.skip || a.model.skip || (o.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (r = n.mK / n.deltaK, s = a.mK / n.deltaK, (u = r ** 2 + s ** 2) <= 9 || (l = 3 / Math.sqrt(u), n.mK = r * l * n.deltaK, a.mK = s * l * n.deltaK))); for (e = 0; e < h; ++e)(n = c[e]).model.skip || (i = e > 0 ? c[e - 1] : null, a = e < h - 1 ? c[e + 1] : null, i && !i.model.skip && (d = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - d, n.model.controlPointPreviousY = n.model.y - d * n.mK), a && !a.model.skip && (d = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + d, n.model.controlPointNextY = n.model.y + d * n.mK)); }, o.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]; }, o.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]; }, o.niceNum = function (t, e) { const i = Math.floor(o.log10(t)); const n = t / 10 ** i; return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * 10 ** i; }, o.requestAnimFrame = typeof window === 'undefined' ? function (t) { t(); } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60); }, o.getRelativePosition = function (t, e) { let i; let n; const a = t.originalEvent || t; const r = t.currentTarget || t.srcElement; const s = r.getBoundingClientRect(); const l = a.touches; l && l.length > 0 ? (i = l[0].clientX, n = l[0].clientY) : (i = a.clientX, n = a.clientY); const u = parseFloat(o.getStyle(r, 'padding-left')); const d = parseFloat(o.getStyle(r, 'padding-top')); const c = parseFloat(o.getStyle(r, 'padding-right')); const h = parseFloat(o.getStyle(r, 'padding-bottom')); const f = s.right - s.left - u - c; const g = s.bottom - s.top - d - h; return { x: i = Math.round((i - s.left - u) / f * r.width / e.currentDevicePixelRatio), y: n = Math.round((n - s.top - d) / g * r.height / e.currentDevicePixelRatio) }; }, o.getConstraintWidth = function (t) { return r(t, 'max-width', 'clientWidth'); }, o.getConstraintHeight = function (t) { return r(t, 'max-height', 'clientHeight'); }, o.getMaximumWidth = function (t) { const e = t.parentNode; if (!e) return t.clientWidth; const i = parseInt(o.getStyle(e, 'padding-left'), 10); const n = parseInt(o.getStyle(e, 'padding-right'), 10); const a = e.clientWidth - i - n; const r = o.getConstraintWidth(t); return isNaN(r) ? a : Math.min(a, r); }, o.getMaximumHeight = function (t) { const e = t.parentNode; if (!e) return t.clientHeight; const i = parseInt(o.getStyle(e, 'padding-top'), 10); const n = parseInt(o.getStyle(e, 'padding-bottom'), 10); const a = e.clientHeight - i - n; const r = o.getConstraintHeight(t); return isNaN(r) ? a : Math.min(a, r); }, o.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e); }, o.retinaScale = function (t, e) { const i = t.currentDevicePixelRatio = e || window.devicePixelRatio || 1; if (i !== 1) { const n = t.canvas; const a = t.height; const o = t.width; n.height = a * i, n.width = o * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = `${a}px`, n.style.width = `${o}px`); } }, o.fontString = function (t, e, i) { return `${e} ${t}px ${i}`; }, o.longestText = function (t, e, i, n) { let a = (n = n || {}).data = n.data || {}; let r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, r = n.garbageCollect = [], n.font = e), t.font = e; let s = 0; o.each(i, (e) => { e != null && !0 !== o.isArray(e) ? s = o.measureText(t, a, r, s, e) : o.isArray(e) && o.each(e, (e) => { e == null || o.isArray(e) || (s = o.measureText(t, a, r, s, e)); }); }); const l = r.length / 2; if (l > i.length) { for (let u = 0; u < l; u++) delete a[r[u]]; r.splice(0, l); } return s; }, o.measureText = function (t, e, i, n, a) { let o = e[a]; return o || (o = e[a] = t.measureText(a).width, i.push(a)), o > n && (n = o), n; }, o.numberOfLabelLines = function (t) { let e = 1; return o.each(t, (t) => { o.isArray(t) && t.length > e && (e = t.length); }), e; }, o.color = n ? function (t) { return t instanceof CanvasGradient && (t = a.global.defaultColor), n(t); } : function (t) { return console.error('Color.js not found!'), t; }, o.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : o.color(t).saturate(0.5).darken(0.1).rgbString(); }; };
  }, { 25: 25, 3: 3, 45: 45 }],
  28: [function (t, e, i) {
    'use strict';

    const n = t(45); function a(t, e) { return t.native ? { x: t.x, y: t.y } : n.getRelativePosition(t, e); } function o(t, e) { let i; let n; let a; let o; let r; for (n = 0, o = t.data.datasets.length; n < o; ++n) if (t.isDatasetVisible(n)) for (a = 0, r = (i = t.getDatasetMeta(n)).data.length; a < r; ++a) { const s = i.data[a]; s._view.skip || e(s); } } function r(t, e) { const i = []; return o(t, (t) => { t.inRange(e.x, e.y) && i.push(t); }), i; } function s(t, e, i, n) { let a = Number.POSITIVE_INFINITY; let r = []; return o(t, (t) => { if (!i || t.inRange(e.x, e.y)) { const o = t.getCenterPoint(); const s = n(e, o); s < a ? (r = [t], a = s) : s === a && r.push(t); } }), r; } function l(t) { const e = t.indexOf('x') !== -1; const i = t.indexOf('y') !== -1; return function (t, n) { const a = e ? Math.abs(t.x - n.x) : 0; const o = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(a ** 2 + o ** 2); }; } function u(t, e, i) { const n = a(e, t); i.axis = i.axis || 'x'; const o = l(i.axis); const u = i.intersect ? r(t, n) : s(t, n, !1, o); const d = []; return u.length ? (t.data.datasets.forEach((e, i) => { if (t.isDatasetVisible(i)) { const n = t.getDatasetMeta(i).data[u[0]._index]; n && !n._view.skip && d.push(n); } }), d) : []; }e.exports = {
      modes: {
        single(t, e) { const i = a(e, t); const n = []; return o(t, (t) => { if (t.inRange(i.x, i.y)) return n.push(t), n; }), n.slice(0, 1); }, label: u, index: u, dataset(t, e, i) { const n = a(e, t); i.axis = i.axis || 'xy'; const o = l(i.axis); let u = i.intersect ? r(t, n) : s(t, n, !1, o); return u.length > 0 && (u = t.getDatasetMeta(u[0]._datasetIndex).data), u; }, 'x-axis': function (t, e) { return u(t, e, { intersect: !1 }); }, point(t, e) { return r(t, a(e, t)); }, nearest(t, e, i) { const n = a(e, t); i.axis = i.axis || 'xy'; const o = l(i.axis); const r = s(t, n, i.intersect, o); return r.length > 1 && r.sort((t, e) => { let i = t.getArea() - e.getArea(); return i === 0 && (i = t._datasetIndex - e._datasetIndex), i; }), r.slice(0, 1); }, x(t, e, i) { const n = a(e, t); let r = []; let s = !1; return o(t, (t) => { t.inXRange(n.x) && r.push(t), t.inRange(n.x, n.y) && (s = !0); }), i.intersect && !s && (r = []), r; }, y(t, e, i) { const n = a(e, t); let r = []; let s = !1; return o(t, (t) => { t.inYRange(n.y) && r.push(t), t.inRange(n.x, n.y) && (s = !0); }), i.intersect && !s && (r = []), r; },
      },
    };
  }, { 45: 45 }],
  29: [function (t, e, i) {
    'use strict';

    t(25)._set('global', {
      responsive: !0,
      responsiveAnimationDuration: 0,
      maintainAspectRatio: !0,
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null, mode: 'nearest', intersect: !0, animationDuration: 400,
      },
      onClick: null,
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      showLines: !0,
      elements: {},
      layout: {
        padding: {
          top: 0, right: 0, bottom: 0, left: 0,
        },
      },
    }), e.exports = function () { const t = function (t, e) { return this.construct(t, e), this; }; return t.Chart = t, t; };
  }, { 25: 25 }],
  30: [function (t, e, i) {
    'use strict';

    const n = t(45); function a(t, e) { return n.where(t, (t) => t.position === e); } function o(t, e) { t.forEach((t, e) => (t._tmpIndex_ = e, t)), t.sort((t, i) => { const n = e ? i : t; const a = e ? t : i; return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight; }), t.forEach((t) => { delete t._tmpIndex_; }); }e.exports = {
      defaults: {},
      addBox(t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || 'top', e.weight = e.weight || 0, t.boxes.push(e); },
      removeBox(t, e) { const i = t.boxes ? t.boxes.indexOf(e) : -1; i !== -1 && t.boxes.splice(i, 1); },
      configure(t, e, i) { for (var n, a = ['fullWidth', 'position', 'weight'], o = a.length, r = 0; r < o; ++r)n = a[r], i.hasOwnProperty(n) && (e[n] = i[n]); },
      update(t, e, i) {
        if (t) {
          const r = t.options.layout || {}; const s = n.options.toPadding(r.padding); var l = s.left; var u = s.right; const d = s.top; const c = s.bottom; const h = a(t.boxes, 'left'); const f = a(t.boxes, 'right'); const g = a(t.boxes, 'top'); const p = a(t.boxes, 'bottom'); const m = a(t.boxes, 'chartArea'); o(h, !0), o(f, !1), o(g, !0), o(p, !1); var v = e - l - u; var b = i - d - c; const x = b / 2; const y = (e - v / 2) / (h.length + f.length); const k = (i - x) / (g.length + p.length); var M = v; var w = b; var S = []; n.each(h.concat(f, g, p), (t) => { let e; const i = t.isHorizontal(); i ? (e = t.update(t.fullWidth ? v : M, k), w -= e.height) : (e = t.update(y, w), M -= e.width), S.push({ horizontal: i, minSize: e, box: t }); }); var C = 0; var _ = 0; let D = 0; let I = 0; n.each(g.concat(p), (t) => { if (t.getPadding) { const e = t.getPadding(); C = Math.max(C, e.left), _ = Math.max(_, e.right); } }), n.each(h.concat(f), (t) => { if (t.getPadding) { const e = t.getPadding(); D = Math.max(D, e.top), I = Math.max(I, e.bottom); } }); var P = l; var A = u; var T = d; let F = c; n.each(h.concat(f), N), n.each(h, (t) => { P += t.width; }), n.each(f, (t) => { A += t.width; }), n.each(g.concat(p), N), n.each(g, (t) => { T += t.height; }), n.each(p, (t) => { F += t.height; }), n.each(h.concat(f), (t) => {
            const e = n.findNextWhere(S, (e) => e.box === t); const i = {
              left: 0, right: 0, top: T, bottom: F,
            }; e && t.update(e.minSize.width, w, i);
          }), P = l, A = u, T = d, F = c, n.each(h, (t) => { P += t.width; }), n.each(f, (t) => { A += t.width; }), n.each(g, (t) => { T += t.height; }), n.each(p, (t) => { F += t.height; }); const O = Math.max(C - P, 0); P += O, A += Math.max(_ - A, 0); const R = Math.max(D - T, 0); T += R, F += Math.max(I - F, 0); const L = i - T - F; const z = e - P - A; z === M && L === w || (n.each(h, (t) => { t.height = L; }), n.each(f, (t) => { t.height = L; }), n.each(g, (t) => { t.fullWidth || (t.width = z); }), n.each(p, (t) => { t.fullWidth || (t.width = z); }), w = L, M = z); var B = l + O; var W = d + R; n.each(h.concat(g), V), B += M, W += w, n.each(f, V), n.each(p, V), t.chartArea = {
            left: P, top: T, right: P + M, bottom: T + w,
          }, n.each(m, (e) => { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(M, w); });
        } function N(t) {
          const e = n.findNextWhere(S, (e) => e.box === t); if (e) {
            if (t.isHorizontal()) {
              const i = {
                left: Math.max(P, C), right: Math.max(A, _), top: 0, bottom: 0,
              }; t.update(t.fullWidth ? v : M, b / 2, i);
            } else t.update(e.minSize.width, w);
          }
        } function V(t) { t.isHorizontal() ? (t.left = t.fullWidth ? l : P, t.right = t.fullWidth ? e - u : P + M, t.top = W, t.bottom = W + t.height, W = t.bottom) : (t.left = B, t.right = B + t.width, t.top = T, t.bottom = T + w, B = t.right); }
      },
    };
  }, { 45: 45 }],
  31: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(45); n._set('global', { plugins: {} }), e.exports = {
      _plugins: [], _cacheId: 0, register(t) { const e = this._plugins; [].concat(t).forEach((t) => { e.indexOf(t) === -1 && e.push(t); }), this._cacheId++; }, unregister(t) { const e = this._plugins; [].concat(t).forEach((t) => { const i = e.indexOf(t); i !== -1 && e.splice(i, 1); }), this._cacheId++; }, clear() { this._plugins = [], this._cacheId++; }, count() { return this._plugins.length; }, getAll() { return this._plugins; }, notify(t, e, i) { let n; let a; let o; let r; let s; const l = this.descriptors(t); const u = l.length; for (n = 0; n < u; ++n) if (typeof (s = (o = (a = l[n]).plugin)[e]) === 'function' && ((r = [t].concat(i || [])).push(a.options), !1 === s.apply(o, r))) return !1; return !0; }, descriptors(t) { const e = t.$plugins || (t.$plugins = {}); if (e.id === this._cacheId) return e.descriptors; const i = []; const o = []; const r = t && t.config || {}; const s = r.options && r.options.plugins || {}; return this._plugins.concat(r.plugins || []).forEach((t) => { if (i.indexOf(t) === -1) { const e = t.id; let r = s[e]; !1 !== r && (!0 === r && (r = a.clone(n.global.plugins[e])), i.push(t), o.push({ plugin: t, options: r || {} })); } }), e.descriptors = o, e.id = this._cacheId, o; }, _invalidate(t) { delete t.$plugins; },
    };
  }, { 25: 25, 45: 45 }],
  32: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); const r = t(34); function s(t) { let e; let i; const n = []; for (e = 0, i = t.length; e < i; ++e)n.push(t[e].label); return n; } function l(t, e, i) { let n = t.getPixelForTick(e); return i && (n -= e === 0 ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n; }n._set('scale', {
      display: !0,
      position: 'left',
      offset: !1,
      gridLines: {
        display: !0, color: 'rgba(0, 0, 0, 0.1)', lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: 'rgba(0,0,0,0.25)', zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0,
      },
      scaleLabel: {
        display: !1, labelString: '', lineHeight: 1.2, padding: { top: 4, bottom: 4 },
      },
      ticks: {
        beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: r.formatters.values, minor: {}, major: {},
      },
    }), e.exports = function (t) {
      function e(t, e, i) { return o.isArray(e) ? o.longestText(t, i, e) : t.measureText(e).width; } function i(t) {
        const e = o.valueOrDefault; const i = n.global; const a = e(t.fontSize, i.defaultFontSize); const r = e(t.fontStyle, i.defaultFontStyle); const s = e(t.fontFamily, i.defaultFontFamily); return {
          size: a, style: r, family: s, font: o.fontString(a, r, s),
        };
      } function r(t) { return o.options.toLineHeight(o.valueOrDefault(t.lineHeight, 1.2), o.valueOrDefault(t.fontSize, n.global.defaultFontSize)); }t.Scale = a.extend({
        getPadding() {
          return {
            left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0,
          };
        },
        getTicks() { return this._ticks; },
        mergeTicksOptions() { const t = this.options.ticks; for (const e in !1 === t.minor && (t.minor = { display: !1 }), !1 === t.major && (t.major = { display: !1 }), t)e !== 'major' && e !== 'minor' && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e])); },
        beforeUpdate() { o.callback(this.options.beforeUpdate, [this]); },
        update(t, e, i) {
          let n; let a; let r; let s; let l; let u; const d = this; for (d.beforeUpdate(), d.maxWidth = t, d.maxHeight = e, d.margins = o.extend({
            left: 0, right: 0, top: 0, bottom: 0,
          }, i), d.longestTextCache = d.longestTextCache || {}, d.beforeSetDimensions(), d.setDimensions(), d.afterSetDimensions(), d.beforeDataLimits(), d.determineDataLimits(), d.afterDataLimits(), d.beforeBuildTicks(), l = d.buildTicks() || [], d.afterBuildTicks(), d.beforeTickToLabelConversion(), r = d.convertTicksToLabels(l) || d.ticks, d.afterTickToLabelConversion(), d.ticks = r, n = 0, a = r.length; n < a; ++n)s = r[n], (u = l[n]) ? u.label = s : l.push(u = { label: s, major: !1 }); return d._ticks = l, d.beforeCalculateTickRotation(), d.calculateTickRotation(), d.afterCalculateTickRotation(), d.beforeFit(), d.fit(), d.afterFit(), d.afterUpdate(), d.minSize;
        },
        afterUpdate() { o.callback(this.options.afterUpdate, [this]); },
        beforeSetDimensions() { o.callback(this.options.beforeSetDimensions, [this]); },
        setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0; },
        afterSetDimensions() { o.callback(this.options.afterSetDimensions, [this]); },
        beforeDataLimits() { o.callback(this.options.beforeDataLimits, [this]); },
        determineDataLimits: o.noop,
        afterDataLimits() { o.callback(this.options.afterDataLimits, [this]); },
        beforeBuildTicks() { o.callback(this.options.beforeBuildTicks, [this]); },
        buildTicks: o.noop,
        afterBuildTicks() { o.callback(this.options.afterBuildTicks, [this]); },
        beforeTickToLabelConversion() { o.callback(this.options.beforeTickToLabelConversion, [this]); },
        convertTicksToLabels() { const t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this); },
        afterTickToLabelConversion() { o.callback(this.options.afterTickToLabelConversion, [this]); },
        beforeCalculateTickRotation() { o.callback(this.options.beforeCalculateTickRotation, [this]); },
        calculateTickRotation() { const t = this; const e = t.ctx; const n = t.options.ticks; const a = s(t._ticks); const r = i(n); e.font = r.font; let l = n.minRotation || 0; if (a.length && t.options.display && t.isHorizontal()) for (var u, d = o.longestText(e, r.font, a, t.longestTextCache), c = d, h = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; c > h && l < n.maxRotation;) { const f = o.toRadians(l); if (u = Math.cos(f), Math.sin(f) * d > t.maxHeight) { l--; break; }l++, c = u * d; }t.labelRotation = l; },
        afterCalculateTickRotation() { o.callback(this.options.afterCalculateTickRotation, [this]); },
        beforeFit() { o.callback(this.options.beforeFit, [this]); },
        fit() { const t = this; const n = t.minSize = { width: 0, height: 0 }; const a = s(t._ticks); const l = t.options; const u = l.ticks; const d = l.scaleLabel; const c = l.gridLines; const h = l.display; const f = t.isHorizontal(); const g = i(u); const p = l.gridLines.tickMarkLength; if (n.width = f ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : h && c.drawTicks ? p : 0, n.height = f ? h && c.drawTicks ? p : 0 : t.maxHeight, d.display && h) { const m = r(d) + o.options.toPadding(d.padding).height; f ? n.height += m : n.width += m; } if (u.display && h) { let v = o.longestText(t.ctx, g.font, a, t.longestTextCache); const b = o.numberOfLabelLines(a); const x = 0.5 * g.size; const y = t.options.ticks.padding; if (f) { t.longestLabelWidth = v; const k = o.toRadians(t.labelRotation); const M = Math.cos(k); const w = Math.sin(k) * v + g.size * b + x * (b - 1) + x; n.height = Math.min(t.maxHeight, n.height + w + y), t.ctx.font = g.font; const S = e(t.ctx, a[0], g.font); const C = e(t.ctx, a[a.length - 1], g.font); t.labelRotation !== 0 ? (t.paddingLeft = l.position === 'bottom' ? M * S + 3 : M * x + 3, t.paddingRight = l.position === 'bottom' ? M * x + 3 : M * C + 3) : (t.paddingLeft = S / 2 + 3, t.paddingRight = C / 2 + 3); } else u.mirror ? v = 0 : v += y + x, n.width = Math.min(t.maxWidth, n.width + v), t.paddingTop = g.size / 2, t.paddingBottom = g.size / 2; }t.handleMargins(), t.width = n.width, t.height = n.height; },
        handleMargins() { const t = this; t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)); },
        afterFit() { o.callback(this.options.afterFit, [this]); },
        isHorizontal() { return this.options.position === 'top' || this.options.position === 'bottom'; },
        isFullWidth() { return this.options.fullWidth; },
        getRightValue(t) { if (o.isNullOrUndef(t)) return NaN; if (typeof t === 'number' && !isFinite(t)) return NaN; if (t) if (this.isHorizontal()) { if (void 0 !== t.x) return this.getRightValue(t.x); } else if (void 0 !== t.y) return this.getRightValue(t.y); return t; },
        getLabelForIndex: o.noop,
        getPixelForValue: o.noop,
        getValueForPixel: o.noop,
        getPixelForTick(t) { const e = this; const i = e.options.offset; if (e.isHorizontal()) { const n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1); let a = n * t + e.paddingLeft; i && (a += n / 2); let o = e.left + Math.round(a); return o += e.isFullWidth() ? e.margins.left : 0; } const r = e.height - (e.paddingTop + e.paddingBottom); return e.top + t * (r / (e._ticks.length - 1)); },
        getPixelForDecimal(t) { const e = this; if (e.isHorizontal()) { const i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft; let n = e.left + Math.round(i); return n += e.isFullWidth() ? e.margins.left : 0; } return e.top + t * e.height; },
        getBasePixel() { return this.getPixelForValue(this.getBaseValue()); },
        getBaseValue() { const t = this.min; const e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0; },
        _autoSkip(t) { let e; let i; let n; let a; const r = this; const s = r.isHorizontal(); const l = r.options.ticks.minor; const u = t.length; const d = o.toRadians(r.labelRotation); const c = Math.cos(d); const h = r.longestLabelWidth * c; const f = []; for (l.maxTicksLimit && (a = l.maxTicksLimit), s && (e = !1, (h + l.autoSkipPadding) * u > r.width - (r.paddingLeft + r.paddingRight) && (e = 1 + Math.floor((h + l.autoSkipPadding) * u / (r.width - (r.paddingLeft + r.paddingRight)))), a && u > a && (e = Math.max(e, Math.floor(u / a)))), i = 0; i < u; i++)n = t[i], (e > 1 && i % e > 0 || i % e == 0 && i + e >= u) && i !== u - 1 && delete n.label, f.push(n); return f; },
        draw(t) {
          const e = this; const a = e.options; if (a.display) {
            const s = e.ctx; const u = n.global; const d = a.ticks.minor; const c = a.ticks.major || d; const h = a.gridLines; const f = a.scaleLabel; const g = e.labelRotation !== 0; const p = e.isHorizontal(); const m = d.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(); const v = o.valueOrDefault(d.fontColor, u.defaultFontColor); const b = i(d); const x = o.valueOrDefault(c.fontColor, u.defaultFontColor); const y = i(c); const k = h.drawTicks ? h.tickMarkLength : 0; const M = o.valueOrDefault(f.fontColor, u.defaultFontColor); const w = i(f); const S = o.options.toPadding(f.padding); const C = o.toRadians(e.labelRotation); const _ = []; const D = e.options.gridLines.lineWidth; const I = a.position === 'right' ? e.right : e.right - D - k; const P = a.position === 'right' ? e.right + k : e.right; const A = a.position === 'bottom' ? e.top + D : e.bottom - k - D; const T = a.position === 'bottom' ? e.top + D + k : e.bottom + D; if (o.each(m, (i, n) => {
              if (!o.isNullOrUndef(i.label)) {
                let r; let s; let c; let f; let v; let b; let x; let y; let M; let w; let S; let F; let O; let R; const L = i.label; n === e.zeroLineIndex && a.offset === h.offsetGridLines ? (r = h.zeroLineWidth, s = h.zeroLineColor, c = h.zeroLineBorderDash, f = h.zeroLineBorderDashOffset) : (r = o.valueAtIndexOrDefault(h.lineWidth, n), s = o.valueAtIndexOrDefault(h.color, n), c = o.valueOrDefault(h.borderDash, u.borderDash), f = o.valueOrDefault(h.borderDashOffset, u.borderDashOffset)); let z = 'middle'; let B = 'middle'; const W = d.padding; if (p) { const N = k + W; a.position === 'bottom' ? (B = g ? 'middle' : 'top', z = g ? 'right' : 'center', R = e.top + N) : (B = g ? 'middle' : 'bottom', z = g ? 'left' : 'center', R = e.bottom - N); let V = l(e, n, h.offsetGridLines && m.length > 1); V < e.left && (s = 'rgba(0,0,0,0)'), V += o.aliasPixel(r), O = e.getPixelForTick(n) + d.labelOffset, v = x = M = S = V, b = A, y = T, w = t.top, F = t.bottom + D; } else { let E; const H = a.position === 'left'; d.mirror ? (z = H ? 'left' : 'right', E = W) : (z = H ? 'right' : 'left', E = k + W), O = H ? e.right - E : e.left + E; let j = l(e, n, h.offsetGridLines && m.length > 1); j < e.top && (s = 'rgba(0,0,0,0)'), j += o.aliasPixel(r), R = e.getPixelForTick(n) + d.labelOffset, v = I, x = P, M = t.left, S = t.right + D, b = y = w = F = j; }_.push({
                  tx1: v, ty1: b, tx2: x, ty2: y, x1: M, y1: w, x2: S, y2: F, labelX: O, labelY: R, glWidth: r, glColor: s, glBorderDash: c, glBorderDashOffset: f, rotation: -1 * C, label: L, major: i.major, textBaseline: B, textAlign: z,
                });
              }
            }), o.each(_, (t) => { if (h.display && (s.save(), s.lineWidth = t.glWidth, s.strokeStyle = t.glColor, s.setLineDash && (s.setLineDash(t.glBorderDash), s.lineDashOffset = t.glBorderDashOffset), s.beginPath(), h.drawTicks && (s.moveTo(t.tx1, t.ty1), s.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (s.moveTo(t.x1, t.y1), s.lineTo(t.x2, t.y2)), s.stroke(), s.restore()), d.display) { s.save(), s.translate(t.labelX, t.labelY), s.rotate(t.rotation), s.font = t.major ? y.font : b.font, s.fillStyle = t.major ? x : v, s.textBaseline = t.textBaseline, s.textAlign = t.textAlign; const i = t.label; if (o.isArray(i)) for (let n = i.length, a = 1.5 * b.size, r = e.isHorizontal() ? 0 : -a * (n - 1) / 2, l = 0; l < n; ++l)s.fillText(`${i[l]}`, 0, r), r += a; else s.fillText(i, 0, 0); s.restore(); } }), f.display) { let F; let O; let R = 0; const L = r(f) / 2; if (p)F = e.left + (e.right - e.left) / 2, O = a.position === 'bottom' ? e.bottom - L - S.bottom : e.top + L + S.top; else { const z = a.position === 'left'; F = z ? e.left + L + S.top : e.right - L - S.top, O = e.top + (e.bottom - e.top) / 2, R = z ? -0.5 * Math.PI : 0.5 * Math.PI; }s.save(), s.translate(F, O), s.rotate(R), s.textAlign = 'center', s.textBaseline = 'middle', s.fillStyle = M, s.font = w.font, s.fillText(f.labelString, 0, 0), s.restore(); } if (h.drawBorder) { s.lineWidth = o.valueAtIndexOrDefault(h.lineWidth, 0), s.strokeStyle = o.valueAtIndexOrDefault(h.color, 0); let B = e.left; let W = e.right + D; let N = e.top; let V = e.bottom + D; const E = o.aliasPixel(s.lineWidth); p ? (N = V = a.position === 'top' ? e.bottom : e.top, N += E, V += E) : (B = W = a.position === 'left' ? e.right : e.left, B += E, W += E), s.beginPath(), s.moveTo(B, N), s.lineTo(W, V), s.stroke(); }
          }
        },
      });
    };
  }, {
    25: 25, 26: 26, 34: 34, 45: 45,
  }],
  33: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(45); const o = t(30); e.exports = function (t) {
      t.scaleService = {
        constructors: {}, defaults: {}, registerScaleType(t, e, i) { this.constructors[t] = e, this.defaults[t] = a.clone(i); }, getScaleConstructor(t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0; }, getScaleDefaults(t) { return this.defaults.hasOwnProperty(t) ? a.merge({}, [n.scale, this.defaults[t]]) : {}; }, updateScaleDefaults(t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = a.extend(this.defaults[t], e)); }, addScalesToLayout(t) { a.each(t.scales, (e) => { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, o.addBox(t, e); }); },
      };
    };
  }, { 25: 25, 30: 30, 45: 45 }],
  34: [function (t, e, i) {
    'use strict';

    const n = t(45); e.exports = { formatters: { values(t) { return n.isArray(t) ? t : `${t}`; }, linear(t, e, i) { let a = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(a) > 1 && t !== Math.floor(t) && (a = t - Math.floor(t)); const o = n.log10(Math.abs(a)); let r = ''; if (t !== 0) { let s = -1 * Math.floor(o); s = Math.max(Math.min(s, 20), 0), r = t.toFixed(s); } else r = '0'; return r; }, logarithmic(t, e, i) { const a = t / 10 ** Math.floor(n.log10(t)); return t === 0 ? '0' : a === 1 || a === 2 || a === 5 || e === 0 || e === i.length - 1 ? t.toExponential() : ''; } } };
  }, { 45: 45 }],
  35: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); n._set('global', {
      tooltips: {
        enabled: !0,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: !0,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: !0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          beforeTitle: o.noop, title(t, e) { let i = ''; const n = e.labels; const a = n ? n.length : 0; if (t.length > 0) { const o = t[0]; o.xLabel ? i = o.xLabel : a > 0 && o.index < a && (i = n[o.index]); } return i; }, afterTitle: o.noop, beforeBody: o.noop, beforeLabel: o.noop, label(t, e) { let i = e.datasets[t.datasetIndex].label || ''; return i && (i += ': '), i += t.yLabel; }, labelColor(t, e) { const i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor }; }, labelTextColor() { return this._options.bodyFontColor; }, afterLabel: o.noop, afterBody: o.noop, beforeFooter: o.noop, footer: o.noop, afterFooter: o.noop,
        },
      },
    }), e.exports = function (t) {
      function e(t, e) { const i = o.color(t); return i.alpha(e * i.alpha()).rgbaString(); } function i(t, e) { return e && (o.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t; } function r(t) {
        const e = n.global; const i = o.valueOrDefault; return {
          xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, bodyFontColor: t.bodyFontColor, _bodyFontFamily: i(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: i(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: i(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: i(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: i(t.titleFontStyle, e.defaultFontStyle), titleFontSize: i(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: i(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: i(t.footerFontStyle, e.defaultFontStyle), footerFontSize: i(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth,
        };
      }t.Tooltip = a.extend({
        initialize() { this._model = r(this._options), this._lastActive = []; },
        getTitle() { const t = this._options.callbacks; const e = t.beforeTitle.apply(this, arguments); const n = t.title.apply(this, arguments); const a = t.afterTitle.apply(this, arguments); let o = []; return o = i(o = i(o = i(o, e), n), a); },
        getBeforeBody() { const t = this._options.callbacks.beforeBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : []; },
        getBody(t, e) { const n = this; const a = n._options.callbacks; const r = []; return o.each(t, (t) => { const o = { before: [], lines: [], after: [] }; i(o.before, a.beforeLabel.call(n, t, e)), i(o.lines, a.label.call(n, t, e)), i(o.after, a.afterLabel.call(n, t, e)), r.push(o); }), r; },
        getAfterBody() { const t = this._options.callbacks.afterBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : []; },
        getFooter() { const t = this._options.callbacks; const e = t.beforeFooter.apply(this, arguments); const n = t.footer.apply(this, arguments); const a = t.afterFooter.apply(this, arguments); let o = []; return o = i(o = i(o = i(o, e), n), a); },
        update(e) {
          let i; let n; let a; let s; let l; let u; let d; let c; let h; let f; let g; let p; let m; let v; let b; let x; let y; let k; let M; let w; const S = this; const C = S._options; const _ = S._model; const D = S._model = r(C); const I = S._active; const P = S._data; let A = { xAlign: _.xAlign, yAlign: _.yAlign }; let T = { x: _.x, y: _.y }; let F = { width: _.width, height: _.height }; let O = { x: _.caretX, y: _.caretY }; if (I.length) {
            D.opacity = 1; const R = []; const L = []; O = t.Tooltip.positioners[C.position].call(S, I, S._eventPosition); let z = []; for (i = 0, n = I.length; i < n; ++i) {
              z.push((x = I[i], y = void 0, k = void 0, void 0, void 0, y = x._xScale, k = x._yScale || x._scale, M = x._index, w = x._datasetIndex, {
                xLabel: y ? y.getLabelForIndex(M, w) : '', yLabel: k ? k.getLabelForIndex(M, w) : '', index: M, datasetIndex: w, x: x._model.x, y: x._model.y,
              }));
            } C.filter && (z = z.filter((t) => C.filter(t, P))), C.itemSort && (z = z.sort((t, e) => C.itemSort(t, e, P))), o.each(z, (t) => { R.push(C.callbacks.labelColor.call(S, t, S._chart)), L.push(C.callbacks.labelTextColor.call(S, t, S._chart)); }), D.title = S.getTitle(z, P), D.beforeBody = S.getBeforeBody(z, P), D.body = S.getBody(z, P), D.afterBody = S.getAfterBody(z, P), D.footer = S.getFooter(z, P), D.x = Math.round(O.x), D.y = Math.round(O.y), D.caretPadding = C.caretPadding, D.labelColors = R, D.labelTextColors = L, D.dataPoints = z, A = (function (t, e) { let i; let n; let a; let o; let r; const s = t._model; const l = t._chart; const u = t._chart.chartArea; let d = 'center'; let c = 'center'; s.y < e.height ? c = 'top' : s.y > l.height - e.height && (c = 'bottom'); const h = (u.left + u.right) / 2; const f = (u.top + u.bottom) / 2; c === 'center' ? (i = function (t) { return t <= h; }, n = function (t) { return t > h; }) : (i = function (t) { return t <= e.width / 2; }, n = function (t) { return t >= l.width - e.width / 2; }), a = function (t) { return t + e.width + s.caretSize + s.caretPadding > l.width; }, o = function (t) { return t - e.width - s.caretSize - s.caretPadding < 0; }, r = function (t) { return t <= f ? 'top' : 'bottom'; }, i(s.x) ? (d = 'left', a(s.x) && (d = 'center', c = r(s.y))) : n(s.x) && (d = 'right', o(s.x) && (d = 'center', c = r(s.y))); const g = t._options; return { xAlign: g.xAlign ? g.xAlign : d, yAlign: g.yAlign ? g.yAlign : c }; }(this, F = (function (t, e) { const i = t._chart.ctx; let n = 2 * e.yPadding; let a = 0; const r = e.body; let s = r.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0); s += e.beforeBody.length + e.afterBody.length; const l = e.title.length; const u = e.footer.length; const d = e.titleFontSize; const c = e.bodyFontSize; const h = e.footerFontSize; n += l * d, n += l ? (l - 1) * e.titleSpacing : 0, n += l ? e.titleMarginBottom : 0, n += s * c, n += s ? (s - 1) * e.bodySpacing : 0, n += u ? e.footerMarginTop : 0, n += u * h, n += u ? (u - 1) * e.footerSpacing : 0; let f = 0; const g = function (t) { a = Math.max(a, i.measureText(t).width + f); }; return i.font = o.fontString(d, e._titleFontStyle, e._titleFontFamily), o.each(e.title, g), i.font = o.fontString(c, e._bodyFontStyle, e._bodyFontFamily), o.each(e.beforeBody.concat(e.afterBody), g), f = e.displayColors ? c + 2 : 0, o.each(r, (t) => { o.each(t.before, g), o.each(t.lines, g), o.each(t.after, g); }), f = 0, i.font = o.fontString(h, e._footerFontStyle, e._footerFontFamily), o.each(e.footer, g), { width: a += 2 * e.xPadding, height: n }; }(this, D)))), a = D, s = F, l = A, u = S._chart, d = a.x, c = a.y, h = a.caretSize, f = a.caretPadding, g = a.cornerRadius, p = l.xAlign, m = l.yAlign, v = h + f, b = g + f, p === 'right' ? d -= s.width : p === 'center' && ((d -= s.width / 2) + s.width > u.width && (d = u.width - s.width), d < 0 && (d = 0)), m === 'top' ? c += v : c -= m === 'bottom' ? s.height + v : s.height / 2, m === 'center' ? p === 'left' ? d += v : p === 'right' && (d -= v) : p === 'left' ? d -= b : p === 'right' && (d += b), T = { x: d, y: c };
          } else D.opacity = 0; return D.xAlign = A.xAlign, D.yAlign = A.yAlign, D.x = T.x, D.y = T.y, D.width = F.width, D.height = F.height, D.caretX = O.x, D.caretY = O.y, S._model = D, e && C.custom && C.custom.call(S, D), S;
        },
        drawCaret(t, e) { const i = this._chart.ctx; const n = this._view; const a = this.getCaretPosition(t, e, n); i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3); },
        getCaretPosition(t, e, i) {
          let n; let a; let o; let r; let s; let l; const u = i.caretSize; const d = i.cornerRadius; const c = i.xAlign; const h = i.yAlign; const f = t.x; const g = t.y; const p = e.width; const m = e.height; if (h === 'center')s = g + m / 2, c === 'left' ? (a = (n = f) - u, o = n, r = s + u, l = s - u) : (a = (n = f + p) + u, o = n, r = s - u, l = s + u); else if (c === 'left' ? (n = (a = f + d + u) - u, o = a + u) : c === 'right' ? (n = (a = f + p - d - u) - u, o = a + u) : (n = (a = i.caretX) - u, o = a + u), h === 'top')s = (r = g) - u, l = r; else { s = (r = g + m) + u, l = r; const v = o; o = n, n = v; } return {
            x1: n, x2: a, x3: o, y1: r, y2: s, y3: l,
          };
        },
        drawTitle(t, i, n, a) { const r = i.title; if (r.length) { n.textAlign = i._titleAlign, n.textBaseline = 'top'; let s; let l; const u = i.titleFontSize; const d = i.titleSpacing; for (n.fillStyle = e(i.titleFontColor, a), n.font = o.fontString(u, i._titleFontStyle, i._titleFontFamily), s = 0, l = r.length; s < l; ++s)n.fillText(r[s], t.x, t.y), t.y += u + d, s + 1 === r.length && (t.y += i.titleMarginBottom - d); } },
        drawBody(t, i, n, a) { const r = i.bodyFontSize; const s = i.bodySpacing; const l = i.body; n.textAlign = i._bodyAlign, n.textBaseline = 'top', n.font = o.fontString(r, i._bodyFontStyle, i._bodyFontFamily); let u = 0; const d = function (e) { n.fillText(e, t.x + u, t.y), t.y += r + s; }; n.fillStyle = e(i.bodyFontColor, a), o.each(i.beforeBody, d); const c = i.displayColors; u = c ? r + 2 : 0, o.each(l, (s, l) => { const u = e(i.labelTextColors[l], a); n.fillStyle = u, o.each(s.before, d), o.each(s.lines, (o) => { c && (n.fillStyle = e(i.legendColorBackground, a), n.fillRect(t.x, t.y, r, r), n.lineWidth = 1, n.strokeStyle = e(i.labelColors[l].borderColor, a), n.strokeRect(t.x, t.y, r, r), n.fillStyle = e(i.labelColors[l].backgroundColor, a), n.fillRect(t.x + 1, t.y + 1, r - 2, r - 2), n.fillStyle = u), d(o); }), o.each(s.after, d); }), u = 0, o.each(i.afterBody, d), t.y -= s; },
        drawFooter(t, i, n, a) { const r = i.footer; r.length && (t.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = 'top', n.fillStyle = e(i.footerFontColor, a), n.font = o.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), o.each(r, (e) => { n.fillText(e, t.x, t.y), t.y += i.footerFontSize + i.footerSpacing; })); },
        drawBackground(t, i, n, a, o) { n.fillStyle = e(i.backgroundColor, o), n.strokeStyle = e(i.borderColor, o), n.lineWidth = i.borderWidth; const r = i.xAlign; const s = i.yAlign; const l = t.x; const u = t.y; const d = a.width; const c = a.height; const h = i.cornerRadius; n.beginPath(), n.moveTo(l + h, u), s === 'top' && this.drawCaret(t, a), n.lineTo(l + d - h, u), n.quadraticCurveTo(l + d, u, l + d, u + h), s === 'center' && r === 'right' && this.drawCaret(t, a), n.lineTo(l + d, u + c - h), n.quadraticCurveTo(l + d, u + c, l + d - h, u + c), s === 'bottom' && this.drawCaret(t, a), n.lineTo(l + h, u + c), n.quadraticCurveTo(l, u + c, l, u + c - h), s === 'center' && r === 'left' && this.drawCaret(t, a), n.lineTo(l, u + h), n.quadraticCurveTo(l, u, l + h, u), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke(); },
        draw() { const t = this._chart.ctx; const e = this._view; if (e.opacity !== 0) { const i = { width: e.width, height: e.height }; const n = { x: e.x, y: e.y }; const a = Math.abs(e.opacity < 0.001) ? 0 : e.opacity; const o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; this._options.enabled && o && (this.drawBackground(n, e, t, i, a), n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, a), this.drawBody(n, e, t, a), this.drawFooter(n, e, t, a)); } },
        handleEvent(t) { let e; const i = this; const n = i._options; return i._lastActive = i._lastActive || [], t.type === 'mouseout' ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !o.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0), i.pivot())), e; },
      }), t.Tooltip.positioners = { average(t) { if (!t.length) return !1; let e; let i; let n = 0; let a = 0; let o = 0; for (e = 0, i = t.length; e < i; ++e) { const r = t[e]; if (r && r.hasValue()) { const s = r.tooltipPosition(); n += s.x, a += s.y, ++o; } } return { x: Math.round(n / o), y: Math.round(a / o) }; }, nearest(t, e) { let i; let n; let a; let r = e.x; let s = e.y; let l = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { const u = t[i]; if (u && u.hasValue()) { const d = u.getCenterPoint(); const c = o.distanceBetweenPoints(e, d); c < l && (l = c, a = u); } } if (a) { const h = a.tooltipPosition(); r = h.x, s = h.y; } return { x: r, y: s }; } };
    };
  }, { 25: 25, 26: 26, 45: 45 }],
  36: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); n._set('global', { elements: { arc: { backgroundColor: n.global.defaultColor, borderColor: '#fff', borderWidth: 2 } } }), e.exports = a.extend({
      inLabelRange(t) { const e = this._view; return !!e && (t - e.x) ** 2 < (e.radius + e.hoverRadius) ** 2; }, inRange(t, e) { const i = this._view; if (i) { for (var n = o.getAngleFromPoint(i, { x: t, y: e }), a = n.angle, r = n.distance, s = i.startAngle, l = i.endAngle; l < s;)l += 2 * Math.PI; for (;a > l;)a -= 2 * Math.PI; for (;a < s;)a += 2 * Math.PI; const u = a >= s && a <= l; const d = r >= i.innerRadius && r <= i.outerRadius; return u && d; } return !1; }, getCenterPoint() { const t = this._view; const e = (t.startAngle + t.endAngle) / 2; const i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, getArea() { const t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (t.outerRadius ** 2 - t.innerRadius ** 2); }, tooltipPosition() { const t = this._view; const e = t.startAngle + (t.endAngle - t.startAngle) / 2; const i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, draw() { const t = this._chart.ctx; const e = this._view; const i = e.startAngle; const n = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, i, n), t.arc(e.x, e.y, e.innerRadius, n, i, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = 'bevel', e.borderWidth && t.stroke(); },
    });
  }, { 25: 25, 26: 26, 45: 45 }],
  37: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); const r = n.global; n._set('global', {
      elements: {
        line: {
          tension: 0.4, backgroundColor: r.defaultColor, borderWidth: 3, borderColor: r.defaultColor, borderCapStyle: 'butt', borderDash: [], borderDashOffset: 0, borderJoinStyle: 'miter', capBezierPoints: !0, fill: !0,
        },
      },
    }), e.exports = a.extend({ draw() { let t; let e; let i; let n; const a = this._view; const s = this._chart.ctx; const l = a.spanGaps; const u = this._children.slice(); const d = r.elements.line; let c = -1; for (this._loop && u.length && u.push(u[0]), s.save(), s.lineCap = a.borderCapStyle || d.borderCapStyle, s.setLineDash && s.setLineDash(a.borderDash || d.borderDash), s.lineDashOffset = a.borderDashOffset || d.borderDashOffset, s.lineJoin = a.borderJoinStyle || d.borderJoinStyle, s.lineWidth = a.borderWidth || d.borderWidth, s.strokeStyle = a.borderColor || r.defaultColor, s.beginPath(), c = -1, t = 0; t < u.length; ++t)e = u[t], i = o.previousItem(u, t), n = e._view, t === 0 ? n.skip || (s.moveTo(n.x, n.y), c = t) : (i = c === -1 ? i : u[c], n.skip || (c !== t - 1 && !l || c === -1 ? s.moveTo(n.x, n.y) : o.canvas.lineTo(s, i._view, e._view), c = t)); s.stroke(), s.restore(); } });
  }, { 25: 25, 26: 26, 45: 45 }],
  38: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); const r = n.global.defaultColor; function s(t) { const e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius; }n._set('global', {
      elements: {
        point: {
          radius: 3, pointStyle: 'circle', backgroundColor: r, borderColor: r, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1,
        },
      },
    }), e.exports = a.extend({
      inRange(t, e) { const i = this._view; return !!i && (t - i.x) ** 2 + (e - i.y) ** 2 < (i.hitRadius + i.radius) ** 2; }, inLabelRange: s, inXRange: s, inYRange(t) { const e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius; }, getCenterPoint() { const t = this._view; return { x: t.x, y: t.y }; }, getArea() { return Math.PI * this._view.radius ** 2; }, tooltipPosition() { const t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth }; }, draw(t) { const e = this._view; const i = this._model; const a = this._chart.ctx; const s = e.pointStyle; const l = e.radius; const u = e.x; const d = e.y; const c = o.color; let h = 0; e.skip || (a.strokeStyle = e.borderColor || r, a.lineWidth = o.valueOrDefault(e.borderWidth, n.global.elements.point.borderWidth), a.fillStyle = e.backgroundColor || r, void 0 !== t && (i.x < t.left || 1.01 * t.right < i.x || i.y < t.top || 1.01 * t.bottom < i.y) && (i.x < t.left ? h = (u - i.x) / (t.left - i.x) : 1.01 * t.right < i.x ? h = (i.x - u) / (i.x - t.right) : i.y < t.top ? h = (d - i.y) / (t.top - i.y) : 1.01 * t.bottom < i.y && (h = (i.y - d) / (i.y - t.bottom)), h = Math.round(100 * h) / 100, a.strokeStyle = c(a.strokeStyle).alpha(h).rgbString(), a.fillStyle = c(a.fillStyle).alpha(h).rgbString()), o.canvas.drawPoint(a, s, l, u, d)); },
    });
  }, { 25: 25, 26: 26, 45: 45 }],
  39: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); function o(t) { return void 0 !== t._view.width; } function r(t) {
      let e; let i; let n; let a; const r = t._view; if (o(t)) { const s = r.width / 2; e = r.x - s, i = r.x + s, n = Math.min(r.y, r.base), a = Math.max(r.y, r.base); } else { const l = r.height / 2; e = Math.min(r.x, r.base), i = Math.max(r.x, r.base), n = r.y - l, a = r.y + l; } return {
        left: e, top: n, right: i, bottom: a,
      };
    }n._set('global', {
      elements: {
        rectangle: {
          backgroundColor: n.global.defaultColor, borderColor: n.global.defaultColor, borderSkipped: 'bottom', borderWidth: 0,
        },
      },
    }), e.exports = a.extend({
      draw() { let t; let e; let i; let n; let a; let o; let r; const s = this._chart.ctx; const l = this._view; let u = l.borderWidth; if (l.horizontal ? (t = l.base, e = l.x, i = l.y - l.height / 2, n = l.y + l.height / 2, a = e > t ? 1 : -1, o = 1, r = l.borderSkipped || 'left') : (t = l.x - l.width / 2, e = l.x + l.width / 2, i = l.y, a = 1, o = (n = l.base) > i ? 1 : -1, r = l.borderSkipped || 'bottom'), u) { const d = Math.min(Math.abs(t - e), Math.abs(i - n)); const c = (u = u > d ? d : u) / 2; const h = t + (r !== 'left' ? c * a : 0); const f = e + (r !== 'right' ? -c * a : 0); const g = i + (r !== 'top' ? c * o : 0); const p = n + (r !== 'bottom' ? -c * o : 0); h !== f && (i = g, n = p), g !== p && (t = h, e = f); }s.beginPath(), s.fillStyle = l.backgroundColor, s.strokeStyle = l.borderColor, s.lineWidth = u; const m = [[t, n], [t, i], [e, i], [e, n]]; let v = ['bottom', 'left', 'top', 'right'].indexOf(r, 0); function b(t) { return m[(v + t) % 4]; }v === -1 && (v = 0); let x = b(0); s.moveTo(x[0], x[1]); for (let y = 1; y < 4; y++)x = b(y), s.lineTo(x[0], x[1]); s.fill(), u && s.stroke(); }, height() { const t = this._view; return t.base - t.y; }, inRange(t, e) { let i = !1; if (this._view) { const n = r(this); i = t >= n.left && t <= n.right && e >= n.top && e <= n.bottom; } return i; }, inLabelRange(t, e) { if (!this._view) return !1; const i = r(this); return o(this) ? t >= i.left && t <= i.right : e >= i.top && e <= i.bottom; }, inXRange(t) { const e = r(this); return t >= e.left && t <= e.right; }, inYRange(t) { const e = r(this); return t >= e.top && t <= e.bottom; }, getCenterPoint() { let t; let e; const i = this._view; return o(this) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), { x: t, y: e }; }, getArea() { const t = this._view; return t.width * Math.abs(t.y - t.base); }, tooltipPosition() { const t = this._view; return { x: t.x, y: t.y }; },
    });
  }, { 25: 25, 26: 26 }],
  40: [function (t, e, i) {
    'use strict';

    e.exports = {}, e.exports.Arc = t(36), e.exports.Line = t(37), e.exports.Point = t(38), e.exports.Rectangle = t(39);
  }, {
    36: 36, 37: 37, 38: 38, 39: 39,
  }],
  41: [function (t, e, i) {
    'use strict';

    const n = t(42); i = e.exports = {
      clear(t) { t.ctx.clearRect(0, 0, t.width, t.height); }, roundedRect(t, e, i, n, a, o) { if (o) { const r = Math.min(o, n / 2); const s = Math.min(o, a / 2); t.moveTo(e + r, i), t.lineTo(e + n - r, i), t.quadraticCurveTo(e + n, i, e + n, i + s), t.lineTo(e + n, i + a - s), t.quadraticCurveTo(e + n, i + a, e + n - r, i + a), t.lineTo(e + r, i + a), t.quadraticCurveTo(e, i + a, e, i + a - s), t.lineTo(e, i + s), t.quadraticCurveTo(e, i, e + r, i); } else t.rect(e, i, n, a); }, drawPoint(t, e, i, n, a) { let o; let r; let s; let l; let u; let d; if (!e || typeof e !== 'object' || (o = e.toString()) !== '[object HTMLImageElement]' && o !== '[object HTMLCanvasElement]') { if (!(isNaN(i) || i <= 0)) { switch (e) { default: t.beginPath(), t.arc(n, a, i, 0, 2 * Math.PI), t.closePath(), t.fill(); break; case 'triangle': t.beginPath(), u = (r = 3 * i / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(n - r / 2, a + u / 3), t.lineTo(n + r / 2, a + u / 3), t.lineTo(n, a - 2 * u / 3), t.closePath(), t.fill(); break; case 'rect': d = 1 / Math.SQRT2 * i, t.beginPath(), t.fillRect(n - d, a - d, 2 * d, 2 * d), t.strokeRect(n - d, a - d, 2 * d, 2 * d); break; case 'rectRounded': var c = i / Math.SQRT2; var h = n - c; var f = a - c; var g = Math.SQRT2 * i; t.beginPath(), this.roundedRect(t, h, f, g, g, i / 2), t.closePath(), t.fill(); break; case 'rectRot': d = 1 / Math.SQRT2 * i, t.beginPath(), t.moveTo(n - d, a), t.lineTo(n, a + d), t.lineTo(n + d, a), t.lineTo(n, a - d), t.closePath(), t.fill(); break; case 'cross': t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case 'crossRot': t.beginPath(), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case 'star': t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case 'line': t.beginPath(), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case 'dash': t.beginPath(), t.moveTo(n, a), t.lineTo(n + i, a), t.closePath(); }t.stroke(); } } else t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height); }, clipArea(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip(); }, unclipArea(t) { t.restore(); }, lineTo(t, e, i, n) { if (i.steppedLine) return i.steppedLine === 'after' && !n || i.steppedLine !== 'after' && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y), void t.lineTo(i.x, i.y); i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y); },
    }; n.clear = i.clear, n.drawRoundedRectangle = function (t) { t.beginPath(), i.roundedRect.apply(i, arguments), t.closePath(); };
  }, { 42: 42 }],
  42: [function (t, e, i) {
    'use strict';

    let n; var a = {
      noop() {}, uid: (n = 0, function () { return n++; }), isNullOrUndef(t) { return t == null; }, isArray: Array.isArray ? Array.isArray : function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }, isObject(t) { return t !== null && Object.prototype.toString.call(t) === '[object Object]'; }, valueOrDefault(t, e) { return void 0 === t ? e : t; }, valueAtIndexOrDefault(t, e, i) { return a.valueOrDefault(a.isArray(t) ? t[e] : t, i); }, callback(t, e, i) { if (t && typeof t.call === 'function') return t.apply(i, e); }, each(t, e, i, n) { let o; let r; let s; if (a.isArray(t)) if (r = t.length, n) for (o = r - 1; o >= 0; o--)e.call(i, t[o], o); else for (o = 0; o < r; o++)e.call(i, t[o], o); else if (a.isObject(t)) for (r = (s = Object.keys(t)).length, o = 0; o < r; o++)e.call(i, t[s[o]], s[o]); }, arrayEquals(t, e) { let i; let n; let o; let r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i) if (o = t[i], r = e[i], o instanceof Array && r instanceof Array) { if (!a.arrayEquals(o, r)) return !1; } else if (o !== r) return !1; return !0; }, clone(t) { if (a.isArray(t)) return t.map(a.clone); if (a.isObject(t)) { for (var e = {}, i = Object.keys(t), n = i.length, o = 0; o < n; ++o)e[i[o]] = a.clone(t[i[o]]); return e; } return t; }, _merger(t, e, i, n) { const o = e[t]; const r = i[t]; a.isObject(o) && a.isObject(r) ? a.merge(o, r, n) : e[t] = a.clone(r); }, _mergerIf(t, e, i) { const n = e[t]; const o = i[t]; a.isObject(n) && a.isObject(o) ? a.mergeIf(n, o) : e.hasOwnProperty(t) || (e[t] = a.clone(o)); }, merge(t, e, i) { let n; let o; let r; let s; let l; const u = a.isArray(e) ? e : [e]; const d = u.length; if (!a.isObject(t)) return t; for (n = (i = i || {}).merger || a._merger, o = 0; o < d; ++o) if (e = u[o], a.isObject(e)) for (l = 0, s = (r = Object.keys(e)).length; l < s; ++l)n(r[l], t, e, i); return t; }, mergeIf(t, e) { return a.merge(t, e, { merger: a._mergerIf }); }, extend(t) { for (let e = function (e, i) { t[i] = e; }, i = 1, n = arguments.length; i < n; ++i)a.each(arguments[i], e); return t; }, inherits(t) { const e = this; const i = t && t.hasOwnProperty('constructor') ? t.constructor : function () { return e.apply(this, arguments); }; const n = function () { this.constructor = i; }; return n.prototype = e.prototype, i.prototype = new n(), i.extend = a.inherits, t && a.extend(i.prototype, t), i.__super__ = e.prototype, i; },
    }; e.exports = a, a.callCallback = a.callback, a.indexOf = function (t, e, i) { return Array.prototype.indexOf.call(t, e, i); }, a.getValueOrDefault = a.valueOrDefault, a.getValueAtIndexOrDefault = a.valueAtIndexOrDefault;
  }, {}],
  43: [function (t, e, i) {
    'use strict';

    const n = t(42); var a = {
      linear(t) { return t; }, easeInQuad(t) { return t * t; }, easeOutQuad(t) { return -t * (t - 2); }, easeInOutQuad(t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }, easeInCubic(t) { return t * t * t; }, easeOutCubic(t) { return (t -= 1) * t * t + 1; }, easeInOutCubic(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }, easeInQuart(t) { return t * t * t * t; }, easeOutQuart(t) { return -((t -= 1) * t * t * t - 1); }, easeInOutQuart(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }, easeInQuint(t) { return t * t * t * t * t; }, easeOutQuint(t) { return (t -= 1) * t * t * t * t + 1; }, easeInOutQuint(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }, easeInSine(t) { return 1 - Math.cos(t * (Math.PI / 2)); }, easeOutSine(t) { return Math.sin(t * (Math.PI / 2)); }, easeInOutSine(t) { return -0.5 * (Math.cos(Math.PI * t) - 1); }, easeInExpo(t) { return t === 0 ? 0 : 2 ** (10 * (t - 1)); }, easeOutExpo(t) { return t === 1 ? 1 : 1 - 2 ** (-10 * t); }, easeInOutExpo(t) { return t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * 2 ** (10 * (t - 1)) : 0.5 * (2 - 2 ** (-10 * --t)); }, easeInCirc(t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1); }, easeOutCirc(t) { return Math.sqrt(1 - (t -= 1) * t); }, easeInOutCirc(t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }, easeInElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : t === 1 ? 1 : (i || (i = 0.3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)); }, easeOutElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : t === 1 ? 1 : (i || (i = 0.3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * 2 ** (-10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1); }, easeInOutElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : (t /= 0.5) == 2 ? 1 : (i || (i = 0.45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -0.5 : n * 2 ** (-10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * 0.5 + 1); }, easeInBack(t) { return t * t * (2.70158 * t - 1.70158); }, easeOutBack(t) { return (t -= 1) * t * (2.70158 * t + 1.70158) + 1; }, easeInOutBack(t) { let e = 1.70158; return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2); }, easeInBounce(t) { return 1 - a.easeOutBounce(1 - t); }, easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }, easeInOutBounce(t) { return t < 0.5 ? 0.5 * a.easeInBounce(2 * t) : 0.5 * a.easeOutBounce(2 * t - 1) + 0.5; },
    }; e.exports = { effects: a }, n.easingEffects = a;
  }, { 42: 42 }],
  44: [function (t, e, i) {
    'use strict';

    const n = t(42); e.exports = {
      toLineHeight(t, e) { const i = (`${t}`).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!i || i[1] === 'normal') return 1.2 * e; switch (t = +i[2], i[3]) { case 'px': return t; case '%': t /= 100; } return e * t; },
      toPadding(t) {
        let e; let i; let a; let o; return n.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, a = +t.bottom || 0, o = +t.left || 0) : e = i = a = o = +t || 0, {
          top: e, right: i, bottom: a, left: o, height: e + a, width: o + i,
        };
      },
      resolve(t, e, i) { let a; let o; let r; for (a = 0, o = t.length; a < o; ++a) if (void 0 !== (r = t[a]) && (void 0 !== e && typeof r === 'function' && (r = r(e)), void 0 !== i && n.isArray(r) && (r = r[i]), void 0 !== r)) return r; },
    };
  }, { 42: 42 }],
  45: [function (t, e, i) {
    'use strict';

    e.exports = t(42), e.exports.easing = t(43), e.exports.canvas = t(41), e.exports.options = t(44);
  }, {
    41: 41, 42: 42, 43: 43, 44: 44,
  }],
  46: [function (t, e, i) { e.exports = { acquireContext(t) { return t && t.canvas && (t = t.canvas), t && t.getContext('2d') || null; } }; }, {}],
  47: [function (t, e, i) {
    'use strict';

    const n = t(45); const a = '$chartjs'; const o = 'chartjs-'; const r = `${o}render-monitor`; const s = `${o}render-animation`; const l = ['animationstart', 'webkitAnimationStart']; const u = {
      touchstart: 'mousedown', touchmove: 'mousemove', touchend: 'mouseup', pointerenter: 'mouseenter', pointerdown: 'mousedown', pointermove: 'mousemove', pointerup: 'mouseup', pointerleave: 'mouseout', pointerout: 'mouseout',
    }; function d(t, e) { const i = n.getStyle(t, e); const a = i && i.match(/^(\d+)(\.\d+)?px$/); return a ? Number(a[1]) : void 0; } const c = !!(function () { let t = !1; try { const e = Object.defineProperty({}, 'passive', { get() { t = !0; } }); window.addEventListener('e', null, e); } catch (t) {} return t; }()) && { passive: !0 }; function h(t, e, i) { t.addEventListener(e, i, c); } function f(t, e, i) { t.removeEventListener(e, i, c); } function g(t, e, i, n, a) {
      return {
        type: t, chart: e, native: a || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null,
      };
    } function p(t, e, i) { let u; let d; let c; let f; let p; let m; let v; let b; const x = t[a] || (t[a] = {}); const y = x.resizer = (function (t) { const e = document.createElement('div'); const i = `${o }size-monitor`; const n = 'position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;'; e.style.cssText = n, e.className = i, e.innerHTML = `<div class="${i}-expand" style="${n}"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="${i}-shrink" style="${n}"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>`; const a = e.childNodes[0]; const r = e.childNodes[1]; e._reset = function () { a.scrollLeft = 1e6, a.scrollTop = 1e6, r.scrollLeft = 1e6, r.scrollTop = 1e6; }; const s = function () { e._reset(), t(); }; return h(a, 'scroll', s.bind(a, 'expand')), h(r, 'scroll', s.bind(r, 'shrink')), e; }((u = function () { if (x.resizer) return e(g('resize', i)); }, c = !1, f = [], function () { f = Array.prototype.slice.call(arguments), d = d || this, c || (c = !0, n.requestAnimFrame.call(window, () => { c = !1, u.apply(d, f); })); }))); m = function () { if (x.resizer) { const e = t.parentNode; e && e !== y.parentNode && e.insertBefore(y, e.firstChild), y._reset(); } }, v = (p = t)[a] || (p[a] = {}), b = v.renderProxy = function (t) { t.animationName === s && m(); }, n.each(l, (t) => { h(p, t, b); }), v.reflow = !!p.offsetParent, p.classList.add(r); } function m(t) { let e; let i; let o; const s = t[a] || {}; const u = s.resizer; delete s.resizer, i = (e = t)[a] || {}, (o = i.renderProxy) && (n.each(l, (t) => { f(e, t, o); }), delete i.renderProxy), e.classList.remove(r), u && u.parentNode && u.parentNode.removeChild(u); }e.exports = {
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined', initialize() { let t; let e; let i; const n = 'from{opacity:0.99}to{opacity:1}'; e = `@-webkit-keyframes ${s}{${n}}@keyframes ${s}{${n}}.${r}{-webkit-animation:${s} 0.001s;animation:${s} 0.001s;}`, i = (t = this)._style || document.createElement('style'), t._style || (t._style = i, e = `/* Chart.js */\n${e}`, i.setAttribute('type', 'text/css'), document.getElementsByTagName('head')[0].appendChild(i)), i.appendChild(document.createTextNode(e)); }, acquireContext(t, e) { typeof t === 'string' ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); const i = t && t.getContext && t.getContext('2d'); return i && i.canvas === t ? ((function (t, e) { const i = t.style; const n = t.getAttribute('height'); const o = t.getAttribute('width'); if (t[a] = { initial: { height: n, width: o, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || 'block', o === null || o === '') { var r = d(t, 'width'); void 0 !== r && (t.width = r); } if (n === null || n === '') if (t.style.height === '')t.height = t.width / (e.options.aspectRatio || 2); else { const s = d(t, 'height'); void 0 !== r && (t.height = s); } }(t, e)), i) : null; }, releaseContext(t) { const e = t.canvas; if (e[a]) { const i = e[a].initial; ['height', 'width'].forEach((t) => { const a = i[t]; n.isNullOrUndef(a) ? e.removeAttribute(t) : e.setAttribute(t, a); }), n.each(i.style || {}, (t, i) => { e.style[i] = t; }), e.width = e.width, delete e[a]; } }, addEventListener(t, e, i) { const o = t.canvas; if (e !== 'resize') { const r = i[a] || (i[a] = {}); h(o, e, (r.proxies || (r.proxies = {}))[`${t.id}_${e}`] = function (e) { let a; let o; let r; let s; i((o = t, r = u[(a = e).type] || a.type, s = n.getRelativePosition(a, o), g(r, o, s.x, s.y, a))); }); } else p(o, i, t); }, removeEventListener(t, e, i) { const n = t.canvas; if (e !== 'resize') { const o = ((i[a] || {}).proxies || {})[`${t.id}_${e}`]; o && f(n, e, o); } else m(n); },
    }, n.addEvent = h, n.removeEvent = f;
  }, { 45: 45 }],
  48: [function (t, e, i) {
    'use strict';

    const n = t(45); const a = t(46); const o = t(47); const r = o._enabled ? o : a; e.exports = n.extend({
      initialize() {}, acquireContext() {}, releaseContext() {}, addEventListener() {}, removeEventListener() {},
    }, r);
  }, { 45: 45, 46: 46, 47: 47 }],
  49: [function (t, e, i) {
    'use strict';

    e.exports = {}, e.exports.filler = t(50), e.exports.legend = t(51), e.exports.title = t(52);
  }, { 50: 50, 51: 51, 52: 52 }],
  50: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(40); const o = t(45); n._set('global', { plugins: { filler: { propagate: !0 } } }); const r = { dataset(t) { const e = t.fill; const i = t.chart; const n = i.getDatasetMeta(e); const a = n && i.isDatasetVisible(e) && n.dataset._children || []; const o = a.length || 0; return o ? function (t, e) { return e < o && a[e]._view || null; } : null; }, boundary(t) { const e = t.boundary; const i = e ? e.x : null; const n = e ? e.y : null; return function (t) { return { x: i === null ? t.x : i, y: n === null ? t.y : n }; }; } }; function s(t, e, i) { let n; const a = t._model || {}; let o = a.fill; if (void 0 === o && (o = !!a.backgroundColor), !1 === o || o === null) return !1; if (!0 === o) return 'origin'; if (n = parseFloat(o, 10), isFinite(n) && Math.floor(n) === n) return o[0] !== '-' && o[0] !== '+' || (n = e + n), !(n === e || n < 0 || n >= i) && n; switch (o) { case 'bottom': return 'start'; case 'top': return 'end'; case 'zero': return 'origin'; case 'origin': case 'start': case 'end': return o; default: return !1; } } function l(t) { let e; const i = t.el._model || {}; const n = t.el._scale || {}; const a = t.fill; let o = null; if (isFinite(a)) return null; if (a === 'start' ? o = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : a === 'end' ? o = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? o = i.scaleZero : n.getBasePosition ? o = n.getBasePosition() : n.getBasePixel && (o = n.getBasePixel()), o != null) { if (void 0 !== o.x && void 0 !== o.y) return o; if (typeof o === 'number' && isFinite(o)) return { x: (e = n.isHorizontal()) ? o : null, y: e ? null : o }; } return null; } function u(t, e, i) { let n; let a = t[e].fill; const o = [e]; if (!i) return a; for (;!1 !== a && o.indexOf(a) === -1;) { if (!isFinite(a)) return a; if (!(n = t[a])) return !1; if (n.visible) return a; o.push(a), a = n.fill; } return !1; } function d(t) { return t && !t.skip; } function c(t, e, i, n, a) { let r; if (n && a) { for (t.moveTo(e[0].x, e[0].y), r = 1; r < n; ++r)o.canvas.lineTo(t, e[r - 1], e[r]); for (t.lineTo(i[a - 1].x, i[a - 1].y), r = a - 1; r > 0; --r)o.canvas.lineTo(t, i[r], i[r - 1], !0); } }e.exports = {
      id: 'filler',
      afterDatasetsUpdate(t, e) {
        let i; let n; let o; let d; let c; let h; let f; const g = (t.data.datasets || []).length; const p = e.propagate; const m = []; for (n = 0; n < g; ++n) {
          d = null, (o = (i = t.getDatasetMeta(n)).dataset) && o._model && o instanceof a.Line && (d = {
            visible: t.isDatasetVisible(n), fill: s(o, n, g), chart: t, el: o,
          }), i.$filler = d, m.push(d);
        } for (n = 0; n < g; ++n)(d = m[n]) && (d.fill = u(m, n, p), d.boundary = l(d), d.mapper = (void 0, f = void 0, h = (c = d).fill, f = 'dataset', !1 === h ? null : (isFinite(h) || (f = 'boundary'), r[f](c))));
      },
      beforeDatasetDraw(t, e) { const i = e.meta.$filler; if (i) { const a = t.ctx; const r = i.el; const s = r._view; const l = r._children || []; const u = i.mapper; const h = s.backgroundColor || n.global.defaultColor; u && h && l.length && (o.canvas.clipArea(a, t.chartArea), (function (t, e, i, n, a, o) { let r; let s; let l; let u; let h; let f; let g; const p = e.length; const m = n.spanGaps; let v = []; let b = []; let x = 0; let y = 0; for (t.beginPath(), r = 0, s = p + !!o; r < s; ++r)h = i(u = e[l = r % p]._view, l, n), f = d(u), g = d(h), f && g ? (x = v.push(u), y = b.push(h)) : x && y && (m ? (f && v.push(u), g && b.push(h)) : (c(t, v, b, x, y), x = y = 0, v = [], b = [])); c(t, v, b, x, y), t.closePath(), t.fillStyle = a, t.fill(); }(a, l, u, s, h, r._loop)), o.canvas.unclipArea(a)); } },
    };
  }, { 25: 25, 40: 40, 45: 45 }],
  51: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); const r = t(30); const s = o.noop; function l(t, e) { return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth; }n._set('global', {
      legend: {
        display: !0,
        position: 'top',
        fullWidth: !0,
        reverse: !1,
        weight: 1e3,
        onClick(t, e) { const i = e.datasetIndex; const n = this.chart; const a = n.getDatasetMeta(i); a.hidden = a.hidden === null ? !n.data.datasets[i].hidden : null, n.update(); },
        onHover: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          generateLabels(t) {
            const e = t.data; return o.isArray(e.datasets) ? e.datasets.map((e, i) => ({
              text: e.label, fillStyle: o.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i,
            }), this) : [];
          },
        },
      },
      legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); for (let i = 0; i < t.data.datasets.length; i++)e.push(`<li><span style="background-color:${t.data.datasets[i].backgroundColor}"></span>`), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push('</li>'); return e.push('</ul>'), e.join(''); },
    }); const u = a.extend({
      initialize(t) { o.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1; },
      beforeUpdate: s,
      update(t, e, i) { const n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; },
      afterUpdate: s,
      beforeSetDimensions: s,
      setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; },
      afterSetDimensions: s,
      beforeBuildLabels: s,
      buildLabels() { const t = this; const e = t.options.labels || {}; let i = o.callback(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter((i) => e.filter(i, t.chart.data))), t.options.reverse && i.reverse(), t.legendItems = i; },
      afterBuildLabels: s,
      beforeFit: s,
      fit() {
        const t = this; const e = t.options; const i = e.labels; const a = e.display; const r = t.ctx; const s = n.global; const u = o.valueOrDefault; const d = u(i.fontSize, s.defaultFontSize); const c = u(i.fontStyle, s.defaultFontStyle); const h = u(i.fontFamily, s.defaultFontFamily); const f = o.fontString(d, c, h); const g = t.legendHitBoxes = []; const p = t.minSize; const m = t.isHorizontal(); if (m ? (p.width = t.maxWidth, p.height = a ? 10 : 0) : (p.width = a ? 10 : 0, p.height = t.maxHeight), a) {
 if (r.font = f, m) {
          const v = t.lineWidths = [0]; let b = t.legendItems.length ? d + i.padding : 0; r.textAlign = 'left', r.textBaseline = 'top', o.each(t.legendItems, (e, n) => {
            const a = l(i, d) + d / 2 + r.measureText(e.text).width; v[v.length - 1] + a + i.padding >= t.width && (b += d + i.padding, v[v.length] = t.left), g[n] = {
              left: 0, top: 0, width: a, height: d,
            }, v[v.length - 1] += a + i.padding;
          }), p.height += b;
        } else {
          const x = i.padding; const y = t.columnWidths = []; let k = i.padding; let M = 0; let w = 0; const S = d + x; o.each(t.legendItems, (t, e) => {
            const n = l(i, d) + d / 2 + r.measureText(t.text).width; w + S > p.height && (k += M + i.padding, y.push(M), M = 0, w = 0), M = Math.max(M, n), w += S, g[e] = {
              left: 0, top: 0, width: n, height: d,
            };
          }), k += M, y.push(M), p.width += k;
        } 
}t.width = p.width, t.height = p.height;
      },
      afterFit: s,
      isHorizontal() { return this.options.position === 'top' || this.options.position === 'bottom'; },
      draw() { const t = this; const e = t.options; const i = e.labels; const a = n.global; const r = a.elements.line; const s = t.width; const u = t.lineWidths; if (e.display) { let d; const c = t.ctx; const h = o.valueOrDefault; const f = h(i.fontColor, a.defaultFontColor); const g = h(i.fontSize, a.defaultFontSize); const p = h(i.fontStyle, a.defaultFontStyle); const m = h(i.fontFamily, a.defaultFontFamily); const v = o.fontString(g, p, m); c.textAlign = 'left', c.textBaseline = 'middle', c.lineWidth = 0.5, c.strokeStyle = f, c.fillStyle = f, c.font = v; const b = l(i, g); const x = t.legendHitBoxes; const y = t.isHorizontal(); d = y ? { x: t.left + (s - u[0]) / 2, y: t.top + i.padding, line: 0 } : { x: t.left + i.padding, y: t.top + i.padding, line: 0 }; const k = g + i.padding; o.each(t.legendItems, (n, l) => { let f; let p; let m; let v; let M; const w = c.measureText(n.text).width; const S = b + g / 2 + w; let C = d.x; let _ = d.y; y ? C + S >= s && (_ = d.y += k, d.line++, C = d.x = t.left + (s - u[d.line]) / 2) : _ + k > t.bottom && (C = d.x = C + t.columnWidths[d.line] + i.padding, _ = d.y = t.top + i.padding, d.line++), (function (t, i, n) { if (!(isNaN(b) || b <= 0)) { c.save(), c.fillStyle = h(n.fillStyle, a.defaultColor), c.lineCap = h(n.lineCap, r.borderCapStyle), c.lineDashOffset = h(n.lineDashOffset, r.borderDashOffset), c.lineJoin = h(n.lineJoin, r.borderJoinStyle), c.lineWidth = h(n.lineWidth, r.borderWidth), c.strokeStyle = h(n.strokeStyle, a.defaultColor); const s = h(n.lineWidth, r.borderWidth) === 0; if (c.setLineDash && c.setLineDash(h(n.lineDash, r.borderDash)), e.labels && e.labels.usePointStyle) { const l = g * Math.SQRT2 / 2; const u = l / Math.SQRT2; const d = t + u; const f = i + u; o.canvas.drawPoint(c, n.pointStyle, l, d, f); } else s || c.strokeRect(t, i, b, g), c.fillRect(t, i, b, g); c.restore(); } }(C, _, n)), x[l].left = C, x[l].top = _, f = n, p = w, v = b + (m = g / 2) + C, M = _ + m, c.fillText(f.text, v, M), f.hidden && (c.beginPath(), c.lineWidth = 2, c.moveTo(v, M), c.lineTo(v + p, M), c.stroke()), y ? d.x += S + i.padding : d.y += k; }); } },
      handleEvent(t) { const e = this; const i = e.options; const n = t.type === 'mouseup' ? 'click' : t.type; let a = !1; if (n === 'mousemove') { if (!i.onHover) return; } else { if (n !== 'click') return; if (!i.onClick) return; } const o = t.x; const r = t.y; if (o >= e.left && o <= e.right && r >= e.top && r <= e.bottom) for (let s = e.legendHitBoxes, l = 0; l < s.length; ++l) { const u = s[l]; if (o >= u.left && o <= u.left + u.width && r >= u.top && r <= u.top + u.height) { if (n === 'click') { i.onClick.call(e, t.native, e.legendItems[l]), a = !0; break; } if (n === 'mousemove') { i.onHover.call(e, t.native, e.legendItems[l]), a = !0; break; } } } return a; },
    }); function d(t, e) { const i = new u({ ctx: t.ctx, options: e, chart: t }); r.configure(t, i, e), r.addBox(t, i), t.legend = i; }e.exports = {
      id: 'legend', _element: u, beforeInit(t) { const e = t.options.legend; e && d(t, e); }, beforeUpdate(t) { const e = t.options.legend; const i = t.legend; e ? (o.mergeIf(e, n.global.legend), i ? (r.configure(t, i, e), i.options = e) : d(t, e)) : i && (r.removeBox(t, i), delete t.legend); }, afterEvent(t, e) { const i = t.legend; i && i.handleEvent(e); },
    };
  }, {
    25: 25, 26: 26, 30: 30, 45: 45,
  }],
  52: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(26); const o = t(45); const r = t(30); const s = o.noop; n._set('global', {
      title: {
        display: !1, fontStyle: 'bold', fullWidth: !0, lineHeight: 1.2, padding: 10, position: 'top', text: '', weight: 2e3,
      },
    }); const l = a.extend({
      initialize(t) { o.extend(this, t), this.legendHitBoxes = []; }, beforeUpdate: s, update(t, e, i) { const n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; }, afterUpdate: s, beforeSetDimensions: s, setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; }, afterSetDimensions: s, beforeBuildLabels: s, buildLabels: s, afterBuildLabels: s, beforeFit: s, fit() { const t = this; const e = o.valueOrDefault; const i = t.options; const a = i.display; const r = e(i.fontSize, n.global.defaultFontSize); const s = t.minSize; const l = o.isArray(i.text) ? i.text.length : 1; const u = o.options.toLineHeight(i.lineHeight, r); const d = a ? l * u + 2 * i.padding : 0; t.isHorizontal() ? (s.width = t.maxWidth, s.height = d) : (s.width = d, s.height = t.maxHeight), t.width = s.width, t.height = s.height; }, afterFit: s, isHorizontal() { const t = this.options.position; return t === 'top' || t === 'bottom'; }, draw() { const t = this; const e = t.ctx; const i = o.valueOrDefault; const a = t.options; const r = n.global; if (a.display) { let s; let l; let u; const d = i(a.fontSize, r.defaultFontSize); const c = i(a.fontStyle, r.defaultFontStyle); const h = i(a.fontFamily, r.defaultFontFamily); const f = o.fontString(d, c, h); const g = o.options.toLineHeight(a.lineHeight, d); const p = g / 2 + a.padding; let m = 0; const v = t.top; const b = t.left; const x = t.bottom; const y = t.right; e.fillStyle = i(a.fontColor, r.defaultFontColor), e.font = f, t.isHorizontal() ? (l = b + (y - b) / 2, u = v + p, s = y - b) : (l = a.position === 'left' ? b + p : y - p, u = v + (x - v) / 2, s = x - v, m = Math.PI * (a.position === 'left' ? -0.5 : 0.5)), e.save(), e.translate(l, u), e.rotate(m), e.textAlign = 'center', e.textBaseline = 'middle'; const k = a.text; if (o.isArray(k)) for (let M = 0, w = 0; w < k.length; ++w)e.fillText(k[w], 0, M, s), M += g; else e.fillText(k, 0, 0, s); e.restore(); } },
    }); function u(t, e) { const i = new l({ ctx: t.ctx, options: e, chart: t }); r.configure(t, i, e), r.addBox(t, i), t.titleBlock = i; }e.exports = {
      id: 'title', _element: l, beforeInit(t) { const e = t.options.title; e && u(t, e); }, beforeUpdate(t) { const e = t.options.title; const i = t.titleBlock; e ? (o.mergeIf(e, n.global.title), i ? (r.configure(t, i, e), i.options = e) : u(t, e)) : i && (r.removeBox(t, i), delete t.titleBlock); },
    };
  }, {
    25: 25, 26: 26, 30: 30, 45: 45,
  }],
  53: [function (t, e, i) {
    'use strict';

    e.exports = function (t) {
      const e = t.Scale.extend({
        getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels; }, determineDataLimits() { let t; const e = this; const i = e.getLabels(); e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = t !== -1 ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = t !== -1 ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex]; }, buildTicks() { const t = this; const e = t.getLabels(); t.ticks = t.minIndex === 0 && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1); }, getLabelForIndex(t, e) { const i = this; const n = i.chart.data; const a = i.isHorizontal(); return n.yLabels && !a ? i.getRightValue(n.datasets[e].data[t]) : i.ticks[t - i.minIndex]; }, getPixelForValue(t, e) { let i; const n = this; const a = n.options.offset; const o = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1); if (t != null && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) { t = i || t; const r = n.getLabels().indexOf(t); e = r !== -1 ? r : e; } if (n.isHorizontal()) { const s = n.width / o; let l = s * (e - n.minIndex); return a && (l += s / 2), n.left + Math.round(l); } const u = n.height / o; let d = u * (e - n.minIndex); return a && (d += u / 2), n.top + Math.round(d); }, getPixelForTick(t) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null); }, getValueForPixel(t) { const e = this; const i = e.options.offset; const n = Math.max(e._ticks.length - (i ? 0 : 1), 1); const a = e.isHorizontal(); const o = (a ? e.width : e.height) / n; return t -= a ? e.left : e.top, i && (t -= o / 2), (t <= 0 ? 0 : Math.round(t / o)) + e.minIndex; }, getBasePixel() { return this.bottom; },
      }); t.scaleService.registerScaleType('category', e, { position: 'bottom' });
    };
  }, {}],
  54: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(45); const o = t(34); e.exports = function (t) {
      const e = { position: 'left', ticks: { callback: o.formatters.linear } }; const i = t.LinearScaleBase.extend({
        determineDataLimits() { const t = this; const e = t.options; const i = t.chart; const n = i.data.datasets; const o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id; }t.min = null, t.max = null; let s = e.stacked; if (void 0 === s && a.each(n, (t, e) => { if (!s) { const n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0); } }), e.stacked || s) { const l = {}; a.each(n, (n, o) => { const s = i.getDatasetMeta(o); const u = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : '', s.stack].join('.'); void 0 === l[u] && (l[u] = { positiveValues: [], negativeValues: [] }); const d = l[u].positiveValues; const c = l[u].negativeValues; i.isDatasetVisible(o) && r(s) && a.each(n.data, (i, n) => { const a = +t.getRightValue(i); isNaN(a) || s.data[n].hidden || (d[n] = d[n] || 0, c[n] = c[n] || 0, e.relativePoints ? d[n] = 100 : a < 0 ? c[n] += a : d[n] += a); }); }), a.each(l, (e) => { const i = e.positiveValues.concat(e.negativeValues); const n = a.min(i); const o = a.max(i); t.min = t.min === null ? n : Math.min(t.min, n), t.max = t.max === null ? o : Math.max(t.max, o); }); } else a.each(n, (e, n) => { const o = i.getDatasetMeta(n); i.isDatasetVisible(n) && r(o) && a.each(e.data, (e, i) => { const n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || (t.min === null ? t.min = n : n < t.min && (t.min = n), t.max === null ? t.max = n : n > t.max && (t.max = n)); }); }); t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions(); }, getTickLimit() { let t; const e = this.options.ticks; if (this.isHorizontal())t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.width / 50)); else { const i = a.valueOrDefault(e.fontSize, n.global.defaultFontSize); t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.height / (2 * i))); } return t; }, handleDirectionalChanges() { this.isHorizontal() || this.ticks.reverse(); }, getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForValue(t) { const e = this; const i = e.start; const n = +e.getRightValue(t); const a = e.end - i; return e.isHorizontal() ? e.left + e.width / a * (n - i) : e.bottom - e.height / a * (n - i); }, getValueForPixel(t) { const e = this; const i = e.isHorizontal(); const n = i ? e.width : e.height; const a = (i ? t - e.left : e.bottom - t) / n; return e.start + (e.end - e.start) * a; }, getPixelForTick(t) { return this.getPixelForValue(this.ticksAsNumbers[t]); },
      }); t.scaleService.registerScaleType('linear', i, e);
    };
  }, { 25: 25, 34: 34, 45: 45 }],
  55: [function (t, e, i) {
    'use strict';

    const n = t(45); e.exports = function (t) {
      const e = n.noop; t.LinearScaleBase = t.Scale.extend({
        getRightValue(e) { return typeof e === 'string' ? +e : t.Scale.prototype.getRightValue.call(this, e); },
        handleTickRangeOptions() { const t = this; const e = t.options.ticks; if (e.beginAtZero) { const i = n.sign(t.min); const a = n.sign(t.max); i < 0 && a < 0 ? t.max = 0 : i > 0 && a > 0 && (t.min = 0); } const o = void 0 !== e.min || void 0 !== e.suggestedMin; const r = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (t.min === null ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (t.max === null ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), o !== r && t.min >= t.max && (o ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--); },
        getTickLimit: e,
        handleDirectionalChanges: e,
        buildTicks() {
          const t = this; const e = t.options.ticks; let i = t.getTickLimit(); const a = {
            maxTicks: i = Math.max(2, i), min: e.min, max: e.max, stepSize: n.valueOrDefault(e.fixedStepSize, e.stepSize),
          }; const o = t.ticks = (function (t, e) { let i; const a = []; if (t.stepSize && t.stepSize > 0)i = t.stepSize; else { const o = n.niceNum(e.max - e.min, !1); i = n.niceNum(o / (t.maxTicks - 1), !0); } let r = Math.floor(e.min / i) * i; let s = Math.ceil(e.max / i) * i; t.min && t.max && t.stepSize && n.almostWhole((t.max - t.min) / t.stepSize, i / 1e3) && (r = t.min, s = t.max); let l = (s - r) / i; l = n.almostEquals(l, Math.round(l), i / 1e3) ? Math.round(l) : Math.ceil(l); let u = 1; i < 1 && (u = 10 ** (i.toString().length - 2), r = Math.round(r * u) / u, s = Math.round(s * u) / u), a.push(void 0 !== t.min ? t.min : r); for (let d = 1; d < l; ++d)a.push(Math.round((r + d * i) * u) / u); return a.push(void 0 !== t.max ? t.max : s), a; }(a, t)); t.handleDirectionalChanges(), t.max = n.max(o), t.min = n.min(o), e.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
        },
        convertTicksToLabels() { const e = this; e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e); },
      });
    };
  }, { 45: 45 }],
  56: [function (t, e, i) {
    'use strict';

    const n = t(45); const a = t(34); e.exports = function (t) {
      const e = { position: 'left', ticks: { callback: a.formatters.logarithmic } }; const i = t.Scale.extend({
        determineDataLimits() { const t = this; const e = t.options; const i = t.chart; const a = i.data.datasets; const o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id; }t.min = null, t.max = null, t.minNotZero = null; let s = e.stacked; if (void 0 === s && n.each(a, (t, e) => { if (!s) { const n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0); } }), e.stacked || s) { const l = {}; n.each(a, (a, o) => { const s = i.getDatasetMeta(o); const u = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : '', s.stack].join('.'); i.isDatasetVisible(o) && r(s) && (void 0 === l[u] && (l[u] = []), n.each(a.data, (e, i) => { const n = l[u]; const a = +t.getRightValue(e); isNaN(a) || s.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a); })); }), n.each(l, (e) => { if (e.length > 0) { const i = n.min(e); const a = n.max(e); t.min = t.min === null ? i : Math.min(t.min, i), t.max = t.max === null ? a : Math.max(t.max, a); } }); } else n.each(a, (e, a) => { const o = i.getDatasetMeta(a); i.isDatasetVisible(a) && r(o) && n.each(e.data, (e, i) => { const n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || n < 0 || (t.min === null ? t.min = n : n < t.min && (t.min = n), t.max === null ? t.max = n : n > t.max && (t.max = n), n !== 0 && (t.minNotZero === null || n < t.minNotZero) && (t.minNotZero = n)); }); }); this.handleTickRangeOptions(); }, handleTickRangeOptions() { const t = this; const e = t.options.ticks; const i = n.valueOrDefault; t.min = i(e.min, t.min), t.max = i(e.max, t.max), t.min === t.max && (t.min !== 0 && t.min !== null ? (t.min = 10 ** (Math.floor(n.log10(t.min)) - 1), t.max = 10 ** (Math.floor(n.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), t.min === null && (t.min = 10 ** (Math.floor(n.log10(t.max)) - 1)), t.max === null && (t.max = t.min !== 0 ? 10 ** (Math.floor(n.log10(t.min)) + 1) : 10), t.minNotZero === null && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = 10 ** Math.floor(n.log10(t.max)) : t.minNotZero = 1); }, buildTicks() { const t = this; const e = t.options.ticks; let i = !t.isHorizontal(); const a = { min: e.min, max: e.max }; const o = t.ticks = (function (t, e) { let i; let a; const o = []; const r = n.valueOrDefault; let s = r(t.min, 10**Math.floor(n.log10(e.min))); const l = Math.floor(n.log10(e.max)); const u = Math.ceil(e.max / 10**l); s === 0 ? (i = Math.floor(n.log10(e.minNotZero)), a = Math.floor(e.minNotZero / 10 ** i), o.push(s), s = a * 10 ** i) : (i = Math.floor(n.log10(s)), a = Math.floor(s / 10 ** i)); for (let d = i < 0 ? 10 ** Math.abs(i) : 1; o.push(s), ++a == 10 && (a = 1, d = ++i >= 0 ? 1 : d), s = Math.round(a * 10 ** i * d) / d, i < l || i === l && a < u;);const c = r(t.max, s); return o.push(c), o; }(a, t)); t.max = n.max(o), t.min = n.min(o), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && o.reverse(); }, convertTicksToLabels() { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this); }, getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForTick(t) { return this.getPixelForValue(this.tickValues[t]); }, _getFirstTickValue(t) { const e = Math.floor(n.log10(t)); return Math.floor(t / 10 ** e) * 10 ** e; }, getPixelForValue(e) { let i; let a; let o; let r; let s; const l = this; const u = l.options.ticks.reverse; const d = n.log10; const c = l._getFirstTickValue(l.minNotZero); let h = 0; return e = +l.getRightValue(e), u ? (o = l.end, r = l.start, s = -1) : (o = l.start, r = l.end, s = 1), l.isHorizontal() ? (i = l.width, a = u ? l.right : l.left) : (i = l.height, s *= -1, a = u ? l.top : l.bottom), e !== o && (o === 0 && (i -= h = n.getValueOrDefault(l.options.ticks.fontSize, t.defaults.global.defaultFontSize), o = c), e !== 0 && (h += i / (d(r) - d(o)) * (d(e) - d(o))), a += s * h), a; }, getValueForPixel(e) { let i; let a; let o; let r; const s = this; const l = s.options.ticks.reverse; const u = n.log10; const d = s._getFirstTickValue(s.minNotZero); if (l ? (a = s.end, o = s.start) : (a = s.start, o = s.end), s.isHorizontal() ? (i = s.width, r = l ? s.right - e : e - s.left) : (i = s.height, r = l ? e - s.top : s.bottom - e), r !== a) { if (a === 0) { const c = n.getValueOrDefault(s.options.ticks.fontSize, t.defaults.global.defaultFontSize); r -= c, i -= c, a = d; }r *= u(o) - u(a), r /= i, r = 10 ** (u(a) + r); } return r; },
      }); t.scaleService.registerScaleType('logarithmic', i, e);
    };
  }, { 34: 34, 45: 45 }],
  57: [function (t, e, i) {
    'use strict';

    const n = t(25); const a = t(45); const o = t(34); e.exports = function (t) {
      const e = n.global; const i = {
        display: !0,
        animate: !0,
        position: 'chartArea',
        angleLines: { display: !0, color: 'rgba(0, 0, 0, 0.1)', lineWidth: 1 },
        gridLines: { circular: !1 },
        ticks: {
          showLabelBackdrop: !0, backdropColor: 'rgba(255,255,255,0.75)', backdropPaddingY: 2, backdropPaddingX: 2, callback: o.formatters.linear,
        },
        pointLabels: { display: !0, fontSize: 10, callback(t) { return t; } },
      }; function r(t) { const e = t.options; return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0; } function s(t) {
        const i = t.options.pointLabels; const n = a.valueOrDefault(i.fontSize, e.defaultFontSize); const o = a.valueOrDefault(i.fontStyle, e.defaultFontStyle); const r = a.valueOrDefault(i.fontFamily, e.defaultFontFamily); return {
          size: n, style: o, family: r, font: a.fontString(n, o, r),
        };
      } function l(t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i - 5, end: e } : { start: e, end: e + i + 5 }; } function u(t, e, i, n) { if (a.isArray(e)) for (let o = i.y, r = 1.5 * n, s = 0; s < e.length; ++s)t.fillText(e[s], i.x, o), o += r; else t.fillText(e, i.x, i.y); } function d(t) { return a.isNumber(t) ? t : 0; } const c = t.LinearScaleBase.extend({
        setDimensions() { const t = this; const i = t.options; const n = i.ticks; t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2); const o = a.min([t.height, t.width]); const r = a.valueOrDefault(n.fontSize, e.defaultFontSize); t.drawingArea = i.display ? o / 2 - (r / 2 + n.backdropPaddingY) : o / 2; }, determineDataLimits() { const t = this; const e = t.chart; let i = Number.POSITIVE_INFINITY; let n = Number.NEGATIVE_INFINITY; a.each(e.data.datasets, (o, r) => { if (e.isDatasetVisible(r)) { const s = e.getDatasetMeta(r); a.each(o.data, (e, a) => { const o = +t.getRightValue(e); isNaN(o) || s.data[a].hidden || (i = Math.min(o, i), n = Math.max(o, n)); }); } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions(); }, getTickLimit() { const t = this.options.ticks; const i = a.valueOrDefault(t.fontSize, e.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i))); }, convertTicksToLabels() { const e = this; t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e); }, getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, fit() { let t; let e; this.options.pointLabels.display ? (function (t) { let e; let i; let n; const o = s(t); const u = Math.min(t.height / 2, t.width / 2); const d = {
 r: t.width, l: 0, t: t.height, b: 0 
}; const c = {}; t.ctx.font = o.font, t._pointLabelSizes = []; let h; let f; let g; const p = r(t); for (e = 0; e < p; e++) { n = t.getPointPosition(e, u), h = t.ctx, f = o.size, g = t.pointLabels[e] || '', i = a.isArray(g) ? { w: a.longestText(h, h.font, g), h: g.length * f + 1.5 * (g.length - 1) * f } : { w: h.measureText(g).width, h: f }, t._pointLabelSizes[e] = i; const m = t.getIndexAngle(e); const v = a.toDegrees(m) % 360; const b = l(v, n.x, i.w, 0, 180); const x = l(v, n.y, i.h, 90, 270); b.start < d.l && (d.l = b.start, c.l = m), b.end > d.r && (d.r = b.end, c.r = m), x.start < d.t && (d.t = x.start, c.t = m), x.end > d.b && (d.b = x.end, c.b = m); }t.setReductions(u, d, c); }(this)) : (t = this, e = Math.min(t.height / 2, t.width / 2), t.drawingArea = Math.round(e), t.setCenterPoint(0, 0, 0, 0)); }, setReductions(t, e, i) { let n = e.l / Math.sin(i.l); let a = Math.max(e.r - this.width, 0) / Math.sin(i.r); let o = -e.t / Math.cos(i.t); let r = -Math.max(e.b - this.height, 0) / Math.cos(i.b); n = d(n), a = d(a), o = d(o), r = d(r), this.drawingArea = Math.min(Math.round(t - (n + a) / 2), Math.round(t - (o + r) / 2)), this.setCenterPoint(n, a, o, r); }, setCenterPoint(t, e, i, n) { const a = this; const o = a.width - e - a.drawingArea; const r = t + a.drawingArea; const s = i + a.drawingArea; const l = a.height - n - a.drawingArea; a.xCenter = Math.round((r + o) / 2 + a.left), a.yCenter = Math.round((s + l) / 2 + a.top); }, getIndexAngle(t) { return t * (2 * Math.PI / r(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360; }, getDistanceFromCenterForValue(t) { const e = this; if (t === null) return 0; const i = e.drawingArea / (e.max - e.min); return e.options.ticks.reverse ? (e.max - t) * i : (t - e.min) * i; }, getPointPosition(t, e) { const i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.round(Math.cos(i) * e) + this.xCenter, y: Math.round(Math.sin(i) * e) + this.yCenter }; }, getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)); }, getBasePosition() { const t = this.min; const e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0); }, draw() { const t = this; const i = t.options; const n = i.gridLines; const o = i.ticks; const l = a.valueOrDefault; if (i.display) { const d = t.ctx; const c = this.getIndexAngle(0); const h = l(o.fontSize, e.defaultFontSize); const f = l(o.fontStyle, e.defaultFontStyle); const g = l(o.fontFamily, e.defaultFontFamily); const p = a.fontString(h, f, g); a.each(t.ticks, (i, s) => { if (s > 0 || o.reverse) { const u = t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]); if (n.display && s !== 0 && (function (t, e, i, n) { const o = t.ctx; if (o.strokeStyle = a.valueAtIndexOrDefault(e.color, n - 1), o.lineWidth = a.valueAtIndexOrDefault(e.lineWidth, n - 1), t.options.gridLines.circular)o.beginPath(), o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI), o.closePath(), o.stroke(); else { const s = r(t); if (s === 0) return; o.beginPath(); let l = t.getPointPosition(0, i); o.moveTo(l.x, l.y); for (let u = 1; u < s; u++)l = t.getPointPosition(u, i), o.lineTo(l.x, l.y); o.closePath(), o.stroke(); } }(t, n, u, s)), o.display) { const f = l(o.fontColor, e.defaultFontColor); if (d.font = p, d.save(), d.translate(t.xCenter, t.yCenter), d.rotate(c), o.showLabelBackdrop) { const g = d.measureText(i).width; d.fillStyle = o.backdropColor, d.fillRect(-g / 2 - o.backdropPaddingX, -u - h / 2 - o.backdropPaddingY, g + 2 * o.backdropPaddingX, h + 2 * o.backdropPaddingY); }d.textAlign = 'center', d.textBaseline = 'middle', d.fillStyle = f, d.fillText(i, 0, -u), d.restore(); } } }), (i.angleLines.display || i.pointLabels.display) && (function (t) { const i = t.ctx; const n = t.options; const o = n.angleLines; const l = n.pointLabels; i.lineWidth = o.lineWidth, i.strokeStyle = o.color; let d; let c; let h; let f; const g = t.getDistanceFromCenterForValue(n.ticks.reverse ? t.min : t.max); const p = s(t); i.textBaseline = 'top'; for (let m = r(t) - 1; m >= 0; m--) { if (o.display) { const v = t.getPointPosition(m, g); i.beginPath(), i.moveTo(t.xCenter, t.yCenter), i.lineTo(v.x, v.y), i.stroke(), i.closePath(); } if (l.display) { const b = t.getPointPosition(m, g + 5); const x = a.valueAtIndexOrDefault(l.fontColor, m, e.defaultFontColor); i.font = p.font, i.fillStyle = x; const y = t.getIndexAngle(m); const k = a.toDegrees(y); i.textAlign = (f = k) === 0 || f === 180 ? 'center' : f < 180 ? 'left' : 'right', d = k, c = t._pointLabelSizes[m], h = b, d === 90 || d === 270 ? h.y -= c.h / 2 : (d > 270 || d < 90) && (h.y -= c.h), u(i, t.pointLabels[m] || '', b, p.size); } } }(t)); } },
      }); t.scaleService.registerScaleType('radialLinear', c, i);
    };
  }, { 25: 25, 34: 34, 45: 45 }],
  58: [function (t, e, i) {
    'use strict';

    let n = t(1); n = typeof n === 'function' ? n : window.moment; const a = t(25); const o = t(45); const r = Number.MIN_SAFE_INTEGER || -9007199254740991; const s = Number.MAX_SAFE_INTEGER || 9007199254740991; const l = {
      millisecond: { common: !0, size: 1, steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 30] }, minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 30] }, hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] }, day: { common: !0, size: 864e5, steps: [1, 2, 5] }, week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] }, month: { common: !0, size: 2628e6, steps: [1, 2, 3] }, quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] }, year: { common: !0, size: 3154e7 },
    }; const u = Object.keys(l); function d(t, e) { return t - e; } function c(t) { let e; let i; let n; const a = {}; const o = []; for (e = 0, i = t.length; e < i; ++e)a[n = t[e]] || (a[n] = !0, o.push(n)); return o; } function h(t, e, i, n) { const a = (function (t, e, i) { for (var n, a, o, r = 0, s = t.length - 1; r >= 0 && r <= s;) { if (a = t[(n = r + s >> 1) - 1] || null, o = t[n], !a) return { lo: null, hi: o }; if (o[e] < i)r = n + 1; else { if (!(a[e] > i)) return { lo: a, hi: o }; s = n - 1; } } return { lo: o, hi: null }; }(t, e, i)); const o = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0]; const r = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1]; const s = r[e] - o[e]; const l = s ? (i - o[e]) / s : 0; const u = (r[n] - o[n]) * l; return o[n] + u; } function f(t, e) { const i = e.parser; const a = e.parser || e.format; return typeof i === 'function' ? i(t) : typeof t === 'string' && typeof a === 'string' ? n(t, a) : (t instanceof n || (t = n(t)), t.isValid() ? t : typeof a === 'function' ? a(t) : t); } function g(t, e) { if (o.isNullOrUndef(t)) return null; const i = e.options.time; const n = f(e.getRightValue(t), i); return n.isValid() ? (i.round && n.startOf(i.round), n.valueOf()) : null; } function p(t) { for (let e = u.indexOf(t) + 1, i = u.length; e < i; ++e) if (l[u[e]].common) return u[e]; } function m(t, e, i, a) { let r; const d = a.time; const c = d.unit || (function (t, e, i, n) { let a; let o; let r; const d = u.length; for (a = u.indexOf(t); a < d - 1; ++a) if (r = (o = l[u[a]]).steps ? o.steps[o.steps.length - 1] : s, o.common && Math.ceil((i - e) / (r * o.size)) <= n) return u[a]; return u[d - 1]; }(d.minUnit, t, e, i)); const h = p(c); let f = o.valueOrDefault(d.stepSize, d.unitStepSize); const g = c === 'week' && d.isoWeekday; const m = a.ticks.major.enabled; const v = l[c]; let b = n(t); let x = n(e); const y = []; for (f || (f = (function (t, e, i, n) { let a; let o; let r; const s = e - t; const u = l[i]; const d = u.size; const c = u.steps; if (!c) return Math.ceil(s / (n * d)); for (a = 0, o = c.length; a < o && (r = c[a], !(Math.ceil(s / (d * r)) <= n)); ++a);return r; }(t, e, c, i))), g && (b = b.isoWeekday(g), x = x.isoWeekday(g)), b = b.startOf(g ? 'day' : c), (x = x.startOf(g ? 'day' : c)) < e && x.add(1, c), r = n(b), m && h && !g && !d.round && (r.startOf(h), r.add(~~((b - r) / (v.size * f)) * f, c)); r < x; r.add(f, c))y.push(+r); return y.push(+r), y; }e.exports = function (t) {
      const e = t.Scale.extend({
        initialize() { if (!n) throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com'); this.mergeTicksOptions(), t.Scale.prototype.initialize.call(this); }, update() { const e = this.options; return e.time && e.time.format && console.warn('options.time.format is deprecated and replaced by options.time.parser.'), t.Scale.prototype.update.apply(this, arguments); }, getRightValue(e) { return e && void 0 !== e.t && (e = e.t), t.Scale.prototype.getRightValue.call(this, e); }, determineDataLimits() { let t; let e; let i; let a; let l; let u; const h = this; const f = h.chart; const p = h.options.time; const m = p.unit || 'day'; let v = s; let b = r; let x = []; const y = []; let k = []; for (t = 0, i = f.data.labels.length; t < i; ++t)k.push(g(f.data.labels[t], h)); for (t = 0, i = (f.data.datasets || []).length; t < i; ++t) if (f.isDatasetVisible(t)) if (l = f.data.datasets[t].data, o.isObject(l[0])) for (y[t] = [], e = 0, a = l.length; e < a; ++e)u = g(l[e], h), x.push(u), y[t][e] = u; else x.push.apply(x, k), y[t] = k.slice(0); else y[t] = []; k.length && (k = c(k).sort(d), v = Math.min(v, k[0]), b = Math.max(b, k[k.length - 1])), x.length && (x = c(x).sort(d), v = Math.min(v, x[0]), b = Math.max(b, x[x.length - 1])), v = g(p.min, h) || v, b = g(p.max, h) || b, v = v === s ? +n().startOf(m) : v, b = b === r ? +n().endOf(m) + 1 : b, h.min = Math.min(v, b), h.max = Math.max(v + 1, b), h._horizontal = h.isHorizontal(), h._table = [], h._timestamps = { data: x, datasets: y, labels: k }; }, buildTicks() { let t; let e; let i; let a; let o; let r; let s; let d; let c; let v; let b; let x; const y = this; let k = y.min; let M = y.max; const w = y.options; const S = w.time; let C = []; const _ = []; switch (w.ticks.source) { case 'data': C = y._timestamps.data; break; case 'labels': C = y._timestamps.labels; break; case 'auto': default: C = m(k, M, y.getLabelCapacity(k), w); } for (w.bounds === 'ticks' && C.length && (k = C[0], M = C[C.length - 1]), k = g(S.min, y) || k, M = g(S.max, y) || M, t = 0, e = C.length; t < e; ++t)(i = C[t]) >= k && i <= M && _.push(i); return y.min = k, y.max = M, y._unit = S.unit || (function (t, e, i, a) { let o; let r; const s = n.duration(n(a).diff(n(i))); for (o = u.length - 1; o >= u.indexOf(e); o--) if (r = u[o], l[r].common && s.as(r) >= t.length) return r; return u[e ? u.indexOf(e) : 0]; }(_, S.minUnit, y.min, y.max)), y._majorUnit = p(y._unit), y._table = (function (t, e, i, n) { if (n === 'linear' || !t.length) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; let a; let o; let r; let s; let l; const u = []; const d = [e]; for (a = 0, o = t.length; a < o; ++a)(s = t[a]) > e && s < i && d.push(s); for (d.push(i), a = 0, o = d.length; a < o; ++a)l = d[a + 1], r = d[a - 1], s = d[a], void 0 !== r && void 0 !== l && Math.round((l + r) / 2) === s || u.push({ time: s, pos: a / (o - 1) }); return u; }(y._timestamps.data, k, M, w.distribution)), y._offsets = (a = y._table, o = _, r = k, s = M, b = 0, x = 0, (d = w).offset && o.length && (d.time.min || (c = o.length > 1 ? o[1] : s, v = o[0], b = (h(a, 'time', c, 'pos') - h(a, 'time', v, 'pos')) / 2), d.time.max || (c = o[o.length - 1], v = o.length > 1 ? o[o.length - 2] : r, x = (h(a, 'time', c, 'pos') - h(a, 'time', v, 'pos')) / 2)), { left: b, right: x }), y._labelFormat = (function (t, e) { let i; let n; let a; const o = t.length; for (i = 0; i < o; i++) { if ((n = f(t[i], e)).millisecond() !== 0) return 'MMM D, YYYY h:mm:ss.SSS a'; n.second() === 0 && n.minute() === 0 && n.hour() === 0 || (a = !0); } return a ? 'MMM D, YYYY h:mm:ss a' : 'MMM D, YYYY'; }(y._timestamps.data, S)), (function (t, e) { let i; let a; let o; let r; const s = []; for (i = 0, a = t.length; i < a; ++i)o = t[i], r = !!e && o === +n(o).startOf(e), s.push({ value: o, major: r }); return s; }(_, y._majorUnit)); }, getLabelForIndex(t, e) { const i = this.chart.data; const n = this.options.time; let a = i.labels && t < i.labels.length ? i.labels[t] : ''; const r = i.datasets[e].data[t]; return o.isObject(r) && (a = this.getRightValue(r)), n.tooltipFormat ? f(a, n).format(n.tooltipFormat) : typeof a === 'string' ? a : f(a, n).format(this._labelFormat); }, tickFormatFunction(t, e, i, n) { const a = this.options; const r = t.valueOf(); const s = a.time.displayFormats; const l = s[this._unit]; const u = this._majorUnit; const d = s[u]; const c = t.clone().startOf(u).valueOf(); const h = a.ticks.major; const f = h.enabled && u && d && r === c; const g = t.format(n || (f ? d : l)); const p = f ? h : a.ticks.minor; const m = o.valueOrDefault(p.callback, p.userCallback); return m ? m(g, e, i) : g; }, convertTicksToLabels(t) { let e; let i; const a = []; for (e = 0, i = t.length; e < i; ++e)a.push(this.tickFormatFunction(n(t[e].value), e, t)); return a; }, getPixelForOffset(t) { const e = this; const i = e._horizontal ? e.width : e.height; const n = e._horizontal ? e.left : e.top; const a = h(e._table, 'time', t, 'pos'); return n + i * (e._offsets.left + a) / (e._offsets.left + 1 + e._offsets.right); }, getPixelForValue(t, e, i) { let n = null; if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), n === null && (n = g(t, this)), n !== null) return this.getPixelForOffset(n); }, getPixelForTick(t) { const e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null; }, getValueForPixel(t) { const e = this; const i = e._horizontal ? e.width : e.height; const a = e._horizontal ? e.left : e.top; const o = (i ? (t - a) / i : 0) * (e._offsets.left + 1 + e._offsets.left) - e._offsets.right; const r = h(e._table, 'pos', o, 'time'); return n(r); }, getLabelWidth(t) { const e = this.options.ticks; const i = this.ctx.measureText(t).width; const n = o.toRadians(e.maxRotation); const r = Math.cos(n); const s = Math.sin(n); return i * r + o.valueOrDefault(e.fontSize, a.global.defaultFontSize) * s; }, getLabelCapacity(t) { const e = this; const i = e.options.time.displayFormats.millisecond; const a = e.tickFormatFunction(n(t), 0, [], i); const o = e.getLabelWidth(a); const r = e.isHorizontal() ? e.width : e.height; const s = Math.floor(r / o); return s > 0 ? s : 1; },
      }); t.scaleService.registerScaleType('time', e, {
        position: 'bottom',
        distribution: 'linear',
        bounds: 'data',
        time: {
          parser: !1,
          format: !1,
          unit: !1,
          round: !1,
          displayFormat: !1,
          isoWeekday: !1,
          minUnit: 'millisecond',
          displayFormats: {
            millisecond: 'h:mm:ss.SSS a', second: 'h:mm:ss a', minute: 'h:mm a', hour: 'hA', day: 'MMM D', week: 'll', month: 'MMM YYYY', quarter: '[Q]Q - YYYY', year: 'YYYY',
          },
        },
        ticks: { autoSkip: !1, source: 'auto', major: { enabled: !1 } },
      });
    };
  }, { 1: 1, 25: 25, 45: 45 }],
}, {}, [7]))(7)));
