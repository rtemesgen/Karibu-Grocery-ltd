!(function (e, t, a, n) {
  'use strict';

  t = typeof t !== 'undefined' && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.calendar = function (t) {
    let o; const r = e(this); const i = r.selector || ''; let l = (new Date()).getTime(); let d = []; const s = arguments[0]; const u = typeof s === 'string'; const p = [].slice.call(arguments, 1); return r.each(function () {
      let r; let c; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.calendar.settings, t) : e.extend({}, e.fn.calendar.settings); const h = f.className; const g = f.namespace; const m = f.selector; const v = f.formatter; const y = f.parser; const D = f.metadata; const b = f.error; const C = `.${g}`; const M = `module-${g}`; const w = e(this); const x = w.find(m.input); let k = w.find(m.popup); let T = w.find(m.activator); const F = this; let H = w.data(M); let O = !1; let I = !1; c = {
        initialize() { c.debug('Initializing calendar for', F), r = c.get.isTouch(), c.setup.popup(), c.setup.inline(), c.setup.input(), c.setup.date(), c.create.calendar(), c.bind.events(), c.instantiate(); },
        instantiate() { c.verbose('Storing instance of calendar'), H = c, w.data(M, H); },
        destroy() { c.verbose('Destroying previous calendar for', F), w.removeData(M), c.unbind.events(); },
        setup: {
          popup() {
            if (!f.inline && (T.length || (T = w.children().first(), T.length))) {
              if (e.fn.popup === n) return void c.error(b.popup); k.length || (k = e('<div/>').addClass(h.popup).prependTo(T.parent())), k.addClass(h.calendar); let t = f.onVisible; let a = f.onHidden; x.length || (k.attr('tabindex', '0'), t = function () { return c.focus(), f.onVisible.apply(k, arguments); }, a = function () { return c.blur(), f.onHidden.apply(k, arguments); }); const o = function () { return c.set.focusDate(c.get.date()), c.set.mode(f.startMode), f.onShow.apply(k, arguments); }; const r = f.on || (x.length ? 'focus' : 'click'); const i = e.extend({}, f.popupOptions, {
                popup: k, on: r, hoverable: r === 'hover', onShow: o, onVisible: t, onHide: f.onHide, onHidden: a,
              }); c.popup(i);
            }
          },
          inline() { T.length && !f.inline || (k = e('<div/>').addClass(h.calendar).appendTo(w), x.length || k.attr('tabindex', '0')); },
          input() { f.touchReadonly && x.length && r && x.prop('readonly', !0); },
          date() { if (x.length) { const e = x.val(); const t = y.date(e, f); c.set.date(t, f.formatInput, !1); } },
        },
        create: {
          calendar() {
            let t; let a; let n; let o; let r; let i; let l; const d = c.get.mode(); const s = new Date(); const u = c.get.date(); let p = c.get.focusDate(); let g = p || u || f.initialDate || s; g = c.helper.dateInRange(g), p || (p = g, c.set.focusDate(p, !1, !1)); const m = d === 'year'; const y = d === 'month'; const b = d === 'day'; const C = d === 'hour'; const M = d === 'minute'; const w = f.type === 'time'; const x = Math.max(f.multiMonth, 1); const T = b ? c.get.monthOffset() : 0; const F = g.getMinutes(); const H = g.getHours(); const O = g.getDate(); const I = g.getMonth() + T; const N = g.getFullYear(); const Y = b ? 7 : C ? 4 : 3; const E = Y === 7 ? 'seven' : Y === 4 ? 'four' : 'three'; let R = b || C ? 6 : 4; const j = b ? x : 1; let A = k; for (A.empty(), j > 1 && (l = e('<div/>').addClass(h.grid).appendTo(A)), o = 0; o < j; o++) {
              if (j > 1) { const S = e('<div/>').addClass(h.column).appendTo(l); A = S; } const V = I + o; const P = (new Date(N, V, 1).getDay() - f.firstDayOfWeek % 7 + 7) % 7; if (!f.constantHeight && b) { const q = new Date(N, V + 1, 0).getDate() + P; R = Math.ceil(q / 7); } const K = m ? 10 : y ? 1 : 0; const J = b ? 1 : 0; const W = C || M ? 1 : 0; const z = C || M ? O : 1; const L = new Date(N - K, V - J, z - W, H); const B = new Date(N + K, V + J, z + W, H); const U = m ? new Date(10 * Math.ceil(N / 10) - 9, 0, 0) : y ? new Date(N, 0, 0) : b ? new Date(N, V, 0) : new Date(N, V, O, (-1)); const Q = m ? new Date(10 * Math.ceil(N / 10) + 1, 0, 1) : y ? new Date(N + 1, 0, 1) : b ? new Date(N, V + 1, 1) : new Date(N, V, O + 1); const Z = e('<table/>').addClass(h.table).addClass(`${E} column`).addClass(d)
                .appendTo(A); if (!w) { const G = e('<thead/>').appendTo(Z); r = e('<tr/>').appendTo(G), i = e('<th/>').attr('colspan', `${Y}`).appendTo(r); const X = m || y ? new Date(N, 0, 1) : b ? new Date(N, V, 1) : new Date(N, V, O, H, F); const $ = e('<span/>').addClass(h.link).appendTo(i); $.text(v.header(X, d, f)); const _ = y ? f.disableYear ? 'day' : 'year' : b ? f.disableMonth ? 'year' : 'month' : 'day'; if ($.data(D.mode, _), o === 0) { const ee = e('<span/>').addClass(h.prev).appendTo(i); ee.data(D.focusDate, L), ee.toggleClass(h.disabledCell, !c.helper.isDateInRange(U, d)), e('<i/>').addClass(h.prevIcon).appendTo(ee); } if (o === j - 1) { const te = e('<span/>').addClass(h.next).appendTo(i); te.data(D.focusDate, B), te.toggleClass(h.disabledCell, !c.helper.isDateInRange(Q, d)), e('<i/>').addClass(h.nextIcon).appendTo(te); } if (b) for (r = e('<tr/>').appendTo(G), t = 0; t < Y; t++)i = e('<th/>').appendTo(r), i.text(v.dayColumnHeader((t + f.firstDayOfWeek) % 7, f)); } const ae = e('<tbody/>').appendTo(Z); for (t = m ? 10 * Math.ceil(N / 10) - 9 : b ? 1 - P : 0, a = 0; a < R; a++) {
                for (r = e('<tr/>').appendTo(ae), n = 0; n < Y; n++, t++) {
                  const ne = m ? new Date(t, V, 1, H, F) : y ? new Date(N, t, 1, H, F) : b ? new Date(N, V, t, H, F) : C ? new Date(N, V, O, t) : new Date(N, V, O, H, 5 * t); const oe = m ? t : y ? f.text.monthsShort[t] : b ? ne.getDate() : v.time(ne, f, !0); i = e('<td/>').addClass(h.cell).appendTo(r), i.text(oe), i.data(D.date, ne); const re = b && ne.getMonth() !== (V + 12) % 12; const ie = re || !c.helper.isDateInRange(ne, d) || f.isDisabled(ne, d); const le = c.helper.dateEqual(ne, u, d); const de = c.helper.dateEqual(ne, s, d); i.toggleClass(h.adjacentCell, re), i.toggleClass(h.disabledCell, ie), i.toggleClass(h.activeCell, le && !re), C || M || i.toggleClass(h.todayCell, !re && de); const se = {
                    mode: d, adjacent: re, disabled: ie, active: le, today: de,
                  }; v.cell(i, ne, se), c.helper.dateEqual(ne, p, d) && c.set.focusDate(ne, !1, !1);
                }
              } if (f.today) { const ue = e('<tr/>').appendTo(ae); const pe = e('<td/>').attr('colspan', `${Y}`).addClass(h.today).appendTo(ue); pe.text(v.today(f)), pe.data(D.date, s); }c.update.focus(!1, Z);
            }
          },
        },
        update: { focus(t, a) { a = a || k; const n = c.get.mode(); const o = c.get.date(); const i = c.get.focusDate(); const l = c.get.startDate(); const d = c.get.endDate(); const s = (t ? i : null) || o || (r ? null : i); a.find('td').each(function () { const t = e(this); const a = t.data(D.date); if (a) { const o = t.hasClass(h.disabledCell); const u = t.hasClass(h.activeCell); const p = t.hasClass(h.adjacentCell); const f = c.helper.dateEqual(a, i, n); const g = !!s && (!!l && c.helper.isDateInRange(a, n, l, s) || !!d && c.helper.isDateInRange(a, n, s, d)); t.toggleClass(h.focusCell, f && (!r || O) && !p), t.toggleClass(h.rangeCell, g && !u && !o); } }); } },
        refresh() { c.create.calendar(); },
        bind: { events() { k.on(`mousedown${C}`, c.event.mousedown), k.on(`touchstart${C}`, c.event.mousedown), k.on(`mouseup${C}`, c.event.mouseup), k.on(`touchend${C}`, c.event.mouseup), k.on(`mouseover${C}`, c.event.mouseover), x.length ? (x.on(`input${C}`, c.event.inputChange), x.on(`focus${C}`, c.event.inputFocus), x.on(`blur${C}`, c.event.inputBlur), x.on(`click${C}`, c.event.inputClick), x.on(`keydown${C}`, c.event.keydown)) : k.on(`keydown${C}`, c.event.keydown); } },
        unbind: { events() { k.off(C), x.length && x.off(C); } },
        event: {
          mouseover(t) { const a = e(t.target); const n = a.data(D.date); const o = t.buttons === 1; n && c.set.focusDate(n, !1, !0, o); },
          mousedown(t) { x.length && t.preventDefault(), O = t.type.indexOf('touch') >= 0; const a = e(t.target); const n = a.data(D.date); n && c.set.focusDate(n, !1, !0, !0); },
          mouseup(t) { c.focus(), t.preventDefault(), t.stopPropagation(), O = !1; let a = e(t.target); const n = a.parent(); (n.data(D.date) || n.data(D.focusDate) || n.data(D.mode)) && (a = n); const o = a.data(D.date); const r = a.data(D.focusDate); const i = a.data(D.mode); if (o) { const l = a.hasClass(h.today); c.selectDate(o, l); } else r ? c.set.focusDate(r) : i && c.set.mode(i); },
          keydown(e) {
            if (e.keyCode !== 27 && e.keyCode !== 9 || c.popup('hide'), c.popup('is visible')) {
              if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
                var t = c.get.mode(); const a = t === 'day' ? 7 : t === 'hour' ? 4 : 3; let n = e.keyCode === 37 ? -1 : e.keyCode === 38 ? -a : e.keyCode == 39 ? 1 : a; n *= t === 'minute' ? 5 : 1; const o = c.get.focusDate() || c.get.date() || new Date(); const r = o.getFullYear() + (t === 'year' ? n : 0); const i = o.getMonth() + (t === 'month' ? n : 0); const l = o.getDate() + (t === 'day' ? n : 0); const d = o.getHours() + (t === 'hour' ? n : 0); const s = o.getMinutes() + (t === 'minute' ? n : 0); let
                  u = new Date(r, i, l, d, s); f.type === 'time' && (u = c.helper.mergeDateTime(o, u)), c.helper.isDateInRange(u, t) && c.set.focusDate(u);
              } else if (e.keyCode === 13) { var t = c.get.mode(); const p = c.get.focusDate(); p && !f.isDisabled(p, t) && c.selectDate(p), e.preventDefault(), e.stopPropagation(); }
            }e.keyCode !== 38 && e.keyCode !== 40 || (e.preventDefault(), c.popup('show'));
          },
          inputChange() { const e = x.val(); const t = y.date(e, f); c.set.date(t, !1); },
          inputFocus() { k.addClass(h.active); },
          inputBlur() { if (k.removeClass(h.active), f.formatInput) { const e = c.get.date(); const t = v.datetime(e, f); x.val(t); } },
          inputClick() { c.popup('show'); },
        },
        get: {
          date() { return w.data(D.date) || null; }, focusDate() { return w.data(D.focusDate) || null; }, startDate() { const e = c.get.calendarModule(f.startCalendar); return (e ? e.get.date() : w.data(D.startDate)) || null; }, endDate() { const e = c.get.calendarModule(f.endCalendar); return (e ? e.get.date() : w.data(D.endDate)) || null; }, monthOffset() { return w.data(D.monthOffset) || 0; }, mode() { const t = w.data(D.mode) || f.startMode; const a = c.get.validModes(); return e.inArray(t, a) >= 0 ? t : f.type === 'time' ? 'hour' : f.type === 'month' ? 'month' : f.type === 'year' ? 'year' : 'day'; }, validModes() { const e = []; return f.type !== 'time' && (f.disableYear && f.type !== 'year' || e.push('year'), (!f.disableMonth && f.type !== 'year' || f.type === 'month') && e.push('month'), f.type.indexOf('date') >= 0 && e.push('day')), f.type.indexOf('time') >= 0 && (e.push('hour'), f.disableMinute || e.push('minute')), e; }, isTouch() { try { return a.createEvent('TouchEvent'), !0; } catch (e) { return !1; } }, calendarModule(t) { return t ? (t instanceof e || (t = w.parent().children(t).first()), t.data(M)) : null; },
        },
        set: {
          date(e, t, a) { t = t !== !1, a = a !== !1, e = c.helper.sanitiseDate(e), e = c.helper.dateInRange(e); const o = c.get.mode(); const r = v.datetime(e, f); if (a && f.onChange.call(F, e, r, o) === !1) return !1; if (c.set.focusDate(e), f.isDisabled(e, o)) return !1; const i = c.get.endDate(); i && e && e > i && c.set.endDate(n), c.set.dataKeyValue(D.date, e), t && x.length && x.val(r); }, startDate(e, t) { e = c.helper.sanitiseDate(e); const a = c.get.calendarModule(f.startCalendar); a && a.set.date(e), c.set.dataKeyValue(D.startDate, e, t); }, endDate(e, t) { e = c.helper.sanitiseDate(e); const a = c.get.calendarModule(f.endCalendar); a && a.set.date(e), c.set.dataKeyValue(D.endDate, e, t); }, focusDate(e, t, a, n) { e = c.helper.sanitiseDate(e), e = c.helper.dateInRange(e); const o = c.get.mode() === 'day'; const r = c.get.focusDate(); if (o && e && r) { const i = e.getFullYear() - r.getFullYear(); const l = 12 * i + e.getMonth() - r.getMonth(); if (l) { const d = c.get.monthOffset() - l; c.set.monthOffset(d, !1); } } const s = c.set.dataKeyValue(D.focusDate, e, t); a = a !== !1 && s && t === !1 || I != n, I = n, a && c.update.focus(n); }, monthOffset(e, t) { const a = Math.max(f.multiMonth, 1); e = Math.max(1 - a, Math.min(0, e)), c.set.dataKeyValue(D.monthOffset, e, t); }, mode(e, t) { c.set.dataKeyValue(D.mode, e, t); }, dataKeyValue(e, t, a) { const n = w.data(e); const o = n === t || n <= t && n >= t; return t ? w.data(e, t) : w.removeData(e), a = a !== !1 && !o, a && c.create.calendar(), !o; },
        },
        selectDate(e, t) { const a = c.get.mode(); const n = t || a === 'minute' || f.disableMinute && a === 'hour' || f.type === 'date' && a === 'day' || f.type === 'month' && a === 'month' || f.type === 'year' && a === 'year'; if (n) { const o = c.set.date(e) === !1; if (!o && f.closable) { c.popup('hide'); const r = c.get.calendarModule(f.endCalendar); r && (r.popup('show'), r.focus()); } } else { const i = a === 'year' ? f.disableMonth ? 'day' : 'month' : a === 'month' ? 'day' : a === 'day' ? 'hour' : 'minute'; c.set.mode(i), a === 'hour' || a === 'day' && c.get.date() ? c.set.date(e) : c.set.focusDate(e); } },
        changeDate(e) { c.set.date(e); },
        clear() { c.set.date(n); },
        popup() { return T.popup.apply(T, arguments); },
        focus() { x.length ? x.focus() : k.focus(); },
        blur() { x.length ? x.blur() : k.blur(); },
        helper: {
          sanitiseDate(e) { return e ? (e instanceof Date || (e = y.date(`${e}`, f)), isNaN(e.getTime()) ? n : e) : n; }, dateDiff(e, t, a) { a = a || 'day'; const n = f.type === 'time'; const o = a === 'year'; const r = o || a === 'month'; const i = a === 'minute'; const l = i || a === 'hour'; return e = new Date(n ? 2e3 : e.getFullYear(), n ? 0 : o ? 0 : e.getMonth(), n ? 1 : r ? 1 : e.getDate(), l ? e.getHours() : 0, i ? 5 * Math.floor(e.getMinutes() / 5) : 0), t = new Date(n ? 2e3 : t.getFullYear(), n ? 0 : o ? 0 : t.getMonth(), n ? 1 : r ? 1 : t.getDate(), l ? t.getHours() : 0, i ? 5 * Math.floor(t.getMinutes() / 5) : 0), t.getTime() - e.getTime(); }, dateEqual(e, t, a) { return !!e && !!t && c.helper.dateDiff(e, t, a) === 0; }, isDateInRange(e, t, a, n) { if (!a && !n) { const o = c.get.startDate(); a = o && f.minDate ? new Date(Math.max(o, f.minDate)) : o || f.minDate, n = f.maxDate; } return a = a && new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), 5 * Math.ceil(a.getMinutes() / 5)), !(!e || a && c.helper.dateDiff(e, a, t) > 0 || n && c.helper.dateDiff(n, e, t) > 0); }, dateInRange(e, t, a) { if (!t && !a) { const n = c.get.startDate(); t = n && f.minDate ? new Date(Math.max(n, f.minDate)) : n || f.minDate, a = f.maxDate; }t = t && new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), 5 * Math.ceil(t.getMinutes() / 5)); const o = f.type === 'time'; return e ? t && c.helper.dateDiff(e, t, 'minute') > 0 ? o ? c.helper.mergeDateTime(e, t) : t : a && c.helper.dateDiff(a, e, 'minute') > 0 ? o ? c.helper.mergeDateTime(e, a) : a : e : e; }, mergeDateTime(e, t) { return e && t ? new Date(e.getFullYear(), e.getMonth(), e.getDate(), t.getHours(), t.getMinutes()) : t; },
        },
        setting(t, a) { if (c.debug('Changing setting', t, a), e.isPlainObject(t))e.extend(!0, f, t); else { if (a === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], a) : f[t] = a; } },
        internal(t, a) { return c.debug('Changing internal', t, a), a === n ? c[t] : void (e.isPlainObject(t) ? e.extend(!0, c, t) : c[t] = a); },
        debug() { !f.silent && f.debug && (f.performance ? c.performance.log(arguments) : (c.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), c.debug.apply(console, arguments))); },
        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? c.performance.log(arguments) : (c.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), c.verbose.apply(console, arguments))); },
        error() { f.silent || (c.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), c.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let a; let n; f.performance && (t = (new Date()).getTime(), n = l || t, a = t - n, l = t, d.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: F, 'Execution Time': a,
            })), clearTimeout(c.performance.timer), c.performance.timer = setTimeout(c.performance.display, 500);
          },
          display() { let t = `${f.name}:`; let a = 0; l = !1, clearTimeout(c.performance.timer), e.each(d, (e, t) => { a += t['Execution Time']; }), t += ` ${a}ms`, i && (t += ` '${i}'`), (console.group !== n || console.table !== n) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), d = []; },
        },
        invoke(t, a, r) { let i; let l; let d; let s = H; return a = a || p, r = F || r, typeof t === 'string' && s !== n && (t = t.split(/[\. ]/), i = t.length - 1, e.each(t, (a, o) => { const r = a != i ? o + t[a + 1].charAt(0).toUpperCase() + t[a + 1].slice(1) : t; if (e.isPlainObject(s[r]) && a != i)s = s[r]; else { if (s[r] !== n) return l = s[r], !1; if (!e.isPlainObject(s[o]) || a == i) return s[o] !== n ? (l = s[o], !1) : (c.error(b.method, t), !1); s = s[o]; } })), e.isFunction(l) ? d = l.apply(r, a) : l !== n && (d = l), e.isArray(o) ? o.push(d) : o !== n ? o = [o, d] : d !== n && (o = d), l; },
      }, u ? (H === n && c.initialize(), c.invoke(s)) : (H !== n && H.invoke('destroy'), c.initialize());
    }), o !== n ? o : this;
  }, e.fn.calendar.settings = {
    name: 'Calendar',
    namespace: 'calendar',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !1,
    type: 'datetime',
    firstDayOfWeek: 0,
    constantHeight: !0,
    today: !1,
    closable: !0,
    monthFirst: !0,
    touchReadonly: !0,
    inline: !1,
    on: null,
    initialDate: null,
    startMode: !1,
    minDate: null,
    maxDate: null,
    ampm: !0,
    disableYear: !1,
    disableMonth: !1,
    disableMinute: !1,
    formatInput: !0,
    startCalendar: null,
    endCalendar: null,
    multiMonth: 1,
    popupOptions: {
      position: 'bottom left', lastResort: 'bottom left', prefer: 'opposite', hideOnScroll: !1,
    },
    text: {
      days: ['S', 'M', 'T', 'W', 'T', 'F', 'S'], months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], today: 'Today', now: 'Now', am: 'AM', pm: 'PM',
    },
    formatter: {
      header(e, t, a) { return t === 'year' ? a.formatter.yearHeader(e, a) : t === 'month' ? a.formatter.monthHeader(e, a) : t === 'day' ? a.formatter.dayHeader(e, a) : t === 'hour' ? a.formatter.hourHeader(e, a) : a.formatter.minuteHeader(e, a); }, yearHeader(e, t) { const a = 10 * Math.ceil(e.getFullYear() / 10); return `${a - 9} - ${a + 2}`; }, monthHeader(e, t) { return e.getFullYear(); }, dayHeader(e, t) { const a = t.text.months[e.getMonth()]; const n = e.getFullYear(); return `${a} ${n}`; }, hourHeader(e, t) { return t.formatter.date(e, t); }, minuteHeader(e, t) { return t.formatter.date(e, t); }, dayColumnHeader(e, t) { return t.text.days[e]; }, datetime(e, t) { if (!e) return ''; const a = t.type === 'time' ? '' : t.formatter.date(e, t); const n = t.type.indexOf('time') < 0 ? '' : t.formatter.time(e, t, !1); const o = t.type === 'datetime' ? ' ' : ''; return a + o + n; }, date(e, t) { if (!e) return ''; const a = e.getDate(); const n = t.text.months[e.getMonth()]; const o = e.getFullYear(); return t.type === 'year' ? o : t.type === 'month' ? `${n} ${o}` : `${t.monthFirst ? `${n} ${a}` : `${a} ${n}`}, ${o}`; }, time(e, t, a) { if (!e) return ''; let n = e.getHours(); const o = e.getMinutes(); let r = ''; return t.ampm && (r = ` ${n < 12 ? t.text.am : t.text.pm}`, n = n === 0 ? 12 : n > 12 ? n - 12 : n), `${n}:${o < 10 ? '0' : ''}${o}${r}`; }, today(e) { return e.type === 'date' ? e.text.today : e.text.now; }, cell(e, t, a) {},
    },
    parser: { date(t, a) { if (!t) return null; if (t = (`${t}`).trim().toLowerCase(), t.length === 0) return null; let o; let r; let i; let l = -1; let d = -1; let s = -1; let u = -1; let p = -1; let c = n; const f = a.type === 'time'; const h = a.type.indexOf('time') < 0; const g = t.split(a.regExp.dateWords); const m = t.split(a.regExp.dateNumbers); if (!h) for (c = e.inArray(a.text.am.toLowerCase(), g) >= 0 || !(e.inArray(a.text.pm.toLowerCase(), g) >= 0) && n, o = 0; o < m.length; o++) { const v = m[o]; if (v.indexOf(':') >= 0) { if (d < 0 || l < 0) { const y = v.split(':'); for (i = 0; i < Math.min(2, y.length); i++)r = parseInt(y[i]), isNaN(r) && (r = 0), i === 0 ? d = r % 24 : l = r % 60; }m.splice(o, 1); } } if (!f) { for (o = 0; o < g.length; o++) { let D = g[o]; if (!(D.length <= 0)) { for (D = D.substring(0, Math.min(D.length, 3)), r = 0; r < a.text.months.length; r++) { let b = a.text.months[r]; if (b = b.substring(0, Math.min(D.length, Math.min(b.length, 3))).toLowerCase(), b === D) { u = r + 1; break; } } if (u >= 0) break; } } for (o = 0; o < m.length; o++) if (r = parseInt(m[o]), !isNaN(r) && r > 59) { p = r, m.splice(o, 1); break; } if (u < 0) for (o = 0; o < m.length; o++) if (i = o > 1 || a.monthFirst ? o : o === 1 ? 0 : 1, r = parseInt(m[i]), !isNaN(r) && r >= 1 && r <= 12) { u = r, m.splice(i, 1); break; } for (o = 0; o < m.length; o++) if (r = parseInt(m[o]), !isNaN(r) && r >= 1 && r <= 31) { s = r, m.splice(o, 1); break; } if (p < 0) for (o = m.length - 1; o >= 0; o--) if (r = parseInt(m[o]), !isNaN(r)) { r < 99 && (r += 2e3), p = r, m.splice(o, 1); break; } } if (!h) { if (d < 0) for (o = 0; o < m.length; o++) if (r = parseInt(m[o]), !isNaN(r) && r >= 0 && r <= 23) { d = r, m.splice(o, 1); break; } if (l < 0) for (o = 0; o < m.length; o++) if (r = parseInt(m[o]), !isNaN(r) && r >= 0 && r <= 59) { l = r, m.splice(o, 1); break; } } if (l < 0 && d < 0 && s < 0 && u < 0 && p < 0) return null; l < 0 && (l = 0), d < 0 && (d = 0), s < 0 && (s = 1), u < 0 && (u = 1), p < 0 && (p = (new Date()).getFullYear()), c !== n && (c ? d === 12 && (d = 0) : d < 12 && (d += 12)); let C = new Date(p, u - 1, s, d, l); return C.getMonth() === u - 1 && C.getFullYear() === p || (C = new Date(p, u, 0, d, l)), isNaN(C.getTime()) ? null : C; } },
    onChange(e, t, a) { return !0; },
    onShow() {},
    onVisible() {},
    onHide() {},
    onHidden() {},
    isDisabled(e, t) { return !1; },
    selector: { popup: '.ui.popup', input: 'input', activator: 'input' },
    regExp: { dateWords: /[^A-Za-z\u00C0-\u024F]+/g, dateNumbers: /[^\d:]+/g },
    error: { popup: 'UI Popup, a required component is not included in this page', method: 'The method you called is not defined.' },
    className: {
      calendar: 'calendar', active: 'active', popup: 'ui popup', grid: 'ui equal width grid', column: 'column', table: 'ui celled center aligned unstackable table', prev: 'prev link', next: 'next link', prevIcon: 'chevron left icon', nextIcon: 'chevron right icon', link: 'link', cell: 'link', disabledCell: 'disabled', adjacentCell: 'adjacent', activeCell: 'active', rangeCell: 'range', focusCell: 'focus', todayCell: 'today', today: 'today link',
    },
    metadata: {
      date: 'date', focusDate: 'focusDate', startDate: 'startDate', endDate: 'endDate', mode: 'mode', monthOffset: 'monthOffset',
    },
  };
}(jQuery, window, document));
