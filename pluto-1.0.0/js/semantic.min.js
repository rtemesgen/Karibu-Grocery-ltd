/*
 * # Semantic UI - 2.1.4
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, t, n, i) {
  e.site = e.fn.site = function (o) {
    let a; let r; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); const f = e.isPlainObject(o) ? e.extend(!0, {}, e.site.settings, o) : e.extend({}, e.site.settings); const m = f.namespace; const g = f.error; const p = `module-${m}`; const h = e(n); const v = h; const b = this; let y = v.data(p); return a = {
      initialize() { a.instantiate(); },
      instantiate() { a.verbose('Storing instance of site', a), y = a, v.data(p, a); },
      normalize() { a.fix.console(), a.fix.requestAnimationFrame(); },
      fix: { console() { a.debug('Normalizing window.console'), (console === i || console.log === i) && (a.verbose('Console not available, normalizing events'), a.disable.console()), (typeof console.group === 'undefined' || typeof console.groupEnd === 'undefined' || typeof console.groupCollapsed === 'undefined') && (a.verbose('Console group not available, normalizing events'), t.console.group = function () {}, t.console.groupEnd = function () {}, t.console.groupCollapsed = function () {}), typeof console.markTimeline === 'undefined' && (a.verbose('Mark timeline not available, normalizing events'), t.console.markTimeline = function () {}); }, consoleClear() { a.debug('Disabling programmatic console clearing'), t.console.clear = function () {}; }, requestAnimationFrame() { a.debug('Normalizing requestAnimationFrame'), t.requestAnimationFrame === i && (a.debug('RequestAnimationFrame not available, normalizing event'), t.requestAnimationFrame = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }); } },
      moduleExists(t) { return e.fn[t] !== i && e.fn[t].settings !== i; },
      enabled: { modules(t) { const n = []; return t = t || f.modules, e.each(t, (e, t) => { a.moduleExists(t) && n.push(t); }), n; } },
      disabled: { modules(t) { const n = []; return t = t || f.modules, e.each(t, (e, t) => { a.moduleExists(t) || n.push(t); }), n; } },
      change: { setting(t, n, o, r) { o = typeof o === 'string' ? o === 'all' ? f.modules : [o] : o || f.modules, r = r !== i ? r : !0, e.each(o, (i, o) => { let s; const c = a.moduleExists(o) ? e.fn[o].settings.namespace || !1 : !0; a.moduleExists(o) && (a.verbose('Changing default setting', t, n, o), e.fn[o].settings[t] = n, r && c && (s = e(`:data(module-${c})`), s.length > 0 && (a.verbose('Modifying existing settings', s), s[o]('setting', t, n)))); }); }, settings(t, n, o) { n = typeof n === 'string' ? [n] : n || f.modules, o = o !== i ? o : !0, e.each(n, (n, i) => { let r; a.moduleExists(i) && (a.verbose('Changing default setting', t, i), e.extend(!0, e.fn[i].settings, t), o && m && (r = e(`:data(module-${m})`), r.length > 0 && (a.verbose('Modifying existing settings', r), r[i]('setting', t)))); }); } },
      enable: { console() { a.console(!0); }, debug(e, t) { e = e || f.modules, a.debug('Enabling debug for modules', e), a.change.setting('debug', !0, e, t); }, verbose(e, t) { e = e || f.modules, a.debug('Enabling verbose debug for modules', e), a.change.setting('verbose', !0, e, t); } },
      disable: { console() { a.console(!1); }, debug(e, t) { e = e || f.modules, a.debug('Disabling debug for modules', e), a.change.setting('debug', !1, e, t); }, verbose(e, t) { e = e || f.modules, a.debug('Disabling verbose debug for modules', e), a.change.setting('verbose', !1, e, t); } },
      console(e) {
        if (e) { if (y.cache.console === i) return void a.error(g.console); a.debug('Restoring console function'), t.console = y.cache.console; } else {
          a.debug('Disabling console function'), y.cache.console = t.console, t.console = {
            clear() {}, error() {}, group() {}, groupCollapsed() {}, groupEnd() {}, info() {}, log() {}, markTimeline() {}, warn() {},
          };
        }
      },
      destroy() { a.verbose('Destroying previous site for', v), v.removeData(p); },
      cache: {},
      setting(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
      internal(t, n) { if (e.isPlainObject(t))e.extend(!0, a, t); else { if (n === i) return a[t]; a[t] = n; } },
      debug() { f.debug && (f.performance ? a.performance.log(arguments) : (a.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), a.debug.apply(console, arguments))); },
      verbose() { f.verbose && f.debug && (f.performance ? a.performance.log(arguments) : (a.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), a.verbose.apply(console, arguments))); },
      error() { a.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), a.error.apply(console, arguments); },
      performance: {
        log(e) {
          let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
            Element: b, Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n,
          })), clearTimeout(a.performance.timer), a.performance.timer = setTimeout(a.performance.display, 500);
        },
        display() { let t = `${f.name}:`; let n = 0; s = !1, clearTimeout(a.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
      },
      invoke(t, n, o) { let s; let c; let l; let u = y; return n = n || d, o = b || o, typeof t === 'string' && u !== i && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, (n, o) => { const r = n != s ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(u[r]) && n != s)u = u[r]; else { if (u[r] !== i) return c = u[r], !1; if (!e.isPlainObject(u[o]) || n == s) return u[o] !== i ? (c = u[o], !1) : (a.error(g.method, t), !1); u = u[o]; } })), e.isFunction(c) ? l = c.apply(o, n) : c !== i && (l = c), e.isArray(r) ? r.push(l) : r !== i ? r = [r, l] : l !== i && (r = l), c; },
    }, u ? (y === i && a.initialize(), a.invoke(l)) : (y !== i && a.destroy(), a.initialize()), r !== i ? r : this;
  }, e.site.settings = {
    name: 'Site',
    namespace: 'site',
    error: { console: 'Console cannot be restored, most likely it was overwritten outside of module', method: 'The method you called is not defined.' },
    debug: !1,
    verbose: !1,
    performance: !0,
    modules: ['accordion', 'api', 'calendar', 'checkbox', 'dimmer', 'dropdown', 'embed', 'form', 'modal', 'nag', 'popup', 'rating', 'shape', 'sidebar', 'state', 'sticky', 'tab', 'transition', 'visit', 'visibility'],
    siteNamespace: 'site',
    namespaceStub: {
      cache: {}, config: {}, sections: {}, section: {}, utilities: {},
    },
  }, e.extend(e.expr[':'], { data: e.expr.createPseudo ? e.expr.createPseudo((t) => function (n) { return !!e.data(n, t); }) : function (t, n, i) { return !!e.data(t, i[3]); } });
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.form = function (t) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = arguments[1]; const d = typeof l === 'string'; const f = [].slice.call(arguments, 1); return a.each(function () {
      let m; let g; let p; let h; let v; let b; let y; let x; let C; let w; let k; let T; let S; let A; let D; let R; let E; let P; const F = e(this); const O = this; let q = []; let j = !1; P = {
        initialize() { P.get.settings(), d ? (E === i && P.instantiate(), P.invoke(l)) : (P.verbose('Initializing form validation', F, x), P.bindEvents(), P.set.defaults(), P.instantiate()); },
        instantiate() { P.verbose('Storing instance of module', P), E = P, F.data(D, P); },
        destroy() { P.verbose('Destroying previous module', E), P.removeEvents(), F.removeData(D); },
        refresh() { P.verbose('Refreshing selector cache'), m = F.find(k.field), g = F.find(k.group), p = F.find(k.message), h = F.find(k.prompt), v = F.find(k.submit), b = F.find(k.clear), y = F.find(k.reset); },
        submit() { P.verbose('Submitting form', F), F.submit(); },
        attachEvents(t, n) { n = n || 'submit', e(t).on(`click${R}`, (e) => { P[n](), e.preventDefault(); }); },
        bindEvents() {
          P.verbose('Attaching form events'), F.on(`submit${R}`, P.validate.form).on(`blur${R}`, k.field, P.event.field.blur).on(`click${R}`, k.submit, P.submit).on(`click${R}`, k.reset, P.reset)
            .on(`click${R}`, k.clear, P.clear), x.keyboardShortcuts && F.on(`keydown${R}`, k.field, P.event.field.keydown), m.each(function () { const t = e(this); const n = t.prop('type'); const i = P.get.changeEvent(n, t); e(this).on(i + R, P.event.field.change); });
        },
        clear() { m.each(function () { const t = e(this); const n = t.parent(); const i = t.closest(g); const o = i.find(k.prompt); const a = t.data(w.defaultValue) || ''; const r = n.is(k.uiCheckbox); const s = n.is(k.uiDropdown); const c = i.hasClass(T.error); c && (P.verbose('Resetting error on field', i), i.removeClass(T.error), o.remove()), s ? (P.verbose('Resetting dropdown value', n, a), n.dropdown('clear')) : r ? t.prop('checked', !1) : (P.verbose('Resetting field value', t, a), t.val('')); }); },
        reset() { m.each(function () { const t = e(this); const n = t.parent(); const o = t.closest(g); const a = o.find(k.prompt); const r = t.data(w.defaultValue); const s = n.is(k.uiCheckbox); const c = n.is(k.uiDropdown); const l = o.hasClass(T.error); r !== i && (l && (P.verbose('Resetting error on field', o), o.removeClass(T.error), a.remove()), c ? (P.verbose('Resetting dropdown value', n, r), n.dropdown('restore defaults')) : s ? (P.verbose('Resetting checkbox value', n, r), t.prop('checked', r)) : (P.verbose('Resetting field value', t, r), t.val(r))); }); },
        is: { bracketedRule(e) { return e.type && e.type.match(x.regExp.bracket); }, valid() { let t = !0; return P.verbose('Checking if form is valid'), e.each(C, (e, n) => { P.validate.field(n, e) || (t = !1); }), t; } },
        removeEvents() { F.off(R), m.off(R), v.off(R), m.off(R); },
        event: {
          field: {
            keydown(t) { const n = e(this); const i = t.which; const o = { enter: 13, escape: 27 }; i == o.escape && (P.verbose('Escape key pressed blurring field'), n.blur()), !t.ctrlKey && i == o.enter && n.is(k.input) && n.not(k.checkbox).length > 0 && (j || (n.one(`keyup${R}`, P.event.field.keyup), P.submit(), P.debug('Enter pressed on input submitting form')), j = !0); }, keyup() { j = !1; }, blur(t) { const n = e(this); const i = n.closest(g); const o = P.get.validation(n); i.hasClass(T.error) ? (P.debug('Revalidating field', n, o), P.validate.form.call(P, t, !0)) : (x.on == 'blur' || x.on == 'change') && P.validate.field(o); }, change(t) { const n = e(this); const i = n.closest(g); (x.on == 'change' || i.hasClass(T.error) && x.revalidate) && (clearTimeout(P.timer), P.timer = setTimeout(() => { P.debug('Revalidating field', n, P.get.validation(n)), P.validate.form.call(P, t, !0); }, x.delay)); },
          },
        },
        get: {
          ancillaryValue(e) { return e.type && P.is.bracketedRule(e) ? `${e.type.match(x.regExp.bracket)[1]}` : !1; }, ruleName(e) { return P.is.bracketedRule(e) ? e.type.replace(e.type.match(x.regExp.bracket)[0], '') : e.type; }, changeEvent(e, t) { return e == 'checkbox' || e == 'radio' || e == 'hidden' || t.is('select') ? 'change' : P.get.inputEvent(); }, inputEvent() { return n.createElement('input').oninput !== i ? 'input' : n.createElement('input').onpropertychange !== i ? 'propertychange' : 'keyup'; }, prompt(e, t) { let n; let i; let o; const a = P.get.ruleName(e); const r = P.get.ancillaryValue(e); let s = e.prompt || x.prompt[a] || x.text.unspecifiedRule; const c = s.search('{value}') !== -1; const l = s.search('{name}') !== -1; return (l || c) && (i = P.get.field(t.identifier)), c && (s = s.replace('{value}', i.val())), l && (n = i.closest(k.group).find('label').eq(0), o = n.size() == 1 ? n.text() : i.prop('placeholder') || x.text.unspecifiedField, s = s.replace('{name}', o)), s = s.replace('{identifier}', t.identifier), s = s.replace('{ruleValue}', r), e.prompt || P.verbose('Using default validation prompt for type', s, a), s; }, settings() { if (e.isPlainObject(t)) { let n; const o = Object.keys(t); const a = o.length > 0 ? t[o[0]].identifier !== i && t[o[0]].rules !== i : !1; a ? (x = e.extend(!0, {}, e.fn.form.settings, u), C = e.extend({}, e.fn.form.settings.defaults, t), P.error(x.error.oldSyntax, O), P.verbose('Extending settings from legacy parameters', C, x)) : (t.fields && (n = Object.keys(t.fields), (typeof t.fields[n[0]] === 'string' || e.isArray(t.fields[n[0]])) && e.each(t.fields, (n, i) => { typeof i === 'string' && (i = [i]), t.fields[n] = { rules: [] }, e.each(i, (e, i) => { t.fields[n].rules.push({ type: i }); }); })), x = e.extend(!0, {}, e.fn.form.settings, t), C = e.extend({}, e.fn.form.settings.defaults, x.fields), P.verbose('Extending settings', C, x)); } else x = e.fn.form.settings, C = e.fn.form.settings.defaults, P.verbose('Using default form validation', C, x); A = x.namespace, w = x.metadata, k = x.selector, T = x.className, S = x.error, D = `module-${A}`, R = `.${A}`, E = F.data(D), P.refresh(); }, field(t) { return P.verbose('Finding field with identifier', t), m.filter(`#${t}`).length > 0 ? m.filter(`#${t}`) : m.filter(`[name="${t}"]`).length > 0 ? m.filter(`[name="${t}"]`) : m.filter(`[name="${t}[]"]`).length > 0 ? m.filter(`[name="${t}[]"]`) : m.filter(`[data-${w.validate}="${t}"]`).length > 0 ? m.filter(`[data-${w.validate}="${t}"]`) : e('<input/>'); }, fields(t) { let n = e(); return e.each(t, (e, t) => { n = n.add(P.get.field(t)); }), n; }, validation(t) { let n; let i; return C ? (e.each(C, (e, o) => { i = o.identifier || e, P.get.field(i)[0] == t[0] && (o.identifier = i, n = o); }), n || !1) : !1; }, value(e) { let t; const n = []; return n.push(e), t = P.get.values.call(O, n), t[e]; }, values(t) { const n = e.isArray(t) ? P.get.fields(t) : m; const i = {}; return n.each((t, n) => { const o = e(n); let a = (o.prop('type'), o.prop('name')); const r = o.val(); const s = o.is(k.checkbox); const c = o.is(k.radio); const l = a.indexOf('[]') !== -1; const u = s ? o.is(':checked') : !1; a && (l ? (a = a.replace('[]', ''), i[a] || (i[a] = []), s ? u ? i[a].push(r || !0) : i[a].push(!1) : i[a].push(r)) : c ? u && (i[a] = r) : s ? u ? i[a] = r || !0 : i[a] = !1 : i[a] = r); }), i; },
        },
        has: { field(e) { return P.verbose('Checking for existence of a field with identifier', e), typeof e !== 'string' && P.error(S.identifier, e), m.filter(`#${e}`).length > 0 ? !0 : m.filter(`[name="${e}"]`).length > 0 ? !0 : m.filter(`[data-${w.validate}="${e}"]`).length > 0 ? !0 : !1; } },
        add: { prompt(t, n) { const o = P.get.field(t); const a = o.closest(g); let r = a.children(k.prompt); const s = r.length !== 0; n = typeof n === 'string' ? [n] : n, P.verbose('Adding field error state', t), a.addClass(T.error), x.inline && (s || (r = x.templates.prompt(n), r.appendTo(a)), r.html(n[0]), s ? P.verbose('Inline errors are disabled, no inline error added', t) : x.transition && e.fn.transition !== i && F.transition('is supported') ? (P.verbose('Displaying error with css transition', x.transition), r.transition(`${x.transition} in`, x.duration)) : (P.verbose('Displaying error with fallback javascript animation'), r.fadeIn(x.duration))); }, errors(e) { P.debug('Adding form error messages', e), P.set.error(), p.html(x.templates.error(e)); } },
        remove: { prompt(t) { const n = P.get.field(t); const o = n.closest(g); const a = o.children(k.prompt); o.removeClass(T.error), x.inline && a.is(':visible') && (P.verbose('Removing prompt for field', t), x.transition && e.fn.transition !== i && F.transition('is supported') ? a.transition(`${x.transition} out`, x.duration, () => { a.remove(); }) : a.fadeOut(x.duration, () => { a.remove(); })); } },
        set: {
          success() { F.removeClass(T.error).addClass(T.success); }, defaults() { m.each(function () { const t = e(this); const n = t.filter(k.checkbox).length > 0; const i = n ? t.is(':checked') : t.val(); t.data(w.defaultValue, i); }); }, error() { F.removeClass(T.success).addClass(T.error); }, value(e, t) { const n = {}; return n[e] = t, P.set.values.call(O, n); }, values(t) { e.isEmptyObject(t) || e.each(t, (t, n) => { let i; const o = P.get.field(t); let a = o.parent(); const r = e.isArray(n); const s = a.is(k.uiCheckbox); const c = a.is(k.uiDropdown); const l = o.is(k.radio) && s; const u = o.length > 0; u && (r && s ? (P.verbose('Selecting multiple', n, o), a.checkbox('uncheck'), e.each(n, (e, t) => { i = o.filter(`[value="${t}"]`), a = i.parent(), i.length > 0 && a.checkbox('check'); })) : l ? (P.verbose('Selecting radio value', n, o), o.filter(`[value="${n}"]`).parent(k.uiCheckbox).checkbox('check')) : s ? (P.verbose('Setting checkbox value', n, a), n === !0 ? a.checkbox('check') : a.checkbox('uncheck')) : c ? (P.verbose('Setting dropdown value', n, a), a.dropdown('set selected', n)) : (P.verbose('Setting field value', n, o), o.val(n))); }); },
        },
        validate: { form(e, t) { const n = P.get.values(); if (j) return !1; if (q = [], P.is.valid()) { if (P.debug('Form has no validation errors, submitting'), P.set.success(), t !== !0) return x.onSuccess.call(O, e, n); } else if (P.debug('Form has errors'), P.set.error(), x.inline || P.add.errors(q), F.data('moduleApi') !== i && e.stopImmediatePropagation(), t !== !0) return x.onFailure.call(O, q, n); }, field(t, n) { const o = t.identifier || n; const a = P.get.field(o); let r = !0; const s = []; return t.identifier || (P.debug('Using field name as identifier', o), t.identifier = o), a.prop('disabled') ? (P.debug('Field is disabled. Skipping', o), r = !0) : t.optional && e.trim(a.val()) === '' ? (P.debug('Field is optional and empty. Skipping', o), r = !0) : t.rules !== i && e.each(t.rules, (e, n) => { P.has.field(o) && !P.validate.rule(t, n) && (P.debug('Field is invalid', o, n.type), s.push(P.get.prompt(n, t)), r = !1); }), r ? (P.remove.prompt(o, s), x.onValid.call(a), !0) : (q = q.concat(s), P.add.prompt(o, s), x.onInvalid.call(a, s), !1); }, rule(t, n) { const o = P.get.field(t.identifier); let a = (n.type, o.val()); const r = P.get.ancillaryValue(n); const s = P.get.ruleName(n); const c = x.rules[s]; return e.isFunction(c) ? (a = a === i || a === '' || a === null ? '' : e.trim(`${a}`), c.call(o, a, r)) : void P.error(S.noRule, s); } },
        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (n === i) return x[t]; x[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, P, t); else { if (n === i) return P[t]; P[t] = n; } },
        debug() { x.debug && (x.performance ? P.performance.log(arguments) : (P.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), P.debug.apply(console, arguments))); },
        verbose() { x.verbose && x.debug && (x.performance ? P.performance.log(arguments) : (P.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), P.verbose.apply(console, arguments))); },
        error() { P.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), P.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; x.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: O, 'Execution Time': n,
            })), clearTimeout(P.performance.timer), P.performance.timer = setTimeout(P.performance.display, 500);
          },
          display() { let t = `${x.name}:`; let n = 0; s = !1, clearTimeout(P.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), a.length > 1 && (t += ` (${a.length})`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = E; return n = n || f, a = O || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, P.initialize();
    }), o !== i ? o : this;
  }, e.fn.form.settings = {
    name: 'Form',
    namespace: 'form',
    debug: !1,
    verbose: !1,
    performance: !0,
    fields: !1,
    keyboardShortcuts: !0,
    on: 'submit',
    inline: !1,
    delay: 200,
    revalidate: !0,
    transition: 'scale',
    duration: 200,
    onValid() {},
    onInvalid() {},
    onSuccess() { return !0; },
    onFailure() { return !1; },
    metadata: { defaultValue: 'default', validate: 'validate' },
    regExp: {
      bracket: /\[(.*)\]/i, decimal: /^\-?\d*(\.\d+)?$/, email: "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i,
    },
    text: { unspecifiedRule: 'Please enter a valid value', unspecifiedField: 'This field' },
    prompt: {
      empty: '{name} must have a value', checked: '{name} must be checked', email: '{name} must be a valid e-mail', url: '{name} must be a valid url', regExp: '{name} is not formatted correctly', integer: '{name} must be an integer', decimal: '{name} must be a decimal number', number: '{name} must be set to a number', is: '{name} must be "{ruleValue}"', isExactly: '{name} must be exactly "{ruleValue}"', not: '{name} cannot be set to "{ruleValue}"', notExactly: '{name} cannot be set to exactly "{ruleValue}"', contain: '{name} cannot contain "{ruleValue}"', containExactly: '{name} cannot contain exactly "{ruleValue}"', doesntContain: '{name} must contain  "{ruleValue}"', doesntContainExactly: '{name} must contain exactly "{ruleValue}"', minLength: '{name} must be at least {ruleValue} characters', length: '{name} must be at least {ruleValue} characters', exactLength: '{name} must be exactly {ruleValue} characters', maxLength: '{name} cannot be longer than {ruleValue} characters', match: '{name} must match {ruleValue} field', different: '{name} must have a different value than {ruleValue} field', creditCard: '{name} must be a valid credit card number', minCount: '{name} must have at least {ruleValue} choices', exactCount: '{name} must have exactly {ruleValue} choices', maxCount: '{name} must have {ruleValue} or less choices',
    },
    selector: {
      checkbox: 'input[type="checkbox"], input[type="radio"]', clear: '.clear', field: 'input, textarea, select', group: '.field', input: 'input', message: '.error.message', prompt: '.prompt.label', radio: 'input[type="radio"]', reset: '.reset:not([type="reset"])', submit: '.submit:not([type="submit"])', uiCheckbox: '.ui.checkbox', uiDropdown: '.ui.dropdown',
    },
    className: {
      error: 'error', label: 'ui prompt label', pressed: 'down', success: 'success',
    },
    error: {
      identifier: 'You must specify a string identifier for each field', method: 'The method you called is not defined.', noRule: 'There is no rule matching the one you specified', oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.',
    },
    templates: { error(t) { let n = '<ul class="list">'; return e.each(t, (e, t) => { n += `<li>${t}</li>`; }), n += '</ul>', e(n); }, prompt(t) { return e('<div/>').addClass('ui basic red pointing prompt label').html(t[0]); } },
    rules: {
      empty(t) { return !(t === i || t === '' || e.isArray(t) && t.length === 0); },
      checked() { return e(this).filter(':checked').length > 0; },
      email(t) { const n = new RegExp(e.fn.form.settings.regExp.email, 'i'); return n.test(t); },
      url(t) { return e.fn.form.settings.regExp.url.test(t); },
      regExp(t, n) { let i; const o = n.match(e.fn.form.settings.regExp.flags); return o && (n = o.length >= 2 ? o[1] : n, i = o.length >= 3 ? o[2] : ''), t.match(new RegExp(n, i)); },
      integer(t, n) { let o; let a; let r; const s = e.fn.form.settings.regExp.integer; return n === i || n === '' || n === '..' || (n.indexOf('..') == -1 ? s.test(n) && (o = a = n - 0) : (r = n.split('..', 2), s.test(r[0]) && (o = r[0] - 0), s.test(r[1]) && (a = r[1] - 0))), s.test(t) && (o === i || t >= o) && (a === i || a >= t); },
      decimal(t) { return e.fn.form.settings.regExp.decimal.test(t); },
      number(t) { return e.fn.form.settings.regExp.number.test(t); },
      is(e, t) { return t = typeof t === 'string' ? t.toLowerCase() : t, e = typeof e === 'string' ? e.toLowerCase() : e, e == t; },
      isExactly(e, t) { return e == t; },
      not(e, t) { return e = typeof e === 'string' ? e.toLowerCase() : e, t = typeof t === 'string' ? t.toLowerCase() : t, e != t; },
      notExactly(e, t) { return e != t; },
      contains(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) !== -1; },
      containsExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) !== -1; },
      doesntContain(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) === -1; },
      doesntContainExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) === -1; },
      minLength(e, t) { return e !== i ? e.length >= t : !1; },
      length(e, t) { return e !== i ? e.length >= t : !1; },
      exactLength(e, t) { return e !== i ? e.length == t : !1; },
      maxLength(e, t) { return e !== i ? e.length <= t : !1; },
      match(t, n) { let o; e(this); return e(`[data-validate="${n}"]`).length > 0 ? o = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? o = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? o = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (o = e(`[name="${n}[]"]`)), o !== i ? t.toString() == o.toString() : !1; },
      different(t, n) { let o; e(this); return e(`[data-validate="${n}"]`).length > 0 ? o = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? o = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? o = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (o = e(`[name="${n}[]"]`)), o !== i ? t.toString() !== o.toString() : !1; },
      creditCard(t, n) {
        let i; let o; const a = {
          visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] },
        }; let r = {}; let s = !1; const c = typeof n === 'string' ? n.split(',') : !1; if (typeof t === 'string' && t.length !== 0) { if (c && (e.each(c, (n, i) => { o = a[i], o && (r = { length: e.inArray(t.length, o.length) !== -1, pattern: t.search(o.pattern) !== -1 }, r.length && r.pattern && (s = !0)); }), !s)) return !1; if (i = { number: e.inArray(t.length, a.unionPay.length) !== -1, pattern: t.search(a.unionPay.pattern) !== -1 }, i.number && i.pattern) return !0; for (var l = t.length, u = 0, d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], f = 0; l--;)f += d[u][parseInt(t.charAt(l), 10)], u ^= 1; return f % 10 === 0 && f > 0; }
      },
      minCount(e, t) { return t == 0 ? !0 : t == 1 ? e !== '' : e.split(',').length >= t; },
      exactCount(e, t) { return t == 0 ? e === '' : t == 1 ? e !== '' && e.search(',') === -1 : e.split(',').length == t; },
      maxCount(e, t) { return t == 0 ? !1 : t == 1 ? e.search(',') === -1 : e.split(',').length <= t; },
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.accordion = function (n) {
    let o; const a = e(this); let r = (new Date()).getTime(); let s = []; const c = arguments[0]; const l = typeof c === 'string'; const u = [].slice.call(arguments, 1); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return a.each(function () {
      let d; let f; const m = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.accordion.settings, n) : e.extend({}, e.fn.accordion.settings); const g = m.className; const p = m.namespace; const h = m.selector; const v = m.error; const b = `.${p}`; const y = `module-${p}`; const x = a.selector || ''; const C = e(this); let w = C.find(h.title); let k = C.find(h.content); const T = this; let S = C.data(y); f = {
        initialize() { f.debug('Initializing', C), f.bind.events(), m.observeChanges && f.observeChanges(), f.instantiate(); },
        instantiate() { S = f, C.data(y, f); },
        destroy() { f.debug('Destroying previous instance', C), C.off(b).removeData(y); },
        refresh() { w = C.find(h.title), k = C.find(h.content); },
        observeChanges() { 'MutationObserver' in t && (d = new MutationObserver((e) => { f.debug('DOM tree modified, updating selector cache'), f.refresh(); }), d.observe(T, { childList: !0, subtree: !0 }), f.debug('Setting up mutation observer', d)); },
        bind: { events() { f.debug('Binding delegated events'), C.on(m.on + b, h.trigger, f.event.click); } },
        event: { click() { f.toggle.call(this); } },
        toggle(t) { const n = t !== i ? typeof t === 'number' ? w.eq(t) : e(t).closest(h.title) : e(this).closest(h.title); const o = n.next(k); const a = o.hasClass(g.animating); const r = o.hasClass(g.active); const s = r && !a; const c = !r && a; f.debug('Toggling visibility of content', n), s || c ? m.collapsible ? f.close.call(n) : f.debug('Cannot close accordion content collapsing is disabled') : f.open.call(n); },
        open(t) {
          const n = t !== i ? typeof t === 'number' ? w.eq(t) : e(t).closest(h.title) : e(this).closest(h.title); const o = n.next(k); const a = o.hasClass(g.animating); const r = o.hasClass(g.active); const s = r || a; return s ? void f.debug('Accordion already open, skipping', o) : (f.debug('Opening accordion content', n), m.onOpening.call(o), m.exclusive && f.closeOthers.call(n), n.addClass(g.active), o.stop(!0, !0).addClass(g.animating), m.animateChildren && (e.fn.transition !== i && C.transition('is supported') ? o.children().transition({
            animation: 'fade in', queue: !1, useFailSafe: !0, debug: m.debug, verbose: m.verbose, duration: m.duration,
          }) : o.children().stop(!0, !0).animate({ opacity: 1 }, m.duration, f.resetOpacity)), void o.slideDown(m.duration, m.easing, function () { o.removeClass(g.animating).addClass(g.active), f.reset.display.call(this), m.onOpen.call(this), m.onChange.call(this); }));
        },
        close(t) {
          const n = t !== i ? typeof t === 'number' ? w.eq(t) : e(t).closest(h.title) : e(this).closest(h.title); const o = n.next(k); const a = o.hasClass(g.animating); const r = o.hasClass(g.active); const s = !r && a; const c = r && a; !r && !s || c || (f.debug('Closing accordion content', o), m.onClosing.call(o), n.removeClass(g.active), o.stop(!0, !0).addClass(g.animating), m.animateChildren && (e.fn.transition !== i && C.transition('is supported') ? o.children().transition({
            animation: 'fade out', queue: !1, useFailSafe: !0, debug: m.debug, verbose: m.verbose, duration: m.duration,
          }) : o.children().stop(!0, !0).animate({ opacity: 0 }, m.duration, f.resetOpacity)), o.slideUp(m.duration, m.easing, function () { o.removeClass(g.animating).removeClass(g.active), f.reset.display.call(this), m.onClose.call(this), m.onChange.call(this); }));
        },
        closeOthers(t) {
          let n; let o; let a; const r = t !== i ? w.eq(t) : e(this).closest(h.title); const s = r.parents(h.content).prev(h.title); const c = r.closest(h.accordion); const l = `${h.title}.${g.active}:visible`; const u = `${h.content}.${g.active}:visible`; m.closeNested ? (n = c.find(l).not(s), a = n.next(k)) : (n = c.find(l).not(s), o = c.find(u).find(l).not(s), n = n.not(o), a = n.next(k)), n.length > 0 && (f.debug('Exclusive enabled, closing other content', n), n.removeClass(g.active), a.removeClass(g.animating).stop(!0, !0), m.animateChildren && (e.fn.transition !== i && C.transition('is supported') ? a.children().transition({
            animation: 'fade out', useFailSafe: !0, debug: m.debug, verbose: m.verbose, duration: m.duration,
          }) : a.children().stop(!0, !0).animate({ opacity: 0 }, m.duration, f.resetOpacity)), a.slideUp(m.duration, m.easing, function () { e(this).removeClass(g.active), f.reset.display.call(this); }));
        },
        reset: { display() { f.verbose('Removing inline display from element', this), e(this).css('display', ''), e(this).attr('style') === '' && e(this).attr('style', '').removeAttr('style'); }, opacity() { f.verbose('Removing inline opacity from element', this), e(this).css('opacity', ''), e(this).attr('style') === '' && e(this).attr('style', '').removeAttr('style'); } },
        setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { return f.debug('Changing internal', t, n), n === i ? f[t] : void (e.isPlainObject(t) ? e.extend(!0, f, t) : f[t] = n); },
        debug() { m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
        error() { f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: T, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; r = !1, clearTimeout(f.performance.timer), e.each(s, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, x && (t += ` '${x}'`), (console.group !== i || console.table !== i) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = S; return n = n || u, a = T || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (f.error(v.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, l ? (S === i && f.initialize(), f.invoke(c)) : (S !== i && S.invoke('destroy'), f.initialize());
    }), o !== i ? o : this;
  }, e.fn.accordion.settings = {
    name: 'Accordion',
    namespace: 'accordion',
    debug: !1,
    verbose: !1,
    performance: !0,
    on: 'click',
    observeChanges: !0,
    exclusive: !0,
    collapsible: !0,
    closeNested: !1,
    animateChildren: !0,
    duration: 350,
    easing: 'easeOutQuad',
    onOpening() {},
    onOpen() {},
    onClosing() {},
    onClose() {},
    onChange() {},
    error: { method: 'The method you called is not defined' },
    className: { active: 'active', animating: 'animating' },
    selector: {
      accordion: '.accordion', title: '.title', trigger: '.title', content: '.content',
    },
  }, e.extend(e.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function (e, t, n, i) {
  e.fn.calendar = function (t) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; let f; const m = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.calendar.settings, t) : e.extend({}, e.fn.calendar.settings); const g = m.className; const p = m.namespace; const h = m.selector; const v = m.formatter; const b = m.parser; const y = m.metadata; const x = m.error; const C = `.${p}`; const w = `module-${p}`; const k = e(this); const T = k.find(h.input); let S = k.find(h.popup); let A = k.find(h.activator); const D = this; let R = k.data(w); let E = !1; let P = !1;
      f = {
        initialize() { f.debug('Initializing calendar for', D), a = f.get.isTouch(), f.setup.popup(), f.setup.inline(), f.setup.input(), f.setup.date(), f.create.calendar(), f.bind.events(), f.instantiate(); },
        instantiate() { f.verbose('Storing instance of calendar'), R = f, k.data(w, R); },
        destroy() { f.verbose('Destroying previous calendar for', D), k.removeData(w), f.unbind.events(); },
        setup: {
          popup() {
            if (!m.inline && (A.length || (A = k.children().first(), A.length))) {
              if (e.fn.popup === i) return void f.error(x.popup); S.length || (S = e('<div/>').addClass(g.popup).prependTo(A.parent())), S.addClass(g.calendar); let t = m.onVisible; let n = m.onHidden; T.length || (S.attr('tabindex', '0'), t = function () { return f.focus(), m.onVisible.apply(S, arguments); }, n = function () { return f.blur(), m.onHidden.apply(S, arguments); }); const o = function () { return f.set.focusDate(f.get.date()), f.set.mode(m.startMode), m.onShow.apply(S, arguments); }; const a = m.on || (T.length ? 'focus' : 'click'); const r = e.extend({}, m.popupOptions, {
                popup: S, on: a, hoverable: a === 'hover', onShow: o, onVisible: t, onHide: m.onHide, onHidden: n,
              }); f.popup(r);
            }
          },
          inline() { (!A.length || m.inline) && (S = e('<div/>').addClass(g.calendar).appendTo(k), T.length || S.attr('tabindex', '0')); },
          input() { m.touchReadonly && T.length && a && T.prop('readonly', !0); },
          date() { if (T.length) { const e = T.val(); const t = b.date(e, m); f.set.date(t, m.formatInput, !1); } },
        },
        create: { calendar() { let t; let n; let i; let o; let a; const r = f.get.mode(); const s = new Date(); const c = f.get.date(); let l = f.get.focusDate(); let u = l || c || m.initialDate || s; u = f.helper.dateInRange(u), l || (l = u, f.set.focusDate(l, !1, !1)); const d = u.getMinutes(); const p = u.getHours(); const h = u.getDate(); const b = u.getMonth(); const x = u.getFullYear(); const C = r === 'year'; const w = r === 'month'; const k = r === 'day'; const T = r === 'hour'; const A = r === 'minute'; const D = m.type === 'time'; const R = k ? 7 : T ? 4 : 3; const E = R === 7 ? 'seven' : R === 4 ? 'four' : 'three'; let P = k || T ? 6 : 4; const F = (new Date(x, b, 1).getDay() - m.firstDayOfWeek % 7 + 7) % 7; if (!m.constantHeight && k) { const O = new Date(x, b + 1, 0).getDate() + F; P = Math.ceil(O / 7); } const q = C ? 10 : w ? 1 : 0; const j = k ? 1 : 0; const I = T || A ? 1 : 0; const z = T || A ? h : 1; const N = new Date(x - q, b - j, z - I, p); const M = new Date(x + q, b + j, z + I, p); const L = C ? new Date(10 * Math.ceil(x / 10) - 9, 0, 0) : w ? new Date(x, 0, 0) : k ? new Date(x, b, 0) : new Date(x, b, h, -1); const V = C ? new Date(10 * Math.ceil(x / 10) + 1, 0, 1) : w ? new Date(x + 1, 0, 1) : k ? new Date(x, b + 1, 1) : new Date(x, b, h + 1); const H = e('<table/>').addClass(g.table).addClass(`${E} column`).addClass(r); if (!D) { const U = e('<thead/>').appendTo(H); o = e('<tr/>').appendTo(U), a = e('<th/>').attr('colspan', `${R}`).appendTo(o); const W = e('<span/>').addClass(g.link).appendTo(a); W.text(v.header(u, r, m)); const B = w ? m.disableYear ? 'day' : 'year' : k ? m.disableMonth ? 'year' : 'month' : 'day'; W.data(y.mode, B); const Y = e('<span/>').addClass(g.prev).appendTo(a); Y.data(y.focusDate, N), Y.toggleClass(g.disabledCell, !f.helper.isDateInRange(L, r)), e('<i/>').addClass(g.prevIcon).appendTo(Y); const Q = e('<span/>').addClass(g.next).appendTo(a); if (Q.data(y.focusDate, M), Q.toggleClass(g.disabledCell, !f.helper.isDateInRange(V, r)), e('<i/>').addClass(g.nextIcon).appendTo(Q), k) for (o = e('<tr/>').appendTo(U), t = 0; R > t; t++)a = e('<th/>').appendTo(o), a.text(v.dayColumnHeader((t + m.firstDayOfWeek) % 7, m)); } const X = e('<tbody/>').appendTo(H); for (t = C ? 10 * Math.ceil(x / 10) - 9 : k ? 1 - F : 0, n = 0; P > n; n++) for (o = e('<tr/>').appendTo(X), i = 0; R > i; i++, t++) { const $ = C ? new Date(t, b, 1, p, d) : w ? new Date(x, t, 1, p, d) : k ? new Date(x, b, t, p, d) : T ? new Date(x, b, h, t) : new Date(x, b, h, p, 5 * t); const K = C ? t : w ? m.text.monthsShort[t] : k ? $.getDate() : v.time($, m, !0); a = e('<td/>').addClass(g.cell).appendTo(o), a.text(K), a.data(y.date, $); const Z = k && $.getMonth() !== b || !f.helper.isDateInRange($, r); const J = f.helper.dateEqual($, c, r); a.toggleClass(g.disabledCell, Z), a.toggleClass(g.activeCell, J), T || A || a.toggleClass(g.todayCell, f.helper.dateEqual($, s, r)), f.helper.dateEqual($, l, r) && f.set.focusDate($, !1, !1); } if (m.today) { const G = e('<tr/>').appendTo(X); const _ = e('<td/>').attr('colspan', `${R}`).addClass(g.today).appendTo(G); _.text(v.today(m)), _.data(y.date, s); }f.update.focus(!1, H), S.empty(), H.appendTo(S); } },
        update: { focus(t, n) { n = n || S; const i = f.get.mode(); const o = f.get.date(); const r = f.get.focusDate(); const s = f.get.startDate(); const c = f.get.endDate(); const l = (t ? r : null) || o || (a ? null : r); n.find('td').each(function () { const t = e(this); const n = t.data(y.date); if (n) { const o = t.hasClass(g.disabledCell); const u = t.hasClass(g.activeCell); const d = f.helper.dateEqual(n, r, i); const m = l ? !!s && f.helper.isDateInRange(n, i, s, l) || !!c && f.helper.isDateInRange(n, i, l, c) : !1; t.toggleClass(g.focusCell, d && (!a || E)), t.toggleClass(g.rangeCell, m && !u && !o); } }); } },
        refresh() { f.create.calendar(); },
        bind: { events() { S.on(`mousedown${C}`, f.event.mousedown), S.on(`touchstart${C}`, f.event.mousedown), S.on(`mouseup${C}`, f.event.mouseup), S.on(`touchend${C}`, f.event.mouseup), S.on(`mouseover${C}`, f.event.mouseover), T.length ? (T.on(`input${C}`, f.event.inputChange), T.on(`focus${C}`, f.event.inputFocus), T.on(`blur${C}`, f.event.inputBlur), T.on(`click${C}`, f.event.inputClick), T.on(`keydown${C}`, f.event.keydown)) : S.on(`keydown${C}`, f.event.keydown); } },
        unbind: { events() { S.off(C), T.length && T.off(C); } },
        event: {
          mouseover(t) { const n = e(t.target); const i = n.data(y.date); const o = t.buttons === 1; i && f.set.focusDate(i, !1, !0, o); },
          mousedown(t) { T.length && t.preventDefault(), E = t.type.indexOf('touch') >= 0; const n = e(t.target); const i = n.data(y.date); i && f.set.focusDate(i, !1, !0, !0); },
          mouseup(t) { f.focus(), t.preventDefault(), t.stopPropagation(), E = !1; let n = e(t.target); const i = n.parent(); (i.data(y.date) || i.data(y.focusDate) || i.data(y.mode)) && (n = i); const o = n.data(y.date); const a = n.data(y.focusDate); const r = n.data(y.mode); if (o) { const s = n.hasClass(g.today); f.selectDate(o, s); } else a ? f.set.focusDate(a) : r && f.set.mode(r); },
          keydown(e) {
            if ((e.keyCode === 27 || e.keyCode === 9) && f.popup('hide'), f.popup('is visible')) {
              if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
                const t = f.get.mode(); const n = t === 'day' ? 7 : t === 'hour' ? 4 : 3; let i = e.keyCode === 37 ? -1 : e.keyCode === 38 ? -n : e.keyCode == 39 ? 1 : n; i *= t === 'minute' ? 5 : 1; const o = f.get.focusDate() || f.get.date() || new Date(); const a = o.getFullYear() + (t === 'year' ? i : 0); const r = o.getMonth() + (t === 'month' ? i : 0); const s = o.getDate() + (t === 'day' ? i : 0); const c = o.getHours() + (t === 'hour' ? i : 0); const l = o.getMinutes() + (t === 'minute' ? i : 0); let
                  u = new Date(a, r, s, c, l); m.type === 'time' && (u = f.helper.mergeDateTime(o, u)), f.helper.isDateInRange(u, t) && f.set.focusDate(u);
              } else if (e.keyCode === 13) { const d = f.get.focusDate(); d && f.selectDate(d); }
            }(e.keyCode === 38 || e.keyCode === 40) && (e.preventDefault(), f.popup('show'));
          },
          inputChange() { const e = T.val(); const t = b.date(e, m); f.set.date(t, !1); },
          inputFocus() { S.addClass(g.active); },
          inputBlur() { if (S.removeClass(g.active), m.formatInput) { const e = f.get.date(); const t = v.datetime(e, m); T.val(t); } },
          inputClick() { f.popup('show'); },
        },
        get: {
          date() { return k.data(y.date); }, focusDate() { return k.data(y.focusDate); }, startDate() { const e = f.get.calendarModule(m.startCalendar); return e ? e.get.date() : k.data(y.startDate); }, endDate() { const e = f.get.calendarModule(m.endCalendar); return e ? e.get.date() : k.data(y.endDate); }, mode() { const t = k.data(y.mode) || m.startMode; const n = f.get.validModes(); return e.inArray(t, n) >= 0 ? t : m.type === 'time' ? 'hour' : m.type === 'month' ? 'month' : m.type === 'year' ? 'year' : 'day'; }, validModes() { const e = []; return m.type !== 'time' && (m.disableYear && m.type !== 'year' || e.push('year'), (!m.disableMonth && m.type !== 'year' || m.type === 'month') && e.push('month'), m.type.indexOf('date') >= 0 && e.push('day')), m.type.indexOf('time') >= 0 && (e.push('hour'), m.disableMinute || e.push('minute')), e; }, isTouch() { try { return n.createEvent('TouchEvent'), !0; } catch (e) { return !1; } }, calendarModule(t) { return t ? (t instanceof e || (t = k.parent().children(t).first()), t.data(w)) : null; },
        },
        set: {
          date(e, t, n) { t = t !== !1, n = n !== !1, e = f.helper.sanitiseDate(e), e = f.helper.dateInRange(e); const o = v.datetime(e, m); if (n && m.onChange.call(D, e, o) === !1) return !1; const a = f.get.endDate(); a && e && e > a && f.set.endDate(i), f.set.dataKeyValue(y.date, e), f.set.focusDate(e), t && T.length && T.val(o); }, startDate(e, t) { e = f.helper.sanitiseDate(e); const n = f.get.calendarModule(m.startCalendar); n && n.set.date(e), f.set.dataKeyValue(y.startDate, e, t); }, endDate(e, t) { e = f.helper.sanitiseDate(e); const n = f.get.calendarModule(m.endCalendar); n && n.set.date(e), f.set.dataKeyValue(y.endDate, e, t); }, focusDate(e, t, n, i) { e = f.helper.sanitiseDate(e), e = f.helper.dateInRange(e); const o = f.set.dataKeyValue(y.focusDate, e, t); n = n !== !1 && o && t === !1 || P != i, P = i, n && f.update.focus(i); }, mode(e, t) { f.set.dataKeyValue(y.mode, e, t); }, dataKeyValue(e, t, n) { const i = k.data(e); const o = i === t || t >= i && i >= t; return t ? k.data(e, t) : k.removeData(e), n = n !== !1 && !o, n && f.create.calendar(), !o; },
        },
        selectDate(e, t) { const n = f.get.mode(); const i = t || n === 'minute' || m.disableMinute && n === 'hour' || m.type === 'date' && n === 'day' || m.type === 'month' && n === 'month' || m.type === 'year' && n === 'year'; if (i) { const o = f.set.date(e) === !1; if (!o && m.closable) { f.popup('hide'); const a = f.get.calendarModule(m.endCalendar); a && (a.popup('show'), a.focus()); } } else { const r = n === 'year' ? m.disableMonth ? 'day' : 'month' : n === 'month' ? 'day' : n === 'day' ? 'hour' : 'minute'; f.set.mode(r), n === 'hour' || n === 'day' && f.get.date() ? f.set.date(e) : f.set.focusDate(e); } },
        changeDate(e) { f.set.date(e); },
        clear() { f.set.date(i); },
        popup() { return A.popup.apply(A, arguments); },
        focus() { T.length ? T.focus() : S.focus(); },
        blur() { T.length ? T.blur() : S.blur(); },
        helper: {
          sanitiseDate(e) { return e ? (e instanceof Date || (e = b.date(`${e}`)), isNaN(e.getTime()) ? i : e) : i; }, dateDiff(e, t, n) { n = n || 'day'; const i = m.type === 'time'; const o = n === 'year'; const a = o || n === 'month'; const r = n === 'minute'; const s = r || n === 'hour'; return e = new Date(i ? 2e3 : e.getFullYear(), i ? 0 : o ? 0 : e.getMonth(), i ? 1 : a ? 1 : e.getDate(), s ? e.getHours() : 0, r ? Math.floor(e.getMinutes() / 5) : 0), t = new Date(i ? 2e3 : t.getFullYear(), i ? 0 : o ? 0 : t.getMonth(), i ? 1 : a ? 1 : t.getDate(), s ? t.getHours() : 0, r ? Math.floor(t.getMinutes() / 5) : 0), t.getTime() - e.getTime(); }, dateEqual(e, t, n) { return !!e && !!t && f.helper.dateDiff(e, t, n) === 0; }, isDateInRange(e, t, n, i) { if (!n && !i) { const o = f.get.startDate(); n = o && m.minDate ? Math.max(o, m.minDate) : o || m.minDate, i = m.maxDate; } return !(!e || n && f.helper.dateDiff(e, n, t) > 0 || i && f.helper.dateDiff(i, e, t) > 0); }, dateInRange(e, t, n) { if (!t && !n) { const i = f.get.startDate(); t = i && m.minDate ? Math.max(i, m.minDate) : i || m.minDate, n = m.maxDate; } const o = m.type === 'time'; return e ? t && f.helper.dateDiff(e, t, 'minute') > 0 ? o ? f.helper.mergeDateTime(e, t) : t : n && f.helper.dateDiff(n, e, 'minute') > 0 ? o ? f.helper.mergeDateTime(e, n) : n : e : e; }, mergeDateTime(e, t) { return e && t ? new Date(e.getFullYear(), e.getMonth(), e.getDate(), t.getHours(), t.getMinutes()) : t; },
        },
        setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        debug() { m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
        error() { f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = R; return n = n || d, a = D || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (f.error(x.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, u ? (R === i && f.initialize(), f.invoke(l)) : (R !== i && R.invoke('destroy'), f.initialize());
    }), o !== i ? o : a;
  }, e.fn.calendar.settings = {
    name: 'Calendar',
    namespace: 'calendar',
    debug: !1,
    verbose: !1,
    performance: !1,
    type: 'datetime',
    firstDayOfWeek: 0,
    constantHeight: !0,
    today: !1,
    closable: !0,
    monthFirst: !0,
    touchReadonly: !0,
    inline: !1,
    on: null,
    initialDate: null,
    startMode: !1,
    minDate: null,
    maxDate: null,
    ampm: !0,
    disableYear: !1,
    disableMonth: !1,
    disableMinute: !1,
    formatInput: !0,
    startCalendar: null,
    endCalendar: null,
    popupOptions: {
      position: 'bottom left', lastResort: 'bottom left', prefer: 'opposite', hideOnScroll: !1,
    },
    text: {
      days: ['S', 'M', 'T', 'W', 'T', 'F', 'S'], months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], today: 'Today', now: 'Now', am: 'AM', pm: 'PM',
    },
    formatter: {
      header(e, t, n) { return t === 'year' ? n.formatter.yearHeader(e, n) : t === 'month' ? n.formatter.monthHeader(e, n) : t === 'day' ? n.formatter.dayHeader(e, n) : t === 'hour' ? n.formatter.hourHeader(e, n) : n.formatter.minuteHeader(e, n); }, yearHeader(e, t) { const n = 10 * Math.ceil(e.getFullYear() / 10); return `${n - 9} - ${n + 2}`; }, monthHeader(e, t) { return e.getFullYear(); }, dayHeader(e, t) { const n = t.text.months[e.getMonth()]; const i = e.getFullYear(); return `${n} ${i}`; }, hourHeader(e, t) { return t.formatter.date(e, t); }, minuteHeader(e, t) { return t.formatter.date(e, t); }, dayColumnHeader(e, t) { return t.text.days[e]; }, datetime(e, t) { if (!e) return ''; const n = t.type === 'time' ? '' : t.formatter.date(e, t); const i = t.type.indexOf('time') < 0 ? '' : t.formatter.time(e, t, !1); const o = t.type === 'datetime' ? ' ' : ''; return n + o + i; }, date(e, t) { if (!e) return ''; const n = e.getDate(); const i = t.text.months[e.getMonth()]; const o = e.getFullYear(); return t.type === 'year' ? o : t.type === 'month' ? `${i} ${o}` : `${t.monthFirst ? `${i} ${n}` : `${n} ${i}`}, ${o}`; }, time(e, t, n) { if (!e) return ''; let i = e.getHours(); const o = e.getMinutes(); let a = ''; return t.ampm && (a = ` ${i < 12 ? t.text.am : t.text.pm}`, i = i === 0 ? 12 : i > 12 ? i - 12 : i), `${i}:${o < 10 ? '0' : ''}${o}${a}`; }, today(e) { return e.type === 'date' ? e.text.today : e.text.now; },
    },
    parser: { date(t, n) { if (!t) return null; if (t = (`${t}`).trim().toLowerCase(), t.length === 0) return null; let o; let a; let r; let s = -1; let c = -1; let l = -1; let u = -1; let d = -1; let f = i; const m = n.type === 'time'; const g = n.type.indexOf('time') < 0; const p = t.split(n.regExp.dateWords); const h = t.split(n.regExp.dateNumbers); if (!g) for (f = e.inArray(n.text.am.toLowerCase(), p) >= 0 ? !0 : e.inArray(n.text.pm.toLowerCase(), p) >= 0 ? !1 : i, o = 0; o < h.length; o++) { const v = h[o]; if (v.indexOf(':') >= 0) { if (c < 0 || s < 0) { const b = v.split(':'); for (r = 0; r < Math.min(2, b.length); r++)a = parseInt(b[r]), isNaN(a) && (a = 0), r === 0 ? c = a % 24 : s = a % 60; }h.splice(o, 1); } } if (!m) { for (o = 0; o < p.length; o++) { let y = p[o]; if (!(y.length <= 0)) { for (y = y.substring(0, Math.min(y.length, 3)), a = 0; a < n.text.months.length; a++) { let x = n.text.months[a]; if (x = x.substring(0, Math.min(y.length, Math.min(x.length, 3))).toLowerCase(), x === y) { u = a + 1; break; } } if (u >= 0) break; } } for (o = 0; o < h.length; o++) if (a = parseInt(h[o]), !isNaN(a) && a > 59) { d = a, h.splice(o, 1); break; } if (u < 0) for (o = 0; o < h.length; o++) if (r = o > 1 || n.monthFirst ? o : o === 1 ? 0 : 1, a = parseInt(h[r]), !isNaN(a) && a >= 1 && a <= 12) { u = a, h.splice(r, 1); break; } for (o = 0; o < h.length; o++) if (a = parseInt(h[o]), !isNaN(a) && a >= 1 && a <= 31) { l = a, h.splice(o, 1); break; } if (d < 0) for (o = h.length - 1; o >= 0; o--) if (a = parseInt(h[o]), !isNaN(a)) { a < 99 && (a += 2e3), d = a, h.splice(o, 1); break; } } if (!g) { if (c < 0) for (o = 0; o < h.length; o++) if (a = parseInt(h[o]), !isNaN(a) && a >= 0 && a <= 23) { c = a, h.splice(o, 1); break; } if (s < 0) for (o = 0; o < h.length; o++) if (a = parseInt(h[o]), !isNaN(a) && a >= 0 && a <= 59) { s = a, h.splice(o, 1); break; } } if (s < 0 && c < 0 && l < 0 && u < 0 && d < 0) return null; s < 0 && (s = 0), c < 0 && (c = 0), l < 0 && (l = 1), u < 0 && (u = 1), d < 0 && (d = (new Date()).getFullYear()), f !== i && (f ? c === 12 && (c = 0) : c < 12 && (c += 12)); let C = new Date(d, u - 1, l, c, s); return (C.getMonth() !== u - 1 || C.getFullYear() !== d) && (C = new Date(d, u, 0, c, s)), isNaN(C.getTime()) ? null : C; } },
    onChange(e, t) { return !0; },
    onShow() {},
    onVisible() {},
    onHide() {},
    onHidden() {},
    selector: { popup: '.ui.popup', input: 'input', activator: 'input' },
    regExp: { dateWords: /[^A-Za-z\u00C0-\u024F]+/g, dateNumbers: /[^\d:]+/g },
    error: { popup: 'UI Popup, a required component is not included in this page', method: 'The method you called is not defined.' },
    className: {
      calendar: 'calendar', active: 'active', popup: 'ui popup', table: 'ui celled center aligned unstackable table', prev: 'prev link', next: 'next link', prevIcon: 'chevron left icon', nextIcon: 'chevron right icon', link: 'link', cell: 'link', disabledCell: 'disabled', activeCell: 'active', rangeCell: 'range', focusCell: 'focus', todayCell: 'today', today: 'today link',
    },
    metadata: {
      date: 'date', focusDate: 'focusDate', startDate: 'startDate', endDate: 'endDate', mode: 'mode',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.checkbox = function (n) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; let f; const m = e.extend(!0, {}, e.fn.checkbox.settings, n); const g = m.className; const p = m.namespace; const h = m.selector; const v = m.error; const b = `.${p}`; const y = `module-${p}`; let x = e(this); let C = e(this).children(h.label); let w = e(this).children(h.input); let k = w[0]; let T = !1; let S = !1; let A = x.data(y); const D = this; f = {
        initialize() { f.verbose('Initializing checkbox', m), f.create.label(), f.bind.events(), f.set.tabbable(), f.hide.input(), f.observeChanges(), f.instantiate(), f.setup(); },
        instantiate() { f.verbose('Storing instance of module', f), A = f, x.data(y, f); },
        destroy() { f.verbose('Destroying module'), f.unbind.events(), f.show.input(), x.removeData(y); },
        fix: { reference() { x.is(h.input) && (f.debug('Behavior called on <input> adjusting invoked element'), x = x.closest(h.checkbox), f.refresh()); } },
        setup() { f.set.initialLoad(), f.is.indeterminate() ? (f.debug('Initial value is indeterminate'), f.indeterminate()) : f.is.checked() ? (f.debug('Initial value is checked'), f.check()) : (f.debug('Initial value is unchecked'), f.uncheck()), f.remove.initialLoad(); },
        refresh() { C = x.children(h.label), w = x.children(h.input), k = w[0]; },
        hide: { input() { f.verbose('Modfying <input> z-index to be unselectable'), w.addClass(g.hidden); } },
        show: { input() { f.verbose('Modfying <input> z-index to be selectable'), w.removeClass(g.hidden); } },
        observeChanges() { 'MutationObserver' in t && (a = new MutationObserver((e) => { f.debug('DOM tree modified, updating selector cache'), f.refresh(); }), a.observe(D, { childList: !0, subtree: !0 }), f.debug('Setting up mutation observer', a)); },
        attachEvents(t, n) { const i = e(t); n = e.isFunction(f[n]) ? f[n] : f.toggle, i.length > 0 ? (f.debug('Attaching checkbox events to element', t, n), i.on(`click${b}`, n)) : f.error(v.notFound); },
        event: { click(t) { const n = e(t.target); return n.is(h.input) ? void f.verbose('Using default check action on initialized checkbox') : n.is(h.link) ? void f.debug('Clicking link inside checkbox, skipping toggle') : (f.toggle(), w.focus(), void t.preventDefault()); }, keydown(e) { const t = e.which; const n = { enter: 13, space: 32, escape: 27 }; t == n.escape ? (f.verbose('Escape key pressed blurring field'), w.blur(), S = !0) : e.ctrlKey || t != n.space && t != n.enter ? S = !1 : (f.verbose('Enter/space key pressed, toggling checkbox'), f.toggle(), S = !0); }, keyup(e) { S && e.preventDefault(); } },
        check() { f.should.allowCheck() && (f.debug('Checking checkbox', w), f.set.checked(), f.should.ignoreCallbacks() || (m.onChecked.call(k), m.onChange.call(k))); },
        uncheck() { f.should.allowUncheck() && (f.debug('Unchecking checkbox'), f.set.unchecked(), f.should.ignoreCallbacks() || (m.onUnchecked.call(k), m.onChange.call(k))); },
        indeterminate() { return f.should.allowIndeterminate() ? void f.debug('Checkbox is already indeterminate') : (f.debug('Making checkbox indeterminate'), f.set.indeterminate(), void (f.should.ignoreCallbacks() || (m.onIndeterminate.call(k), m.onChange.call(k)))); },
        determinate() { return f.should.allowDeterminate() ? void f.debug('Checkbox is already determinate') : (f.debug('Making checkbox determinate'), f.set.determinate(), void (f.should.ignoreCallbacks() || (m.onDeterminate.call(k), m.onChange.call(k)))); },
        enable() { return f.is.enabled() ? void f.debug('Checkbox is already enabled') : (f.debug('Enabling checkbox'), f.set.enabled(), void m.onEnable.call(k)); },
        disable() { return f.is.disabled() ? void f.debug('Checkbox is already disabled') : (f.debug('Disabling checkbox'), f.set.disabled(), void m.onDisable.call(k)); },
        get: { radios() { const t = f.get.name(); return e(`input[name="${t}"]`).closest(h.checkbox); }, otherRadios() { return f.get.radios().not(x); }, name() { return w.attr('name'); } },
        is: {
          initialLoad() { return T; }, radio() { return w.hasClass(g.radio) || w.attr('type') == 'radio'; }, indeterminate() { return w.prop('indeterminate') !== i && w.prop('indeterminate'); }, checked() { return w.prop('checked') !== i && w.prop('checked'); }, disabled() { return w.prop('disabled') !== i && w.prop('disabled'); }, enabled() { return !f.is.disabled(); }, determinate() { return !f.is.indeterminate(); }, unchecked() { return !f.is.checked(); },
        },
        should: {
          allowCheck() { return f.is.determinate() && f.is.checked() && !f.should.forceCallbacks() ? (f.debug('Should not allow check, checkbox is already checked'), !1) : m.beforeChecked.apply(k) === !1 ? (f.debug('Should not allow check, beforeChecked cancelled'), !1) : !0; }, allowUncheck() { return f.is.determinate() && f.is.unchecked() && !f.should.forceCallbacks() ? (f.debug('Should not allow uncheck, checkbox is already unchecked'), !1) : m.beforeUnchecked.apply(k) === !1 ? (f.debug('Should not allow uncheck, beforeUnchecked cancelled'), !1) : !0; }, allowIndeterminate() { return f.is.indeterminate() && !f.should.forceCallbacks() ? (f.debug('Should not allow indeterminate, checkbox is already indeterminate'), !1) : m.beforeIndeterminate.apply(k) === !1 ? (f.debug('Should not allow indeterminate, beforeIndeterminate cancelled'), !1) : !0; }, allowDeterminate() { return f.is.determinate() && !f.should.forceCallbacks() ? (f.debug('Should not allow determinate, checkbox is already determinate'), !1) : m.beforeDeterminate.apply(k) === !1 ? (f.debug('Should not allow determinate, beforeDeterminate cancelled'), !1) : !0; }, forceCallbacks() { return f.is.initialLoad() && m.fireOnInit; }, ignoreCallbacks() { return T && !m.fireOnInit; },
        },
        can: { change() { return !(x.hasClass(g.disabled) || x.hasClass(g.readOnly) || w.prop('disabled') || w.prop('readonly')); }, uncheck() { return typeof m.uncheckable === 'boolean' ? m.uncheckable : !f.is.radio(); } },
        set: {
          initialLoad() { T = !0; }, checked() { return f.verbose('Setting class to checked'), x.removeClass(g.indeterminate).addClass(g.checked), f.is.radio() && f.uncheckOthers(), !f.is.indeterminate() && f.is.checked() ? void f.debug('Input is already checked, skipping input property change') : (f.verbose('Setting state to checked', k), w.prop('indeterminate', !1).prop('checked', !0), void f.trigger.change()); }, unchecked() { return f.verbose('Removing checked class'), x.removeClass(g.indeterminate).removeClass(g.checked), !f.is.indeterminate() && f.is.unchecked() ? void f.debug('Input is already unchecked') : (f.debug('Setting state to unchecked'), w.prop('indeterminate', !1).prop('checked', !1), void f.trigger.change()); }, indeterminate() { return f.verbose('Setting class to indeterminate'), x.addClass(g.indeterminate), f.is.indeterminate() ? void f.debug('Input is already indeterminate, skipping input property change') : (f.debug('Setting state to indeterminate'), w.prop('indeterminate', !0), void f.trigger.change()); }, determinate() { return f.verbose('Removing indeterminate class'), x.removeClass(g.indeterminate), f.is.determinate() ? void f.debug('Input is already determinate, skipping input property change') : (f.debug('Setting state to determinate'), void w.prop('indeterminate', !1)); }, disabled() { return f.verbose('Setting class to disabled'), x.addClass(g.disabled), f.is.disabled() ? void f.debug('Input is already disabled, skipping input property change') : (f.debug('Setting state to disabled'), w.prop('disabled', 'disabled'), void f.trigger.change()); }, enabled() { return f.verbose('Removing disabled class'), x.removeClass(g.disabled), f.is.enabled() ? void f.debug('Input is already enabled, skipping input property change') : (f.debug('Setting state to enabled'), w.prop('disabled', !1), void f.trigger.change()); }, tabbable() { f.verbose('Adding tabindex to checkbox'), w.attr('tabindex') === i && w.attr('tabindex', 0); },
        },
        remove: { initialLoad() { T = !1; } },
        trigger: { change() { f.verbose('Triggering change event from programmatic change'), w.trigger('change'); } },
        create: { label() { w.prevAll(h.label).length > 0 ? (w.prev(h.label).detach().insertAfter(w), f.debug('Moving existing label', C)) : f.has.label() || (C = e('<label>').insertAfter(w), f.debug('Creating label', C)); } },
        has: { label() { return C.length > 0; } },
        bind: { events() { f.verbose('Attaching checkbox events'), x.on(`click${b}`, f.event.click).on(`keydown${b}`, h.input, f.event.keydown).on(`keyup${b}`, h.input, f.event.keyup); } },
        unbind: { events() { f.debug('Removing events'), x.off(b); } },
        uncheckOthers() { const e = f.get.otherRadios(); f.debug('Unchecking other radios', e), e.removeClass(g.checked); },
        toggle() { return f.can.change() ? void (f.is.indeterminate() || f.is.unchecked() ? (f.debug('Currently unchecked'), f.check()) : f.is.checked() && f.can.uncheck() && (f.debug('Currently checked'), f.uncheck())) : void (f.is.radio() || f.debug('Checkbox is read-only or disabled, ignoring toggle')); },
        setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        debug() { m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
        error() { f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = A; return n = n || d, a = D || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (f.error(v.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, u ? (A === i && f.initialize(), f.invoke(l)) : (A !== i && A.invoke('destroy'), f.initialize());
    }), o !== i ? o : this;
  }, e.fn.checkbox.settings = {
    name: 'Checkbox',
    namespace: 'checkbox',
    debug: !1,
    verbose: !0,
    performance: !0,
    uncheckable: 'auto',
    fireOnInit: !1,
    onChange() {},
    beforeChecked() {},
    beforeUnchecked() {},
    beforeDeterminate() {},
    beforeIndeterminate() {},
    onChecked() {},
    onUnchecked() {},
    onDeterminate() {},
    onIndeterminate() {},
    onEnabled() {},
    onDisabled() {},
    className: {
      checked: 'checked', indeterminate: 'indeterminate', disabled: 'disabled', hidden: 'hidden', radio: 'radio', readOnly: 'read-only',
    },
    error: { method: 'The method you called is not defined' },
    selector: {
      checkbox: '.ui.checkbox', label: 'label, .box', input: 'input[type="checkbox"], input[type="radio"]', link: 'a[href]',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.dimmer = function (t) {
    let o; const a = e(this); let r = (new Date()).getTime(); let s = []; const c = arguments[0]; const l = typeof c === 'string'; const u = [].slice.call(arguments, 1); return a.each(function () {
      let d; let f; let m; const g = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.dimmer.settings, t) : e.extend({}, e.fn.dimmer.settings); const p = g.selector; const h = g.namespace; const v = g.className; const b = g.error; const y = `.${h}`; const x = `module-${h}`; const C = a.selector || ''; const w = 'ontouchstart' in n.documentElement ? 'touchstart' : 'click'; const k = e(this); const T = this; let S = k.data(x); m = {
        preinitialize() { m.is.dimmer() ? (f = k.parent(), d = k) : (f = k, d = m.has.dimmer() ? g.dimmerName ? f.find(p.dimmer).filter(`.${g.dimmerName}`) : f.find(p.dimmer) : m.create()); },
        initialize() { m.debug('Initializing dimmer', g), m.bind.events(), m.set.dimmable(), m.instantiate(); },
        instantiate() { m.verbose('Storing instance of module', m), S = m, k.data(x, S); },
        destroy() { m.verbose('Destroying previous module', d), m.unbind.events(), m.remove.variation(), f.off(y); },
        bind: { events() { g.on == 'hover' ? f.on(`mouseenter${y}`, m.show).on(`mouseleave${y}`, m.hide) : g.on == 'click' && f.on(w + y, m.toggle), m.is.page() && (m.debug('Setting as a page dimmer', f), m.set.pageDimmer()), m.is.closable() && (m.verbose('Adding dimmer close event', d), f.on(w + y, p.dimmer, m.event.click)); } },
        unbind: { events() { k.removeData(x); } },
        event: { click(t) { m.verbose('Determining if event occured on dimmer', t), (d.find(t.target).length === 0 || e(t.target).is(p.content)) && (m.hide(), t.stopImmediatePropagation()); } },
        addContent(t) { const n = e(t); m.debug('Add content to dimmer', n), n.parent()[0] !== d[0] && n.detach().appendTo(d); },
        create() { const t = e(g.template.dimmer()); return g.variation && (m.debug('Creating dimmer with variation', g.variation), t.addClass(g.variation)), g.dimmerName && (m.debug('Creating named dimmer', g.dimmerName), t.addClass(g.dimmerName)), t.appendTo(f), t; },
        show(t) { t = e.isFunction(t) ? t : function () {}, m.debug('Showing dimmer', d, g), m.is.dimmed() && !m.is.animating() || !m.is.enabled() ? m.debug('Dimmer is already shown or disabled') : (m.animate.show(t), g.onShow.call(T), g.onChange.call(T)); },
        hide(t) { t = e.isFunction(t) ? t : function () {}, m.is.dimmed() || m.is.animating() ? (m.debug('Hiding dimmer', d), m.animate.hide(t), g.onHide.call(T), g.onChange.call(T)) : m.debug('Dimmer is not visible'); },
        toggle() { m.verbose('Toggling dimmer visibility', d), m.is.dimmed() ? m.hide() : m.show(); },
        animate: {
          show(t) {
            t = e.isFunction(t) ? t : function () {}, g.useCSS && e.fn.transition !== i && d.transition('is supported') ? (g.opacity !== 'auto' && m.set.opacity(), d.transition({
              animation: `${g.transition} in`, queue: !1, duration: m.get.duration(), useFailSafe: !0, onStart() { m.set.dimmed(); }, onComplete() { m.set.active(), t(); },
            })) : (m.verbose('Showing dimmer animation with javascript'), m.set.dimmed(), g.opacity == 'auto' && (g.opacity = 0.8), d.stop().css({ opacity: 0, width: '100%', height: '100%' }).fadeTo(m.get.duration(), g.opacity, () => { d.removeAttr('style'), m.set.active(), t(); }));
          },
          hide(t) {
            t = e.isFunction(t) ? t : function () {}, g.useCSS && e.fn.transition !== i && d.transition('is supported') ? (m.verbose('Hiding dimmer with css'), d.transition({
              animation: `${g.transition} out`, queue: !1, duration: m.get.duration(), useFailSafe: !0, onStart() { m.remove.dimmed(); }, onComplete() { m.remove.active(), t(); },
            })) : (m.verbose('Hiding dimmer with javascript'), m.remove.dimmed(), d.stop().fadeOut(m.get.duration(), () => { m.remove.active(), d.removeAttr('style'), t(); }));
          },
        },
        get: { dimmer() { return d; }, duration() { return typeof g.duration === 'object' ? m.is.active() ? g.duration.hide : g.duration.show : g.duration; } },
        has: { dimmer() { return g.dimmerName ? k.find(p.dimmer).filter(`.${g.dimmerName}`).length > 0 : k.find(p.dimmer).length > 0; } },
        is: {
          active() { return d.hasClass(v.active); },
          animating() { return d.is(':animated') || d.hasClass(v.animating); },
          closable() { return g.closable == 'auto' ? g.on == 'hover' ? !1 : !0 : g.closable; },
          dimmer() { return k.hasClass(v.dimmer); },
          dimmable() { return k.hasClass(v.dimmable); },
          dimmed() {
            return f.hasClass(v.dimmed);
          },
          disabled() { return f.hasClass(v.disabled); },
          enabled() { return !m.is.disabled(); },
          page() { return f.is('body'); },
          pageDimmer() { return d.hasClass(v.pageDimmer); },
        },
        can: { show() { return !d.hasClass(v.disabled); } },
        set: {
          opacity(e) { let t = d.css('background-color'); const n = t.split(','); const i = n && n.length == 4; e = g.opacity === 0 ? 0 : g.opacity || e, i ? (n[3] = `${e})`, t = n.join(',')) : t = `rgba(0, 0, 0, ${e})`, m.debug('Setting opacity to', e), d.css('background-color', t); }, active() { d.addClass(v.active); }, dimmable() { f.addClass(v.dimmable); }, dimmed() { f.addClass(v.dimmed); }, pageDimmer() { d.addClass(v.pageDimmer); }, disabled() { d.addClass(v.disabled); }, variation(e) { e = e || g.variation, e && d.addClass(e); },
        },
        remove: {
          active() { d.removeClass(v.active); }, dimmed() { f.removeClass(v.dimmed); }, disabled() { d.removeClass(v.disabled); }, variation(e) { e = e || g.variation, e && d.removeClass(e); },
        },
        setting(t, n) { if (m.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, g, t); else { if (n === i) return g[t]; g[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        debug() { g.debug && (g.performance ? m.performance.log(arguments) : (m.debug = Function.prototype.bind.call(console.info, console, `${g.name}:`), m.debug.apply(console, arguments))); },
        verbose() { g.verbose && g.debug && (g.performance ? m.performance.log(arguments) : (m.verbose = Function.prototype.bind.call(console.info, console, `${g.name}:`), m.verbose.apply(console, arguments))); },
        error() { m.error = Function.prototype.bind.call(console.error, console, `${g.name}:`), m.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; g.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: T, 'Execution Time': n,
            })), clearTimeout(m.performance.timer), m.performance.timer = setTimeout(m.performance.display, 500);
          },
          display() { let t = `${g.name}:`; let n = 0; r = !1, clearTimeout(m.performance.timer), e.each(s, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, C && (t += ` '${C}'`), a.length > 1 && (t += ` (${a.length})`), (console.group !== i || console.table !== i) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = S; return n = n || u, a = T || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (m.error(b.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, m.preinitialize(), l ? (S === i && m.initialize(), m.invoke(c)) : (S !== i && S.invoke('destroy'), m.initialize());
    }), o !== i ? o : this;
  }, e.fn.dimmer.settings = {
    name: 'Dimmer',
    namespace: 'dimmer',
    debug: !1,
    verbose: !1,
    performance: !0,
    dimmerName: !1,
    variation: !1,
    closable: 'auto',
    useCSS: !0,
    transition: 'fade',
    on: !1,
    opacity: 'auto',
    duration: { show: 500, hide: 500 },
    onChange() {},
    onShow() {},
    onHide() {},
    error: { method: 'The method you called is not defined.' },
    className: {
      active: 'active', animating: 'animating', dimmable: 'dimmable', dimmed: 'dimmed', dimmer: 'dimmer', disabled: 'disabled', hide: 'hide', pageDimmer: 'page', show: 'show',
    },
    selector: { dimmer: '> .ui.dimmer', content: '.ui.dimmer > .content, .ui.dimmer > .content > .center' },
    template: { dimmer() { return e('<div />').attr('class', 'ui dimmer'); } },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.dropdown = function (o) {
    let a; let r = e(this); const s = e(n); const c = r.selector || ''; const l = 'ontouchstart' in n.documentElement; let u = (new Date()).getTime(); let d = []; const f = arguments[0]; const m = typeof f === 'string'; const g = [].slice.call(arguments, 1); return r.each(function (p) {
      let h; let v; let b; let y; let x; let C; let w; const k = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.dropdown.settings, o) : e.extend({}, e.fn.dropdown.settings); const T = k.className; const S = k.message; const A = k.fields; const D = k.metadata; const R = k.namespace; const E = k.regExp; const P = k.selector; const F = k.error; const O = k.templates; const q = `.${R}`; const j = `module-${R}`; let I = e(this); const z = e(k.context); let N = I.find(P.text); let M = I.find(P.search); let L = I.find(P.input); let V = I.find(P.icon); let H = I.prev().find(P.text).length > 0 ? I.prev().find(P.text) : I.prev(); let U = I.children(P.menu); let W = U.find(P.item); let B = !1; let Y = !1; let Q = !1; const X = this; let $ = I.data(j); w = {
        initialize() { w.debug('Initializing dropdown', k), w.is.alreadySetup() ? w.setup.reference() : (w.setup.layout(), w.refreshData(), w.save.defaults(), w.restore.selected(), w.create.id(), w.bind.events(), w.observeChanges(), w.instantiate()); },
        instantiate() { w.verbose('Storing instance of dropdown', w), $ = w, I.data(j, w); },
        destroy() { w.verbose('Destroying previous dropdown', I), w.remove.tabbable(), I.off(q).removeData(j), U.off(q), s.off(b), x && x.disconnect(), C && C.disconnect(); },
        observeChanges() { 'MutationObserver' in t && (x = new MutationObserver((e) => { w.debug('<select> modified, recreating menu'), w.setup.select(); }), C = new MutationObserver((e) => { w.debug('Menu modified, updating selector cache'), w.refresh(); }), w.has.input() && x.observe(L[0], { childList: !0, subtree: !0 }), w.has.menu() && C.observe(U[0], { childList: !0, subtree: !0 }), w.debug('Setting up mutation observer', x, C)); },
        create: {
          id() { y = (`${Math.random().toString(16)}000000000`).substr(2, 8), b = `.${y}`, w.verbose('Creating unique id for element', y); },
          userChoice(t) {
            let n; let o; let a; return (t = t || w.get.userValues()) ? (t = e.isArray(t) ? t : [t], e.each(t, (t, r) => {
              w.get.item(r) === !1 && (a = k.templates.addition(w.add.variables(S.addResult, r)), o = e('<div />').html(a).attr(`data-${D.value}`, r).attr(`data-${D.text}`, r)
                .addClass(T.addition)
                .addClass(T.item), n = n === i ? o : n.add(o), w.verbose('Creating user choices for value', r, o));
            }), n) : !1;
          },
          userLabels(t) { const n = w.get.userValues(); n && (w.debug('Adding user labels', n), e.each(n, (e, t) => { w.verbose('Adding custom user value'), w.add.label(t, t); })); },
          menu() { U = e('<div />').addClass(T.menu).appendTo(I); },
        },
        search(e) { e = e !== i ? e : w.get.query(), w.verbose('Searching for query', e), w.filter(e); },
        select: { firstUnfiltered() { w.verbose('Selecting first non-filtered element'), w.remove.selectedItem(), W.not(P.unselectable).eq(0).addClass(T.selected); }, nextAvailable(e) { e = e.eq(0); const t = e.nextAll(P.item).not(P.unselectable).eq(0); const n = e.prevAll(P.item).not(P.unselectable).eq(0); const i = t.length > 0; i ? (w.verbose('Moving selection to', t), t.addClass(T.selected)) : (w.verbose('Moving selection to', n), n.addClass(T.selected)); } },
        setup: {
          api() { const e = { debug: k.debug, on: !1 }; w.verbose('First request, initializing API'), I.api(e); },
          layout() { I.is('select') && (w.setup.select(), w.setup.returnedObject()), w.has.menu() || w.create.menu(), w.is.search() && !w.has.search() && (w.verbose('Adding search input'), M = e('<input />').addClass(T.search).insertBefore(N)), k.allowTab && w.set.tabbable(); },
          select() {
            const t = w.get.selectValues(); w.debug('Dropdown initialized on a select', t), I.is('select') && (L = I), L.parent(P.dropdown).length > 0 ? (w.debug('UI dropdown already exists. Creating dropdown menu only'), I = L.closest(P.dropdown), w.has.menu() || w.create.menu(), U = I.children(P.menu), w.setup.menu(t)) : (w.debug('Creating entire dropdown from select'), I = e('<div />').attr('class', L.attr('class')).addClass(T.selection).addClass(T.dropdown)
              .html(O.dropdown(t))
              .insertBefore(L), L.hasClass(T.multiple) && L.prop('multiple') === !1 && (w.error(F.missingMultiple), L.prop('multiple', !0)), L.is('[multiple]') && w.set.multiple(), L.prop('disabled') && (w.debug('Disabling dropdown'), I.addClass(T.disabled)), L.removeAttr('class').detach().prependTo(I)), w.refresh();
          },
          menu(e) { U.html(O.menu(e, A)), W = U.find(P.item); },
          reference() { w.debug('Dropdown behavior was called on select, replacing with closest dropdown'), I = I.parent(P.dropdown), w.refresh(), w.setup.returnedObject(), m && ($ = w, w.invoke(f)); },
          returnedObject() { const e = r.slice(0, p); const t = r.slice(p + 1); r = e.add(I).add(t); },
        },
        refresh() { w.refreshSelectors(), w.refreshData(); },
        refreshSelectors() { w.verbose('Refreshing selector cache'), N = I.find(P.text), M = I.find(P.search), L = I.find(P.input), V = I.find(P.icon), H = I.prev().find(P.text).length > 0 ? I.prev().find(P.text) : I.prev(), U = I.children(P.menu), W = U.find(P.item); },
        refreshData() { w.verbose('Refreshing cached metadata'), W.removeData(D.text).removeData(D.value), I.removeData(D.defaultText).removeData(D.defaultValue).removeData(D.placeholderText); },
        toggle() { w.verbose('Toggling menu visibility'), w.is.active() ? w.hide() : w.show(); },
        show(t) { if (t = e.isFunction(t) ? t : function () {}, w.can.show() && !w.is.active()) { if (w.debug('Showing dropdown'), w.is.multiple() && !w.has.search() && w.is.allFiltered()) return !0; w.has.message() && !w.has.maxSelections() && w.remove.message(), k.onShow.call(X) !== !1 && w.animate.show(() => { w.can.click() && w.bind.intent(), w.set.visible(), t.call(X); }); } },
        hide(t) { t = e.isFunction(t) ? t : function () {}, w.is.active() && (w.debug('Hiding dropdown'), k.onHide.call(X) !== !1 && w.animate.hide(() => { w.remove.visible(), t.call(X); })); },
        hideOthers() { w.verbose('Finding other dropdowns to hide'), r.not(I).has(`${P.menu}.${T.visible}`).dropdown('hide'); },
        hideMenu() { w.verbose('Hiding menu  instantaneously'), w.remove.active(), w.remove.visible(), U.transition('hide'); },
        hideSubMenus() { const e = U.children(P.item).find(P.menu); w.verbose('Hiding sub menus', e), e.transition('hide'); },
        bind: {
          events() { l && w.bind.touchEvents(), w.bind.keyboardEvents(), w.bind.inputEvents(), w.bind.mouseEvents(); },
          touchEvents() { w.debug('Touch device detected binding additional touch events'), w.is.searchSelection() || w.is.single() && I.on(`touchstart${q}`, w.event.test.toggle), U.on(`touchstart${q}`, P.item, w.event.item.mouseenter); },
          keyboardEvents() { w.verbose('Binding keyboard events'), I.on(`keydown${q}`, w.event.keydown), w.has.search() && I.on(w.get.inputEvent() + q, P.search, w.event.input), w.is.multiple() && s.on(`keydown${b}`, w.event.document.keydown); },
          inputEvents() { w.verbose('Binding input change events'), I.on(`change${q}`, P.input, w.event.change); },
          mouseEvents() {
            w.verbose('Binding mouse events'), w.is.multiple() && I.on(`click${q}`, P.label, w.event.label.click).on(`click${q}`, P.remove, w.event.remove.click), w.is.searchSelection() ? (I.on(`mousedown${q}`, P.menu, w.event.menu.mousedown).on(`mouseup${q}`, P.menu, w.event.menu.mouseup).on(`click${q}`, P.icon, w.event.icon.click).on(`click${q}`, P.search, w.show)
              .on(`focus${q}`, P.search, w.event.search.focus)
              .on(`blur${q}`, P.search, w.event.search.blur)
              .on(`click${q}`, P.text, w.event.text.focus), w.is.multiple() && I.on(`click${q}`, w.event.click)) : (k.on == 'click' ? I.on(`click${q}`, P.icon, w.event.icon.click).on(`click${q}`, w.event.test.toggle) : k.on == 'hover' ? I.on(`mouseenter${q}`, w.delay.show).on(`mouseleave${q}`, w.delay.hide) : I.on(k.on + q, w.toggle), I.on(`mousedown${q}`, w.event.mousedown).on(`mouseup${q}`, w.event.mouseup).on(`focus${q}`, w.event.focus).on(`blur${q}`, w.event.blur)), U.on(`mouseenter${q}`, P.item, w.event.item.mouseenter).on(`mouseleave${q}`, P.item, w.event.item.mouseleave).on(`click${q}`, P.item, w.event.item.click);
          },
          intent() { w.verbose('Binding hide intent event to document'), l && s.on(`touchstart${b}`, w.event.test.touch).on(`touchmove${b}`, w.event.test.touch), s.on(`click${b}`, w.event.test.hide); },
        },
        unbind: { intent() { w.verbose('Removing hide intent event from document'), l && s.off(`touchstart${b}`).off(`touchmove${b}`), s.off(`click${b}`); } },
        filter(e) { const t = e !== i ? e : w.get.query(); const n = function () { w.is.multiple() && w.filterActive(), w.select.firstUnfiltered(), w.has.allResultsFiltered() ? k.onNoResults.call(X, t) ? k.allowAdditions || (w.verbose('All items filtered, showing message', t), w.add.message(S.noResults)) : (w.verbose('All items filtered, hiding dropdown', t), w.hideMenu()) : w.remove.message(), k.allowAdditions && w.add.userSuggestion(e), w.is.searchSelection() && w.can.show() && w.is.focusedOnSearch() && w.show(); }; k.useLabels && w.has.maxSelections() || (k.apiSettings ? w.can.useAPI() ? w.queryRemote(t, () => { n(); }) : w.error(F.noAPI) : (w.filterItems(t), n())); },
        queryRemote(t, n) {
          let i = {
            errorDuration: !1, throttle: k.throttle, urlData: { query: t }, onError() { w.add.message(S.serverError), n(); }, onFailure() { w.add.message(S.serverError), n(); }, onSuccess(e) { w.remove.message(), w.setup.menu({ values: e.results }), n(); },
          }; I.api('get request') || w.setup.api(), i = e.extend(!0, {}, i, k.apiSettings), I.api('setting', i).api('query');
        },
        filterItems(t) { const n = t !== i ? t : w.get.query(); let o = null; const a = w.escape.regExp(n); const r = new RegExp(`^${a}`, 'igm'); w.has.query() && (o = [], w.verbose('Searching for matching values', n), W.each(function () { let t; let i; const a = e(this); if (k.match == 'both' || k.match == 'text') { if (t = String(w.get.choiceText(a, !1)), t.search(r) !== -1) return o.push(this), !0; if (k.fullTextSearch && w.fuzzySearch(n, t)) return o.push(this), !0; } if (k.match == 'both' || k.match == 'value') { if (i = String(w.get.choiceValue(a, t)), i.search(r) !== -1) return o.push(this), !0; if (k.fullTextSearch && w.fuzzySearch(n, i)) return o.push(this), !0; } })), w.debug('Showing only matched items', n), w.remove.filteredItem(), o && W.not(o).addClass(T.filtered); },
        fuzzySearch(e, t) { const n = t.length; const i = e.length; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; i > o; o++) { for (let r = e.charCodeAt(o); n > a;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
        filterActive() { k.useLabels && W.filter(`.${T.active}`).addClass(T.filtered); },
        focusSearch() { w.is.search() && !w.is.focusedOnSearch() && M[0].focus(); },
        forceSelection() { const e = W.not(T.filtered).filter(`.${T.selected}`).eq(0); const t = W.not(T.filtered).filter(`.${T.active}`).eq(0); const n = e.length > 0 ? e : t; const i = n.size() > 0; i && w.has.query() ? (w.debug('Forcing partial selection to selected item', n), w.event.item.click.call(n)) : w.hide(); },
        event: {
          change() { Q || (w.debug('Input changed, updating selection'), w.set.selected()); },
          focus() { k.showOnFocus && !B && w.is.hidden() && !v && w.show(); },
          click(t) { const n = e(t.target); n.is(I) && !w.is.focusedOnSearch() && w.focusSearch(); },
          blur(e) { v = n.activeElement === this, B || v || (w.remove.activeLabel(), w.hide()); },
          mousedown() { B = !0; },
          mouseup() { B = !1; },
          search: { focus() { B = !0, w.is.multiple() && w.remove.activeLabel(), k.showOnFocus && w.show(); }, blur(e) { v = n.activeElement === this, Y || v ? v && k.forceSelection && w.forceSelection() : w.is.multiple() ? (w.remove.activeLabel(), w.hide()) : k.forceSelection ? w.forceSelection() : w.hide(); } },
          icon: { click(e) { w.toggle(), e.stopPropagation(); } },
          text: { focus(e) { B = !0, w.focusSearch(); } },
          input(e) { (w.is.multiple() || w.is.searchSelection()) && w.set.filtered(), clearTimeout(w.timer), w.timer = setTimeout(w.search, k.delay.search); },
          label: { click(t) { const n = e(this); const i = I.find(P.label); const o = i.filter(`.${T.active}`); const a = n.nextAll(`.${T.active}`); const r = n.prevAll(`.${T.active}`); const s = a.length > 0 ? n.nextUntil(a).add(o).add(n) : n.prevUntil(r).add(o).add(n); t.shiftKey ? (o.removeClass(T.active), s.addClass(T.active)) : t.ctrlKey ? n.toggleClass(T.active) : (o.removeClass(T.active), n.addClass(T.active)), k.onLabelSelect.apply(this, i.filter(`.${T.active}`)); } },
          remove: { click() { const t = e(this).parent(); t.hasClass(T.active) ? w.remove.activeLabels() : w.remove.activeLabels(t); } },
          test: { toggle(e) { const t = w.is.multiple() ? w.show : w.toggle; w.determine.eventOnElement(e, t) && e.preventDefault(); }, touch(e) { w.determine.eventOnElement(e, () => { e.type == 'touchstart' ? w.timer = setTimeout(() => { w.hide(); }, k.delay.touch) : e.type == 'touchmove' && clearTimeout(w.timer); }), e.stopPropagation(); }, hide(e) { w.determine.eventInModule(e, w.hide); } },
          menu: { mousedown() { Y = !0; }, mouseup() { Y = !1; } },
          item: {
            mouseenter(t) { const n = e(this).children(P.menu); const i = e(this).siblings(P.item).children(P.menu); n.length > 0 && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(() => { w.verbose('Showing sub-menu', n), e.each(i, function () { w.animate.hide(!1, e(this)); }), w.animate.show(!1, n); }, k.delay.show), t.preventDefault()); }, mouseleave(t) { const n = e(this).children(P.menu); n.length > 0 && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(() => { w.verbose('Hiding sub-menu', n), w.animate.hide(!1, n); }, k.delay.hide)); }, touchend() {}, click(t) { const n = e(this); const i = e(t ? t.target : ''); const o = n.find(P.menu); const a = w.get.choiceText(n); const r = w.get.choiceValue(n, a); const s = o.length > 0; const c = o.find(i).length > 0; c || s && !k.allowCategorySelection || (k.useLabels || (w.remove.filteredItem(), w.remove.searchTerm(), w.set.scrollPosition(n)), w.determine.selectAction.call(this, a, r)); },
          },
          document: { keydown(e) { const t = e.which; const n = w.get.shortcutKeys(); const i = w.is.inObject(t, n); if (i) { const o = I.find(P.label); let a = o.filter(`.${T.active}`); const r = (a.data(D.value), o.index(a)); const s = o.length; const c = a.length > 0; const l = a.length > 1; const u = r === 0; const d = r + 1 == s; const f = w.is.searchSelection(); const m = w.is.focusedOnSearch(); const g = w.is.focused(); const p = m && w.get.caretPosition() === 0; if (f && !c && !m) return; t == n.leftArrow ? !g && !p || c ? c && (e.shiftKey ? w.verbose('Adding previous label to selection') : (w.verbose('Selecting previous label'), o.removeClass(T.active)), u && !l ? a.addClass(T.active) : a.prev(P.siblingLabel).addClass(T.active).end(), e.preventDefault()) : (w.verbose('Selecting previous label'), o.last().addClass(T.active)) : t == n.rightArrow ? (g && !c && o.first().addClass(T.active), c && (e.shiftKey ? w.verbose('Adding next label to selection') : (w.verbose('Selecting next label'), o.removeClass(T.active)), d ? f ? m ? o.removeClass(T.active) : w.focusSearch() : l ? a.next(P.siblingLabel).addClass(T.active) : a.addClass(T.active) : a.next(P.siblingLabel).addClass(T.active), e.preventDefault())) : t == n.deleteKey || t == n.backspace ? c ? (w.verbose('Removing active labels'), d && f && !m && w.focusSearch(), a.last().next(P.siblingLabel).addClass(T.active), w.remove.activeLabels(a), e.preventDefault()) : p && !c && t == n.backspace && (w.verbose('Removing last label on input backspace'), a = o.last().addClass(T.active), w.remove.activeLabels(a)) : a.removeClass(T.active); } } },
          keydown(e) { let t = e.which; const n = w.get.shortcutKeys(); const i = w.is.inObject(t, n); if (i) { let o; let a; const r = W.not(P.unselectable).filter(`.${T.selected}`).eq(0); const s = U.children(`.${T.active}`).eq(0); const c = r.length > 0 ? r : s; const l = c.length > 0 ? c.siblings(`:not(.${T.filtered})`).andSelf() : U.children(`:not(.${T.filtered})`); const u = c.children(P.menu); const d = c.closest(P.menu); const f = d.hasClass(T.visible) || d.hasClass(T.animating) || d.parent(P.menu).length > 0; const m = u.length > 0; const g = c.length > 0; const p = c.not(P.unselectable).length > 0; const h = t == n.delimiter && k.allowAdditions && w.is.multiple(); if (w.is.visible()) { if ((t == n.enter || h) && (t == n.enter && g && m && !k.allowCategorySelection ? (w.verbose('Pressed enter on unselectable category, opening sub menu'), t = n.rightArrow) : p && (w.verbose('Selecting item from keyboard shortcut', c), w.event.item.click.call(c, e), w.is.searchSelection() && w.remove.searchTerm()), e.preventDefault()), t == n.leftArrow && (a = d[0] !== U[0], a && (w.verbose('Left key pressed, closing sub-menu'), w.animate.hide(!1, d), c.removeClass(T.selected), d.closest(P.item).addClass(T.selected), e.preventDefault())), t == n.rightArrow && m && (w.verbose('Right key pressed, opening sub-menu'), w.animate.show(!1, u), c.removeClass(T.selected), u.find(P.item).eq(0).addClass(T.selected), e.preventDefault()), t == n.upArrow) { if (o = g && f ? c.prevAll(`${P.item}:not(${P.unselectable})`).eq(0) : W.eq(0), l.index(o) < 0) return w.verbose('Up key pressed but reached top of current menu'), void e.preventDefault(); w.verbose('Up key pressed, changing active item'), c.removeClass(T.selected), o.addClass(T.selected), w.set.scrollPosition(o), e.preventDefault(); } if (t == n.downArrow) { if (o = g && f ? o = c.nextAll(`${P.item}:not(${P.unselectable})`).eq(0) : W.eq(0), o.length === 0) return w.verbose('Down key pressed but reached bottom of current menu'), void e.preventDefault(); w.verbose('Down key pressed, changing active item'), W.removeClass(T.selected), o.addClass(T.selected), w.set.scrollPosition(o), e.preventDefault(); }t == n.pageUp && (w.scrollPage('up'), e.preventDefault()), t == n.pageDown && (w.scrollPage('down'), e.preventDefault()), t == n.escape && (w.verbose('Escape key pressed, closing dropdown'), w.hide()); } else h && e.preventDefault(), t == n.downArrow && (w.verbose('Down key pressed, showing dropdown'), w.show(), e.preventDefault()); } else w.is.selection() && !w.is.search() && w.set.selectedLetter(String.fromCharCode(t)); },
        },
        determine: { selectAction(t, n) { w.verbose('Determining action', k.action), e.isFunction(w.action[k.action]) ? (w.verbose('Triggering preset action', k.action, t, n), w.action[k.action].call(this, t, n)) : e.isFunction(k.action) ? (w.verbose('Triggering user action', k.action, t, n), k.action.call(this, t, n)) : w.error(F.action, k.action); }, eventInModule(t, i) { const o = e(t.target); const a = o.closest(n.documentElement).length > 0; const r = o.closest(I).length > 0; return i = e.isFunction(i) ? i : function () {}, a && !r ? (w.verbose('Triggering event', i), i(), !0) : (w.verbose('Event occurred in dropdown, canceling callback'), !1); }, eventOnElement(t, n) { const i = e(t.target); const o = i.closest(P.siblingLabel); const a = I.find(o).length === 0; const r = i.closest(U).length === 0; return n = e.isFunction(n) ? n : function () {}, a && r ? (w.verbose('Triggering event', n), n(), !0) : (w.verbose('Event occurred in dropdown menu, canceling callback'), !1); } },
        action: {
          nothing() {}, activate(t, n) { if (n = n !== i ? n : t, w.can.activate(e(this))) { if (w.set.selected(n, e(this)), w.is.multiple() && !w.is.allFiltered()) return; w.hideAndClear(); } }, select(e, t) { w.action.activate.call(this); }, combo(t, n) { n = n !== i ? n : t, w.set.selected(n, e(this)), w.hideAndClear(); }, hide(e, t) { w.set.value(t), w.hideAndClear(); },
        },
        get: {
          id() { return y; },
          defaultText() { return I.data(D.defaultText); },
          defaultValue() { return I.data(D.defaultValue); },
          placeholderText() { return I.data(D.placeholderText) || ''; },
          text() { return N.text(); },
          query() { return e.trim(M.val()); },
          searchWidth(e) { return `${e * k.glyphWidth}em`; },
          selectionCount() { let t; const n = w.get.values(); return t = w.is.multiple() ? e.isArray(n) ? n.length : 0 : w.get.value() !== '' ? 1 : 0; },
          transition(e) { return k.transition == 'auto' ? w.is.upward(e) ? 'slide up' : 'slide down' : k.transition; },
          userValues() { let t = w.get.values(); return t ? (t = e.isArray(t) ? t : [t], e.grep(t, (e) => w.get.item(e) === !1)) : !1; },
          uniqueArray(t) { return e.grep(t, (n, i) => e.inArray(n, t) === i); },
          caretPosition() { let e; let t; const i = M.get(0); return 'selectionStart' in i ? i.selectionStart : n.selection ? (i.focus(), e = n.selection.createRange(), t = e.text.length, e.moveStart('character', -i.value.length), e.text.length - t) : void 0; },
          shortcutKeys() {
            return {
              backspace: 8, delimiter: 188, deleteKey: 46, enter: 13, escape: 27, pageUp: 33, pageDown: 34, leftArrow: 37, upArrow: 38, rightArrow: 39, downArrow: 40,
            };
          },
          value() { const t = L.length > 0 ? L.val() : I.data(D.value); return e.isArray(t) && t.length === 1 && t[0] === '' ? '' : t; },
          values() { const e = w.get.value(); return e === '' ? '' : !w.has.selectInput() && w.is.multiple() ? typeof e === 'string' ? e.split(k.delimiter) : '' : e; },
          remoteValues() { let t = w.get.values(); let n = !1; return t && (typeof t === 'string' && (t = [t]), n = {}, e.each(t, (e, t) => { const i = w.read.remoteData(t); w.verbose('Restoring value from session data', i, t), n[t] = i || t; })), n; },
          choiceText(t, n) { return n = n !== i ? n : k.preserveHTML, t ? (t.find(P.menu).length > 0 && (w.verbose('Retreiving text of element with sub-menu'), t = t.clone(), t.find(P.menu).remove(), t.find(P.menuIcon).remove()), t.data(D.text) !== i ? t.data(D.text) : n ? e.trim(t.html()) : e.trim(t.text())) : void 0; },
          choiceValue(t, n) { return n = n || w.get.choiceText(t), t ? t.data(D.value) !== i ? String(t.data(D.value)) : typeof n === 'string' ? e.trim(n.toLowerCase()) : String(n) : !1; },
          inputEvent() { const e = M[0]; return e ? e.oninput !== i ? 'input' : e.onpropertychange !== i ? 'propertychange' : 'keyup' : !1; },
          selectValues() { const t = {}; return t.values = [], I.find('option').each(function () { const n = e(this); const o = n.html(); const a = n.attr('disabled'); const r = n.attr('value') !== i ? n.attr('value') : o; k.placeholder === 'auto' && r === '' ? t.placeholder = o : t.values.push({ name: o, value: r, disabled: a }); }), k.placeholder && k.placeholder !== 'auto' && (w.debug('Setting placeholder value to', k.placeholder), t.placeholder = k.placeholder), k.sortSelect ? (t.values.sort((e, t) => (e.name > t.name ? 1 : -1)), w.debug('Retrieved and sorted values from select', t)) : w.debug('Retreived values from select', t), t; },
          activeItem() { return W.filter(`.${T.active}`); },
          selectedItem() { const e = W.not(P.unselectable).filter(`.${T.selected}`); return e.length > 0 ? e : W.eq(0); },
          itemWithAdditions(e) { let t = w.get.item(e); const n = w.create.userChoice(e); const i = n && n.length > 0; return i && (t = t.length > 0 ? t.add(n) : n), t; },
          item(t, n) { let o; let a; let r = !1; return t = t !== i ? t : w.get.values() !== i ? w.get.values() : w.get.text(), o = a ? t.length > 0 : t !== i && t !== null, a = w.is.multiple() && e.isArray(t), n = t === '' || t === 0 ? !0 : n || !1, o && W.each(function () { const o = e(this); const s = w.get.choiceText(o); const c = w.get.choiceValue(o, s); if (c !== null && c !== i) if (a)(e.inArray(String(c), t) !== -1 || e.inArray(s, t) !== -1) && (r = r ? r.add(o) : o); else if (n) { if (w.verbose('Ambiguous dropdown value using strict type check', o, t), c === t || s === t) return r = o, !0; } else if (String(c) == String(t) || s == t) return w.verbose('Found select item by value', c, t), r = o, !0; }), r; },
        },
        check: { maxSelections(e) { return k.maxSelections ? (e = e !== i ? e : w.get.selectionCount(), e >= k.maxSelections ? (w.debug('Maximum selection count reached'), k.useLabels && (W.addClass(T.filtered), w.add.message(S.maxSelections)), !0) : (w.verbose('No longer at maximum selection count'), w.remove.message(), w.remove.filteredItem(), w.is.searchSelection() && w.filterItems(), !1)) : !0; } },
        restore: {
          defaults() { w.clear(), w.restore.defaultText(), w.restore.defaultValue(); }, defaultText() { const e = w.get.defaultText(); const t = w.get.placeholderText; e === t ? (w.debug('Restoring default placeholder text', e), w.set.placeholderText(e)) : (w.debug('Restoring default text', e), w.set.text(e)); }, defaultValue() { const e = w.get.defaultValue(); e !== i && (w.debug('Restoring default value', e), e !== '' ? (w.set.value(e), w.set.selected()) : (w.remove.activeItem(), w.remove.selectedItem())); }, labels() { k.allowAdditions && (k.useLabels || (w.error(F.labels), k.useLabels = !0), w.debug('Restoring selected values'), w.create.userLabels()), w.check.maxSelections(); }, selected() { w.restore.values(), w.is.multiple() ? (w.debug('Restoring previously selected values and labels'), w.restore.labels()) : w.debug('Restoring previously selected values'); }, values() { w.set.initialLoad(), k.apiSettings ? k.saveRemoteData ? w.restore.remoteValues() : w.clearValue() : w.set.selected(), w.remove.initialLoad(); }, remoteValues() { const t = w.get.remoteValues(); w.debug('Recreating selected from session data', t), t && (w.is.single() ? e.each(t, (e, t) => { w.set.text(t); }) : e.each(t, (e, t) => { w.add.label(e, t); })); },
        },
        read: { remoteData(e) { let n; return t.Storage === i ? void w.error(F.noStorage) : (n = sessionStorage.getItem(e), n !== i ? n : !1); } },
        save: {
          defaults() { w.save.defaultText(), w.save.placeholderText(), w.save.defaultValue(); }, defaultValue() { const e = w.get.value(); w.verbose('Saving default value as', e), I.data(D.defaultValue, e); }, defaultText() { const e = w.get.text(); w.verbose('Saving default text as', e), I.data(D.defaultText, e); }, placeholderText() { let e; k.placeholder !== !1 && N.hasClass(T.placeholder) && (e = w.get.text(), w.verbose('Saving placeholder text as', e), I.data(D.placeholderText, e)); }, remoteData(e, n) { return t.Storage === i ? void w.error(F.noStorage) : (w.verbose('Saving remote data to session storage', n, e), void sessionStorage.setItem(n, e)); },
        },
        clear() { w.is.multiple() ? w.remove.labels() : (w.remove.activeItem(), w.remove.selectedItem()), w.set.placeholderText(), w.clearValue(); },
        clearValue() { w.set.value(''); },
        scrollPage(e, t) { let n; let i; let o; const a = t || w.get.selectedItem(); const r = a.closest(P.menu); const s = r.outerHeight(); const c = r.scrollTop(); const l = W.eq(0).outerHeight(); const u = Math.floor(s / l); const d = (r.prop('scrollHeight'), e == 'up' ? c - l * u : c + l * u); const f = W.not(P.unselectable); o = e == 'up' ? f.index(a) - u : f.index(a) + u, n = e == 'up' ? o >= 0 : o < f.length, i = n ? f.eq(o) : e == 'up' ? f.first() : f.last(), i.length > 0 && (w.debug('Scrolling page', e, i), a.removeClass(T.selected), i.addClass(T.selected), r.scrollTop(d)); },
        set: {
          filtered() { const e = w.is.multiple(); const t = w.is.searchSelection(); const n = e && t; const i = t ? w.get.query() : ''; const o = typeof i === 'string' && i.length > 0; const a = w.get.searchWidth(i.length); const r = i !== ''; e && o && (w.verbose('Adjusting input width', a, k.glyphWidth), M.css('width', a)), o || n && r ? (w.verbose('Hiding placeholder text'), N.addClass(T.filtered)) : (!e || n && !r) && (w.verbose('Showing placeholder text'), N.removeClass(T.filtered)); }, loading() { I.addClass(T.loading); }, placeholderText(e) { e = e || w.get.placeholderText(), w.debug('Setting placeholder text', e), w.set.text(e), N.addClass(T.placeholder); }, tabbable() { w.has.search() ? (w.debug('Added tabindex to searchable dropdown'), M.val('').attr('tabindex', 0), U.attr('tabindex', -1)) : (w.debug('Added tabindex to dropdown'), I.attr('tabindex') || (I.attr('tabindex', 0), U.attr('tabindex', -1))); }, initialLoad() { w.verbose('Setting initial load'), h = !0; }, activeItem(e) { k.allowAdditions && e.filter(P.addition).length > 0 ? e.addClass(T.filtered) : e.addClass(T.active); }, scrollPosition(e, t) { let n; let o; let a; let r; let s; let c; let l; let u; let d; const f = 5; e = e || w.get.selectedItem(), n = e.closest(P.menu), o = e && e.length > 0, t = t !== i ? t : !1, e && n.length > 0 && o && (r = e.position().top, n.addClass(T.loading), c = n.scrollTop(), s = n.offset().top, r = e.offset().top, a = c - s + r, t || (l = n.height(), d = a + f > c + l, u = c > a - f), w.debug('Scrolling to active item', a), (t || u || d) && n.scrollTop(a), n.removeClass(T.loading)); }, text(e) { k.action !== 'select' && (k.action == 'combo' ? (w.debug('Changing combo button text', e, H), k.preserveHTML ? H.html(e) : H.text(e)) : (e !== w.get.placeholderText() && N.removeClass(T.placeholder), w.debug('Changing text', e, N), N.removeClass(T.filtered), k.preserveHTML ? N.html(e) : N.text(e))); }, selectedLetter(t) { let n; const i = W.filter(`.${T.selected}`); const o = i.length > 0 && w.has.firstLetter(i, t); let a = !1; o && (n = i.nextAll(W).eq(0), w.has.firstLetter(n, t) && (a = n)), a || W.each(function () { return w.has.firstLetter(e(this), t) ? (a = e(this), !1) : void 0; }), a && (w.verbose('Scrolling to next value with letter', t), w.set.scrollPosition(a), i.removeClass(T.selected), a.addClass(T.selected)); }, direction(e) { k.direction == 'auto' ? w.is.onScreen(e) ? w.remove.upward(e) : w.set.upward(e) : k.direction == 'upward' && w.set.upward(e); }, upward(e) { const t = e || I; t.addClass(T.upward); }, value(e, t, n) { const o = L.length > 0; const a = (!w.has.value(e), w.get.values()); const r = e !== i ? String(e) : e; if (o) { if (r == a && (w.verbose('Skipping value update already same value', e, a), !w.is.initialLoad())) return; w.is.single() && w.has.selectInput() && w.can.extendSelect() && (w.debug('Adding user option', e), w.add.optionValue(e)), w.debug('Updating input value', e, a), Q = !0, L.val(e), k.fireOnInit === !1 && w.is.initialLoad() ? w.debug('Input native change event ignored on initial load') : L.trigger('change'), Q = !1; } else w.verbose('Storing value in metadata', e, L), e !== a && I.data(D.value, r); k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose('No callback on initial load', k.onChange) : k.onChange.call(X, e, t, n); }, active() { I.addClass(T.active); }, multiple() { I.addClass(T.multiple); }, visible() { I.addClass(T.visible); }, exactly(e, t) { w.debug('Setting selected to exact values'), w.clear(), w.set.selected(e, t); }, selected(t, n) { const i = w.is.multiple(); n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t), n && (w.debug('Setting selected menu item to', n), w.is.single() ? (w.remove.activeItem(), w.remove.selectedItem()) : k.useLabels && w.remove.selectedItem(), n.each(function () { const t = e(this); const o = w.get.choiceText(t); const a = w.get.choiceValue(t, o); const r = t.hasClass(T.filtered); const s = t.hasClass(T.active); const c = t.hasClass(T.addition); const l = i && n.length == 1; i ? !s || c ? (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), k.useLabels ? (w.add.value(a, o, t), w.add.label(a, o, l), w.set.activeItem(t), w.filterActive(), w.select.nextAvailable(n)) : (w.add.value(a, o, t), w.set.text(w.add.variables(S.count)), w.set.activeItem(t))) : r || (w.debug('Selected active value, removing label'), w.remove.selected(a)) : (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), w.set.text(o), w.set.value(a, o, t), t.addClass(T.active).addClass(T.selected)); })); },
        },
        add: {
          label(t, n, i) {
            let o; const a = w.is.searchSelection() ? M : N; return o = e('<a />').addClass(T.label).attr('data-value', t).html(O.label(t, n)), o = k.onLabelCreate.call(o, t, n), w.has.label(t) ? void w.debug('Label already exists, skipping', t) : (k.label.variation && o.addClass(k.label.variation),
            void (i === !0 ? (w.debug('Animating in label', o), o.addClass(T.hidden).insertBefore(a).transition(k.label.transition, k.label.duration)) : (w.debug('Adding selection label', o), o.insertBefore(a))));
          },
          message(t) { let n = U.children(P.message); const i = k.templates.message(w.add.variables(t)); n.length > 0 ? n.html(i) : n = e('<div/>').html(i).addClass(T.message).appendTo(U); },
          optionValue(t) {
            const n = L.find(`option[value="${t}"]`); const i = n.length > 0; i || (x && (x.disconnect(), w.verbose('Temporarily disconnecting mutation observer', t)), w.is.single() && (w.verbose('Removing previous user addition'), L.find(`option.${T.addition}`).remove()), e('<option/>').prop('value', t).addClass(T.addition).html(t)
              .appendTo(L), w.verbose('Adding user addition as an <option>', t), x && x.observe(L[0], { childList: !0, subtree: !0 }));
          },
          userSuggestion(e) {
            let t; let n = U.children(P.addition); const i = w.get.item(e); const o = i && i.not(P.addition).length; const a = n.length > 0; if (!k.useLabels || !w.has.maxSelections()) {
              if (e === '' || o) return void n.remove(); W.removeClass(T.selected), a ? (t = k.templates.addition(w.add.variables(S.addResult, e)), n.html(t).attr(`data-${D.value}`, e).attr(`data-${D.text}`, e).removeClass(T.filtered)
                .addClass(T.selected), w.verbose('Replacing user suggestion with new value', n)) : (n = w.create.userChoice(e), n.prependTo(U).addClass(T.selected), w.verbose('Adding item choice to menu corresponding with user choice addition', n));
            }
          },
          variables(e, t) { let n; let i; const o = e.search('{count}') !== -1; const a = e.search('{maxCount}') !== -1; const r = e.search('{term}') !== -1; return w.verbose('Adding templated variables to message', e), o && (n = w.get.selectionCount(), e = e.replace('{count}', n)), a && (n = w.get.selectionCount(), e = e.replace('{maxCount}', k.maxSelections)), r && (i = t || w.get.query(), e = e.replace('{term}', i)), e; },
          value(t, n, i) { let o; const a = w.get.values(); return t === '' ? void w.debug('Cannot select blank values from multiselect') : (e.isArray(a) ? (o = a.concat([t]), o = w.get.uniqueArray(o)) : o = [t], w.has.selectInput() ? w.can.extendSelect() && (w.debug('Adding value to select', t, o, L), w.add.optionValue(t)) : (o = o.join(k.delimiter), w.debug('Setting hidden input to delimited value', o, L)), k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose('Skipping onadd callback on initial load', k.onAdd) : k.onAdd.call(X, t, n, i), w.set.value(o, t, n, i), void w.check.maxSelections()); },
        },
        remove: {
          active() { I.removeClass(T.active); }, activeLabel() { I.find(P.label).removeClass(T.active); }, loading() { I.removeClass(T.loading); }, initialLoad() { h = !1; }, upward(e) { const t = e || I; t.removeClass(T.upward); }, visible() { I.removeClass(T.visible); }, activeItem() { W.removeClass(T.active); }, filteredItem() { k.useLabels && w.has.maxSelections() || (k.useLabels && w.is.multiple() ? W.not(`.${T.active}`).removeClass(T.filtered) : W.removeClass(T.filtered)); }, optionValue(e) { const t = L.find(`option[value="${e}"]`); const n = t.length > 0; n && t.hasClass(T.addition) && (x && (x.disconnect(), w.verbose('Temporarily disconnecting mutation observer', e)), t.remove(), w.verbose('Removing user addition as an <option>', e), x && x.observe(L[0], { childList: !0, subtree: !0 })); }, message() { U.children(P.message).remove(); }, searchTerm() { w.verbose('Cleared search term'), M.val(''), w.set.filtered(); }, selected(t, n) { return (n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t)) ? void n.each(function () { const t = e(this); const n = w.get.choiceText(t); const i = w.get.choiceValue(t, n); w.is.multiple() ? k.useLabels ? (w.remove.value(i, n, t), w.remove.label(i)) : (w.remove.value(i, n, t), w.get.selectionCount() === 0 ? w.set.placeholderText() : w.set.text(w.add.variables(S.count))) : w.remove.value(i, n, t), t.removeClass(T.filtered).removeClass(T.active), k.useLabels && t.removeClass(T.selected); }) : !1; }, selectedItem() { W.removeClass(T.selected); }, value(e, t, n) { let i; const o = w.get.values(); w.has.selectInput() ? (w.verbose('Input is <select> removing selected option', e), i = w.remove.arrayValue(e, o), w.remove.optionValue(e)) : (w.verbose('Removing from delimited values', e), i = w.remove.arrayValue(e, o), i = i.join(k.delimiter)), k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose('No callback on initial load', k.onRemove) : k.onRemove.call(X, e, t, n), w.set.value(i, t, n), w.check.maxSelections(); }, arrayValue(t, n) { return e.isArray(n) || (n = [n]), n = e.grep(n, (e) => t != e), w.verbose('Removed value from delimited string', t, n), n; }, label(e, t) { const n = I.find(P.label); const i = n.filter(`[data-value="${e}"]`); w.verbose('Removing label', i), i.remove(); }, activeLabels(e) { e = e || I.find(P.label).filter(`.${T.active}`), w.verbose('Removing active label selections', e), w.remove.labels(e); }, labels(t) { t = t || I.find(P.label), w.verbose('Removing labels', t), t.each(function () { const t = e(this).data(D.value); const n = t !== i ? String(t) : t; const o = w.is.userValue(n); o ? (w.remove.value(n), w.remove.label(n)) : w.remove.selected(n); }); }, tabbable() { w.has.search() ? (w.debug('Searchable dropdown initialized'), M.attr('tabindex', '-1'), U.attr('tabindex', '-1')) : (w.debug('Simple selection dropdown initialized'), I.attr('tabindex', '-1'), U.attr('tabindex', '-1')); },
        },
        has: {
          search() { return M.length > 0; }, selectInput() { return L.is('select'); }, firstLetter(e, t) { let n; let i; return e && e.length !== 0 && typeof t === 'string' ? (n = w.get.choiceText(e, !1), t = t.toLowerCase(), i = String(n).charAt(0).toLowerCase(), t == i) : !1; }, input() { return L.length > 0; }, items() { return W.length > 0; }, menu() { return U.length > 0; }, message() { return U.children(P.message).length !== 0; }, label(e) { const t = I.find(P.label); return t.filter(`[data-value="${e}"]`).length > 0; }, maxSelections() { return k.maxSelections && w.get.selectionCount() >= k.maxSelections; }, allResultsFiltered() { return W.filter(P.unselectable).length === W.length; }, query() { return w.get.query() !== ''; }, value(t) { const n = w.get.values(); const i = e.isArray(n) ? n && e.inArray(t, n) !== -1 : n == t; return i ? !0 : !1; },
        },
        is: {
          active() { return I.hasClass(T.active); }, alreadySetup() { return I.is('select') && I.parent(P.dropdown).length > 0 && I.prev().length === 0; }, animating(e) { return e ? e.transition && e.transition('is animating') : U.transition && U.transition('is animating'); }, disabled() { return I.hasClass(T.disabled); }, focused() { return n.activeElement === I[0]; }, focusedOnSearch() { return n.activeElement === M[0]; }, allFiltered() { return (w.is.multiple() || w.has.search()) && !w.has.message() && w.has.allResultsFiltered(); }, hidden(e) { return !w.is.visible(e); }, initialLoad() { return h; }, onScreen(e) { let t; const n = e || U; let i = !0; let o = {}; return n.addClass(T.loading), t = { context: { scrollTop: z.scrollTop(), height: z.outerHeight() }, menu: { offset: n.offset(), height: n.outerHeight() } }, o = { above: t.context.scrollTop <= t.menu.offset.top - t.menu.height, below: t.context.scrollTop + t.context.height >= t.menu.offset.top + t.menu.height }, o.below ? (w.verbose('Dropdown can fit in context downward', o), i = !0) : o.below || o.above ? (w.verbose('Dropdown cannot fit below, opening upward', o), i = !1) : (w.verbose('Dropdown cannot fit in either direction, favoring downward', o), i = !0), n.removeClass(T.loading), i; }, inObject(t, n) { let i = !1; return e.each(n, (e, n) => (n == t ? (i = !0, !0) : void 0)), i; }, multiple() { return I.hasClass(T.multiple); }, single() { return !w.is.multiple(); }, selectMutation(t) { let n = !1; return e.each(t, (t, i) => (i.target && e(i.target).is('select') ? (n = !0, !0) : void 0)), n; }, search() { return I.hasClass(T.search); }, searchSelection() { return w.has.search() && M.parent(P.dropdown).length === 1; }, selection() { return I.hasClass(T.selection); }, userValue(t) { return e.inArray(t, w.get.userValues()) !== -1; }, upward(e) { const t = e || I; return t.hasClass(T.upward); }, visible(e) { return e ? e.hasClass(T.visible) : U.hasClass(T.visible); },
        },
        can: {
          activate(e) { return k.useLabels ? !0 : w.has.maxSelections() ? w.has.maxSelections() && e.hasClass(T.active) ? !0 : !1 : !0; }, click() { return l || k.on == 'click'; }, extendSelect() { return k.allowAdditions || k.apiSettings; }, show() { return !w.is.disabled() && (w.has.items() || w.has.message()); }, useAPI() { return e.fn.api !== i; },
        },
        animate: {
          show(t, n) {
            let o; const a = n || U; const r = n ? function () {} : function () { w.hideSubMenus(), w.hideOthers(), w.set.active(); }; t = e.isFunction(t) ? t : function () {}, w.verbose('Doing menu show animation', a), w.set.direction(n), o = w.get.transition(n), w.is.selection() && w.set.scrollPosition(w.get.selectedItem(), !0), (w.is.hidden(a) || w.is.animating(a)) && (o == 'none' ? (r(), a.transition('show'), t.call(X)) : e.fn.transition !== i && I.transition('is supported') ? a.transition({
              animation: `${o} in`, debug: k.debug, verbose: k.verbose, duration: k.duration, queue: !0, onStart: r, onComplete() { t.call(X); },
            }) : w.error(F.noTransition, o));
          },
          hide(t, n) {
            const o = n || U; const a = (n ? 0.9 * k.duration : k.duration, n ? function () {} : function () { w.can.click() && w.unbind.intent(), w.remove.active(); }); const r = w.get.transition(n); t = e.isFunction(t) ? t : function () {}, (w.is.visible(o) || w.is.animating(o)) && (w.verbose('Doing menu hide animation', o), r == 'none' ? (a(), o.transition('hide'), t.call(X)) : e.fn.transition !== i && I.transition('is supported') ? o.transition({
              animation: `${r} out`, duration: k.duration, debug: k.debug, verbose: k.verbose, queue: !0, onStart: a, onComplete() { k.direction == 'auto' && w.remove.upward(n), t.call(X); },
            }) : w.error(F.transition));
          },
        },
        hideAndClear() { w.remove.searchTerm(), w.has.maxSelections() || (w.has.search() ? w.hide(() => { w.remove.filteredItem(); }) : w.hide()); },
        delay: { show() { w.verbose('Delaying show event to ensure user intent'), clearTimeout(w.timer), w.timer = setTimeout(w.show, k.delay.show); }, hide() { w.verbose('Delaying hide event to ensure user intent'), clearTimeout(w.timer), w.timer = setTimeout(w.hide, k.delay.hide); } },
        escape: { regExp(e) { return e = String(e), e.replace(E.escape, '\\$&'); } },
        setting(t, n) { if (w.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, k, t); else { if (n === i) return k[t]; k[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, w, t); else { if (n === i) return w[t]; w[t] = n; } },
        debug() { k.debug && (k.performance ? w.performance.log(arguments) : (w.debug = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.debug.apply(console, arguments))); },
        verbose() { k.verbose && k.debug && (k.performance ? w.performance.log(arguments) : (w.verbose = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.verbose.apply(console, arguments))); },
        error() { w.error = Function.prototype.bind.call(console.error, console, `${k.name}:`), w.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; k.performance && (t = (new Date()).getTime(), i = u || t, n = t - i, u = t, d.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: X, 'Execution Time': n,
            })), clearTimeout(w.performance.timer), w.performance.timer = setTimeout(w.performance.display, 500);
          },
          display() { let t = `${k.name}:`; let n = 0; u = !1, clearTimeout(w.performance.timer), e.each(d, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, c && (t += ` '${c}'`), (console.group !== i || console.table !== i) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), d = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = $; return n = n || g, o = X || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (w.error(F.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, m ? ($ === i && w.initialize(), w.invoke(f)) : ($ !== i && $.invoke('destroy'), w.initialize());
    }), a !== i ? a : r;
  }, e.fn.dropdown.settings = {
    debug: !1,
    verbose: !1,
    performance: !0,
    on: 'click',
    action: 'activate',
    apiSettings: !1,
    saveRemoteData: !0,
    throttle: 200,
    context: t,
    direction: 'auto',
    keepOnScreen: !0,
    match: 'both',
    fullTextSearch: !1,
    placeholder: 'auto',
    preserveHTML: !0,
    sortSelect: !1,
    forceSelection: !0,
    allowAdditions: !1,
    maxSelections: !1,
    useLabels: !0,
    delimiter: ',',
    showOnFocus: !0,
    allowTab: !0,
    allowCategorySelection: !1,
    fireOnInit: !1,
    transition: 'auto',
    duration: 200,
    glyphWidth: 1.0714,
    label: { transition: 'scale', duration: 200, variation: !1 },
    delay: {
      hide: 300, show: 200, search: 20, touch: 50,
    },
    onChange(e, t, n) {},
    onAdd(e, t, n) {},
    onRemove(e, t, n) {},
    onLabelSelect(e) {},
    onLabelCreate(t, n) { return e(this); },
    onNoResults(e) { return !0; },
    onShow() {},
    onHide() {},
    name: 'Dropdown',
    namespace: 'dropdown',
    message: {
      addResult: 'Add <b>{term}</b>', count: '{count} selected', maxSelections: 'Max {maxCount} selections', noResults: 'No results found.', serverError: 'There was an error contacting the server',
    },
    error: {
      action: 'You called a dropdown action that was not defined', alreadySetup: 'Once a select has been initialized behaviors must be called on the created ui dropdown', labels: 'Allowing user additions currently requires the use of labels.', missingMultiple: '<select> requires multiple property to be set to correctly preserve multiple values', method: 'The method you called is not defined.', noAPI: 'The API module is required to load resources remotely', noStorage: 'Saving remote data requires session storage', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
    },
    regExp: { escape: /[-[\]{}()*+?.,\\^$|#\s]/g },
    metadata: {
      defaultText: 'defaultText', defaultValue: 'defaultValue', placeholderText: 'placeholder', text: 'text', value: 'value',
    },
    fields: { values: 'values', name: 'name', value: 'value' },
    selector: {
      addition: '.addition', dropdown: '.ui.dropdown', icon: '> .dropdown.icon', input: '> input[type="hidden"], > select', item: '.item', label: '> .label', remove: '> .label > .delete.icon', siblingLabel: '.label', menu: '.menu', message: '.message', menuIcon: '.dropdown.icon', search: 'input.search, .menu > .search > input', text: '> .text:not(.icon)', unselectable: '.disabled, .filtered',
    },
    className: {
      active: 'active', addition: 'addition', animating: 'animating', disabled: 'disabled', dropdown: 'ui dropdown', filtered: 'filtered', hidden: 'hidden transition', item: 'item', label: 'ui label', loading: 'loading', menu: 'menu', message: 'message', multiple: 'multiple', placeholder: 'default', search: 'search', selected: 'selected', selection: 'selection', upward: 'upward', visible: 'visible',
    },
  }, e.fn.dropdown.settings.templates = {
    dropdown(t) { const n = t.placeholder || !1; let i = (t.values || {}, ''); return i += '<i class="dropdown icon"></i>', i += t.placeholder ? `<div class="default text">${n}</div>` : '<div class="text"></div>', i += '<div class="menu">', e.each(t.values, (e, t) => { i += t.disabled ? `<div class="disabled item" data-value="${t.value}">${t.name}</div>` : `<div class="item" data-value="${t.value}">${t.name}</div>`; }), i += '</div>'; }, menu(t, n) { let i = (t.values || {}, ''); return e.each(t[n.values], (e, t) => { i += `<div class="item" data-value="${t[n.value]}">${t[n.name]}</div>`; }), i; }, label(e, t) { return `${t}<i class="delete icon"></i>`; }, message(e) { return e; }, addition(e) { return e; },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.embed = function (n) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let f; const m = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.embed.settings, n) : e.extend({}, e.fn.embed.settings); const g = m.selector; const p = m.className; const h = m.sources; const v = m.error; const b = m.metadata; const y = m.namespace; const x = m.templates; const C = `.${y}`; const w = `module-${y}`; const k = (e(t), e(this)); let T = k.find(g.placeholder); let S = k.find(g.icon); let A = k.find(g.embed); const D = this; let R = k.data(w); f = {
        initialize() { f.debug('Initializing embed'), f.determine.autoplay(), f.create(), f.bind.events(), f.instantiate(); },
        instantiate() { f.verbose('Storing instance of module', f), R = f, k.data(w, f); },
        destroy() { f.verbose('Destroying previous instance of embed'), f.reset(), k.removeData(w).off(C); },
        refresh() { f.verbose('Refreshing selector cache'), T = k.find(g.placeholder), S = k.find(g.icon), A = k.find(g.embed); },
        bind: { events() { f.has.placeholder() && (f.debug('Adding placeholder events'), k.on(`click${C}`, g.placeholder, f.createAndShow).on(`click${C}`, g.icon, f.createAndShow)); } },
        create() { const e = f.get.placeholder(); e ? f.createPlaceholder() : f.createAndShow(); },
        createPlaceholder(e) { const t = f.get.icon(); const n = f.get.url(); f.generate.embed(n); e = e || f.get.placeholder(), k.html(x.placeholder(e, t)), f.debug('Creating placeholder for embed', e, t); },
        createEmbed(t) { f.refresh(), t = t || f.get.url(), A = e('<div/>').addClass(p.embed).html(f.generate.embed(t)).appendTo(k), m.onCreate.call(D, t), f.debug('Creating embed object', A); },
        createAndShow() { f.createEmbed(), f.show(); },
        change(e, t, n) { f.debug('Changing video to ', e, t, n), k.data(b.source, e).data(b.id, t).data(b.url, n), f.create(); },
        reset() { f.debug('Clearing embed and showing placeholder'), f.remove.active(), f.remove.embed(), f.showPlaceholder(), m.onReset.call(D); },
        show() { f.debug('Showing embed'), f.set.active(), m.onDisplay.call(D); },
        hide() { f.debug('Hiding embed'), f.showPlaceholder(); },
        showPlaceholder() { f.debug('Showing placeholder image'), f.remove.active(), m.onPlaceholderDisplay.call(D); },
        get: {
          id() { return m.id || k.data(b.id); }, placeholder() { return m.placeholder || k.data(b.placeholder); }, icon() { return m.icon ? m.icon : k.data(b.icon) !== i ? k.data(b.icon) : f.determine.icon(); }, source(e) { return m.source ? m.source : k.data(b.source) !== i ? k.data(b.source) : f.determine.source(); }, type() { const e = f.get.source(); return h[e] !== i ? h[e].type : !1; }, url() { return m.url ? m.url : k.data(b.url) !== i ? k.data(b.url) : f.determine.url(); },
        },
        determine: {
          autoplay() { f.should.autoplay() && (m.autoplay = !0); }, source(t) { let n = !1; return t = t || f.get.url(), t && e.each(h, (e, i) => (t.search(i.domain) !== -1 ? (n = e, !1) : void 0)), n; }, icon() { const e = f.get.source(); return h[e] !== i ? h[e].icon : !1; }, url() { let e; const t = m.id || k.data(b.id); const n = m.source || k.data(b.source); return e = h[n] !== i ? h[n].url.replace('{id}', t) : !1, e && k.data(b.url, e), e; },
        },
        set: { active() { k.addClass(p.active); } },
        remove: { active() { k.removeClass(p.active); }, embed() { A.empty(); } },
        encode: { parameters(e) { let t; const n = []; for (t in e)n.push(`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`); return n.join('&amp;'); } },
        generate: { embed(e) { f.debug('Generating embed html'); let t; let n; const i = f.get.source(); return e = f.get.url(e), e ? (n = f.generate.parameters(i), t = x.iframe(e, n)) : f.error(v.noURL, k), t; }, parameters(t, n) { let o = h[t] && h[t].parameters !== i ? h[t].parameters(m) : {}; return n = n || m.parameters, n && (o = e.extend({}, o, n)), o = m.onEmbed(o), f.encode.parameters(o); } },
        has: { placeholder() { return m.placeholder || k.data(b.placeholder); } },
        should: { autoplay() { return m.autoplay === 'auto' ? m.placeholder || k.data(b.placeholder) !== i : m.autoplay; } },
        is: { video() { return f.get.type() == 'video'; } },
        setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        debug() { m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
        error() { f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), a.length > 1 && (t += ` (${a.length})`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = R; return n = n || d, a = D || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (f.error(v.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, u ? (R === i && f.initialize(), f.invoke(l)) : (R !== i && R.invoke('destroy'), f.initialize());
    }), o !== i ? o : this;
  }, e.fn.embed.settings = {
    name: 'Embed',
    namespace: 'embed',
    debug: !1,
    verbose: !1,
    performance: !0,
    icon: !1,
    source: !1,
    url: !1,
    id: !1,
    autoplay: 'auto',
    color: '#444444',
    hd: !0,
    brandedUI: !1,
    parameters: !1,
    onDisplay() {},
    onPlaceholderDisplay() {},
    onReset() {},
    onCreate(e) {},
    onEmbed(e) { return e; },
    metadata: {
      id: 'id', icon: 'icon', placeholder: 'placeholder', source: 'source', url: 'url',
    },
    error: { noURL: 'No URL specified', method: 'The method you called is not defined' },
    className: { active: 'active', embed: 'embed' },
    selector: { embed: '.embed', placeholder: '.placeholder', icon: '.icon' },
    sources: {
      youtube: {
        name: 'youtube',
        type: 'video',
        icon: 'video play',
        domain: 'youtube.com',
        url: '//www.youtube.com/embed/{id}',
        parameters(e) {
          return {
            autohide: !e.brandedUI, autoplay: e.autoplay, color: e.colors || i, hq: e.hd, jsapi: e.api, modestbranding: !e.brandedUI,
          };
        },
      },
      vimeo: {
        name: 'vimeo',
        type: 'video',
        icon: 'video play',
        domain: 'vimeo.com',
        url: '//player.vimeo.com/video/{id}',
        parameters(e) {
          return {
            api: e.api, autoplay: e.autoplay, byline: e.brandedUI, color: e.colors || i, portrait: e.brandedUI, title: e.brandedUI,
          };
        },
      },
    },
    templates: { iframe(e, t) { return `<iframe src="${e}?${t}" width="100%" height="100%" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`; }, placeholder(e, t) { let n = ''; return t && (n += `<i class="${t} icon"></i>`), e && (n += `<img class="placeholder" src="${e}">`), n; } },
    api: !0,
    onPause() {},
    onPlay() {},
    onStop() {},
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.modal = function (o) {
    let a; const r = e(this); const s = e(t); const c = e(n); const l = e('body'); const u = r.selector || ''; let d = (new Date()).getTime(); let f = []; const m = arguments[0]; const g = typeof m === 'string'; const p = [].slice.call(arguments, 1); const h = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return r.each(function () {
      let r; let v; let b; let y; let x; let C; let w; let k; let T; const S = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.modal.settings, o) : e.extend({}, e.fn.modal.settings); const A = S.selector; const D = S.className; const R = S.namespace; const E = S.error; const P = `.${R}`; const F = `module-${R}`; const O = e(this); const q = e(S.context); const j = O.find(A.close); const I = this; let z = O.data(F); T = {
        initialize() { T.verbose('Initializing dimmer', q), T.create.id(), T.create.dimmer(), T.refreshModals(), T.bind.events(), S.observeChanges && T.observeChanges(), T.instantiate(); },
        instantiate() { T.verbose('Storing instance of modal'), z = T, O.data(F, z); },
        create: { dimmer() { const t = { debug: S.debug, dimmerName: 'modals', duration: { show: S.duration, hide: S.duration } }; const n = e.extend(!0, t, S.dimmerSettings); return S.inverted && (n.variation = n.variation !== i ? `${n.variation} inverted` : 'inverted'), e.fn.dimmer === i ? void T.error(E.dimmer) : (T.debug('Creating dimmer with settings', n), y = q.dimmer(n), S.detachable ? (T.verbose('Modal is detachable, moving content into dimmer'), y.dimmer('add content', O)) : T.set.undetached(), S.blurring && y.addClass(D.blurring), void (x = y.dimmer('get dimmer'))); }, id() { w = (`${Math.random().toString(16)}000000000`).substr(2, 8), C = `.${w}`, T.verbose('Creating unique id for element', w); } },
        destroy() { T.verbose('Destroying previous modal'), O.removeData(F).off(P), s.off(C), j.off(P), q.dimmer('destroy'); },
        observeChanges() { 'MutationObserver' in t && (k = new MutationObserver((e) => { T.debug('DOM tree modified, refreshing'), T.refresh(); }), k.observe(I, { childList: !0, subtree: !0 }), T.debug('Setting up mutation observer', k)); },
        refresh() { T.remove.scrolling(), T.cacheSizes(), T.set.screenHeight(), T.set.type(), T.set.position(); },
        refreshModals() { v = O.siblings(A.modal), r = v.add(O); },
        attachEvents(t, n) { const i = e(t); n = e.isFunction(T[n]) ? T[n] : T.toggle, i.length > 0 ? (T.debug('Attaching modal events to element', t, n), i.off(P).on(`click${P}`, n)) : T.error(E.notFound, t); },
        bind: { events() { T.verbose('Attaching events'), O.on(`click${P}`, A.close, T.event.close).on(`click${P}`, A.approve, T.event.approve).on(`click${P}`, A.deny, T.event.deny), s.on(`resize${C}`, T.event.resize); } },
        get: { id() { return (`${Math.random().toString(16)}000000000`).substr(2, 8); } },
        event: {
          approve() { return S.onApprove.call(I, e(this)) === !1 ? void T.verbose('Approve callback returned false cancelling hide') : void T.hide(); }, deny() { return S.onDeny.call(I, e(this)) === !1 ? void T.verbose('Deny callback returned false cancelling hide') : void T.hide(); }, close() { T.hide(); }, click(t) { const i = e(t.target); const o = i.closest(A.modal).length > 0; const a = e.contains(n.documentElement, t.target); !o && a && (T.debug('Dimmer clicked, hiding all modals'), T.is.active() && (T.remove.clickaway(), S.allowMultiple ? T.hide() : T.hideAll())); }, debounce(e, t) { clearTimeout(T.timer), T.timer = setTimeout(e, t); }, keyboard(e) { const t = e.which; const n = 27; t == n && (S.closable ? (T.debug('Escape key pressed hiding modal'), T.hide()) : T.debug('Escape key pressed, but closable is set to false'), e.preventDefault()); }, resize() { y.dimmer('is active') && h(T.refresh); },
        },
        toggle() { T.is.active() || T.is.animating() ? T.hide() : T.show(); },
        show(t) { t = e.isFunction(t) ? t : function () {}, T.refreshModals(), T.showModal(t); },
        hide(t) { t = e.isFunction(t) ? t : function () {}, T.refreshModals(), T.hideModal(t); },
        showModal(t) {
          t = e.isFunction(t) ? t : function () {}, T.is.animating() || !T.is.active() ? (T.showDimmer(), T.cacheSizes(), T.set.position(), T.set.screenHeight(), T.set.type(), T.set.clickaway(), !S.allowMultiple && T.others.active() ? T.hideOthers(T.showModal) : (S.onShow.call(I), S.transition && e.fn.transition !== i && O.transition('is supported') ? (T.debug('Showing modal with css animations'), O.transition({
            debug: S.debug, animation: `${S.transition} in`, queue: S.queue, duration: S.duration, useFailSafe: !0, onComplete() { S.onVisible.apply(I), T.add.keyboardShortcuts(), T.save.focus(), T.set.active(), S.autofocus && T.set.autofocus(), t(); },
          })) : T.error(E.noTransition))) : T.debug('Modal is already visible');
        },
        hideModal(t, n) {
          return t = e.isFunction(t) ? t : function () {}, T.debug('Hiding modal'), S.onHide.call(I, e(this)) === !1 ? void T.verbose('Hide callback returned false cancelling hide') : void ((T.is.animating() || T.is.active()) && (S.transition && e.fn.transition !== i && O.transition('is supported') ? (T.remove.active(), O.transition({
            debug: S.debug, animation: `${S.transition} out`, queue: S.queue, duration: S.duration, useFailSafe: !0, onStart() { T.others.active() || n || T.hideDimmer(), T.remove.keyboardShortcuts(); }, onComplete() { S.onHidden.call(I), T.restore.focus(), t(); },
          })) : T.error(E.noTransition)));
        },
        showDimmer() { y.dimmer('is animating') || !y.dimmer('is active') ? (T.debug('Showing dimmer'), y.dimmer('show')) : T.debug('Dimmer already visible'); },
        hideDimmer() { return y.dimmer('is animating') || y.dimmer('is active') ? void y.dimmer('hide', () => { T.remove.clickaway(), T.remove.screenHeight(); }) : void T.debug('Dimmer is not visible cannot hide'); },
        hideAll(t) { const n = r.filter(`.${D.active}, .${D.animating}`); t = e.isFunction(t) ? t : function () {}, n.length > 0 && (T.debug('Hiding all visible modals'), T.hideDimmer(), n.modal('hide modal', t)); },
        hideOthers(t) { const n = v.filter(`.${D.active}, .${D.animating}`); t = e.isFunction(t) ? t : function () {}, n.length > 0 && (T.debug('Hiding other modals', v), n.modal('hide modal', t, !0)); },
        others: { active() { return v.filter(`.${D.active}`).length > 0; }, animating() { return v.filter(`.${D.animating}`).length > 0; } },
        add: { keyboardShortcuts() { T.verbose('Adding keyboard shortcuts'), c.on(`keyup${P}`, T.event.keyboard); } },
        save: { focus() { b = e(n.activeElement).blur(); } },
        restore: { focus() { b && b.length > 0 && b.focus(); } },
        remove: {
          active() { O.removeClass(D.active); }, clickaway() { S.closable && x.off(`click${C}`); }, bodyStyle() { l.attr('style') === '' && (T.verbose('Removing style attribute'), l.removeAttr('style')); }, screenHeight() { T.debug('Removing page height'), l.css('height', ''); }, keyboardShortcuts() { T.verbose('Removing keyboard shortcuts'), c.off(`keyup${P}`); }, scrolling() { y.removeClass(D.scrolling), O.removeClass(D.scrolling); },
        },
        cacheSizes() { const o = O.outerHeight(); (T.cache === i || o !== 0) && (T.cache = { pageHeight: e(n).outerHeight(), height: o + S.offset, contextHeight: S.context == 'body' ? e(t).height() : y.height() }), T.debug('Caching modal and container sizes', T.cache); },
        can: { fit() { return T.cache.height + 2 * S.padding < T.cache.contextHeight; } },
        is: {
          active() { return O.hasClass(D.active); }, animating() { return O.transition('is supported') ? O.transition('is animating') : O.is(':visible'); }, scrolling() { return y.hasClass(D.scrolling); }, modernBrowser() { return !(t.ActiveXObject || 'ActiveXObject' in t); },
        },
        set: {
          autofocus() { const e = O.find(':input').filter(':visible'); const t = e.filter('[autofocus]'); const n = t.length > 0 ? t.first() : e.first(); n.length > 0 && n.focus(); }, clickaway() { S.closable && x.on(`click${C}`, T.event.click); }, screenHeight() { T.can.fit() ? l.css('height', '') : (T.debug('Modal is taller than page content, resizing page height'), l.css('height', T.cache.height + 2 * S.padding)); }, active() { O.addClass(D.active); }, scrolling() { y.addClass(D.scrolling), O.addClass(D.scrolling); }, type() { T.can.fit() ? (T.verbose('Modal fits on screen'), T.others.active() || T.others.animating() || T.remove.scrolling()) : (T.verbose('Modal cannot fit on screen setting to scrolling'), T.set.scrolling()); }, position() { T.verbose('Centering modal on page', T.cache), T.can.fit() ? O.css({ top: '', marginTop: -(T.cache.height / 2) }) : O.css({ marginTop: '', top: c.scrollTop() }); }, undetached() { y.addClass(D.undetached); },
        },
        setting(t, n) { if (T.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, S, t); else { if (n === i) return S[t]; S[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, T, t); else { if (n === i) return T[t]; T[t] = n; } },
        debug() { S.debug && (S.performance ? T.performance.log(arguments) : (T.debug = Function.prototype.bind.call(console.info, console, `${S.name}:`), T.debug.apply(console, arguments))); },
        verbose() { S.verbose && S.debug && (S.performance ? T.performance.log(arguments) : (T.verbose = Function.prototype.bind.call(console.info, console, `${S.name}:`), T.verbose.apply(console, arguments))); },
        error() { T.error = Function.prototype.bind.call(console.error, console, `${S.name}:`), T.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; S.performance && (t = (new Date()).getTime(), i = d || t, n = t - i, d = t, f.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: I, 'Execution Time': n,
            })), clearTimeout(T.performance.timer), T.performance.timer = setTimeout(T.performance.display, 500);
          },
          display() { let t = `${S.name}:`; let n = 0; d = !1, clearTimeout(T.performance.timer), e.each(f, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, u && (t += ` '${u}'`), (console.group !== i || console.table !== i) && f.length > 0 && (console.groupCollapsed(t), console.table ? console.table(f) : e.each(f, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), f = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = z; return n = n || p, o = I || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, g ? (z === i && T.initialize(), T.invoke(m)) : (z !== i && z.invoke('destroy'),
      T.initialize());
    }), a !== i ? a : this;
  }, e.fn.modal.settings = {
    name: 'Modal',
    namespace: 'modal',
    debug: !1,
    verbose: !1,
    performance: !0,
    observeChanges: !1,
    allowMultiple: !1,
    detachable: !0,
    closable: !0,
    autofocus: !0,
    inverted: !1,
    blurring: !1,
    dimmerSettings: { closable: !1, useCSS: !0 },
    context: 'body',
    queue: !1,
    duration: 500,
    offset: 0,
    transition: 'scale',
    padding: 50,
    onShow() {},
    onVisible() {},
    onHide() { return !0; },
    onHidden() {},
    onApprove() { return !0; },
    onDeny() { return !0; },
    selector: {
      close: '> .close', approve: '.actions .positive, .actions .approve, .actions .ok', deny: '.actions .negative, .actions .deny, .actions .cancel', modal: '.ui.modal',
    },
    error: { dimmer: 'UI Dimmer, a required component is not included in this page', method: 'The method you called is not defined.', notFound: 'The element you specified could not be found' },
    className: {
      active: 'active', animating: 'animating', blurring: 'blurring', scrolling: 'scrolling', undetached: 'undetached',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.nag = function (n) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; const f = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.nag.settings, n) : e.extend({}, e.fn.nag.settings); const m = (f.className, f.selector); const g = f.error; const p = f.namespace; const h = `.${p}`; const v = `${p}-module`; const b = e(this); const y = (b.find(m.close), e(f.context ? f.context : 'body')); const x = this; const C = b.data(v); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; a = {
        initialize() { a.verbose('Initializing element'), b.on(`click${h}`, m.close, a.dismiss).data(v, a), f.detachable && b.parent()[0] !== y[0] && b.detach().prependTo(y), f.displayTime > 0 && setTimeout(a.hide, f.displayTime), a.show(); },
        destroy() { a.verbose('Destroying instance'), b.removeData(v).off(h); },
        show() { a.should.show() && !b.is(':visible') && (a.debug('Showing nag', f.animation.show), f.animation.show == 'fade' ? b.fadeIn(f.duration, f.easing) : b.slideDown(f.duration, f.easing)); },
        hide() { a.debug('Showing nag', f.animation.hide), f.animation.show == 'fade' ? b.fadeIn(f.duration, f.easing) : b.slideUp(f.duration, f.easing); },
        onHide() { a.debug('Removing nag', f.animation.hide), b.remove(), f.onHide && f.onHide(); },
        dismiss(e) { f.storageMethod && a.storage.set(f.key, f.value), a.hide(), e.stopImmediatePropagation(), e.preventDefault(); },
        should: { show() { return f.persist ? (a.debug('Persistent nag is set, can show nag'), !0) : a.storage.get(f.key) != f.value.toString() ? (a.debug('Stored value is not set, can show nag', a.storage.get(f.key)), !0) : (a.debug('Stored value is set, cannot show nag', a.storage.get(f.key)), !1); } },
        get: { storageOptions() { const e = {}; return f.expires && (e.expires = f.expires), f.domain && (e.domain = f.domain), f.path && (e.path = f.path), e; } },
        clear() { a.storage.remove(f.key); },
        storage: { set(n, o) { const r = a.get.storageOptions(); if (f.storageMethod == 'localstorage' && t.localStorage !== i)t.localStorage.setItem(n, o), a.debug('Value stored using local storage', n, o); else if (f.storageMethod == 'sessionstorage' && t.sessionStorage !== i)t.sessionStorage.setItem(n, o), a.debug('Value stored using session storage', n, o); else { if (e.cookie === i) return void a.error(g.noCookieStorage); e.cookie(n, o, r), a.debug('Value stored using cookie', n, o, r); } }, get(n, o) { let r; return f.storageMethod == 'localstorage' && t.localStorage !== i ? r = t.localStorage.getItem(n) : f.storageMethod == 'sessionstorage' && t.sessionStorage !== i ? r = t.sessionStorage.getItem(n) : e.cookie !== i ? r = e.cookie(n) : a.error(g.noCookieStorage), (r == 'undefined' || r == 'null' || r === i || r === null) && (r = i), r; }, remove(n) { const o = a.get.storageOptions(); f.storageMethod == 'localstorage' && t.localStorage !== i ? t.localStorage.removeItem(n) : f.storageMethod == 'sessionstorage' && t.sessionStorage !== i ? t.sessionStorage.removeItem(n) : e.cookie !== i ? e.removeCookie(n, o) : a.error(g.noStorage); } },
        setting(t, n) { if (a.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, a, t); else { if (n === i) return a[t]; a[t] = n; } },
        debug() { f.debug && (f.performance ? a.performance.log(arguments) : (a.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), a.debug.apply(console, arguments))); },
        verbose() { f.verbose && f.debug && (f.performance ? a.performance.log(arguments) : (a.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), a.verbose.apply(console, arguments))); },
        error() { a.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), a.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: x, 'Execution Time': n,
            })), clearTimeout(a.performance.timer), a.performance.timer = setTimeout(a.performance.display, 500);
          },
          display() { let t = `${f.name}:`; let n = 0; s = !1, clearTimeout(a.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, r) { let s; let c; let l; let u = C; return n = n || d, r = x || r, typeof t === 'string' && u !== i && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, (n, o) => { const r = n != s ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(u[r]) && n != s)u = u[r]; else { if (u[r] !== i) return c = u[r], !1; if (!e.isPlainObject(u[o]) || n == s) return u[o] !== i ? (c = u[o], !1) : (a.error(g.method, t), !1); u = u[o]; } })), e.isFunction(c) ? l = c.apply(r, n) : c !== i && (l = c), e.isArray(o) ? o.push(l) : o !== i ? o = [o, l] : l !== i && (o = l), c; },
      }, u ? (C === i && a.initialize(), a.invoke(l)) : (C !== i && C.invoke('destroy'), a.initialize());
    }), o !== i ? o : this;
  }, e.fn.nag.settings = {
    name: 'Nag', debug: !1, verbose: !1, performance: !0, namespace: 'Nag', persist: !1, displayTime: 0, animation: { show: 'slide', hide: 'slide' }, context: !1, detachable: !1, expires: 30, domain: !1, path: '/', storageMethod: 'cookie', key: 'nag', value: 'dismiss', error: { noCookieStorage: '$.cookie is not included. A storage solution is required.', noStorage: 'Neither $.cookie or store is defined. A storage solution is required for storing state', method: 'The method you called is not defined.' }, className: { bottom: 'bottom', fixed: 'fixed' }, selector: { close: '.close.icon' }, speed: 500, easing: 'easeOutQuad', onHide() {},
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.popup = function (o) {
    let a; const r = e(this); const s = e(n); const c = e(t); const l = e('body'); const u = r.selector || ''; const d = !0; let f = (new Date()).getTime(); let m = []; const g = arguments[0]; const p = typeof g === 'string'; const h = [].slice.call(arguments, 1); return r.each(function () {
      let n; let r; let v; let b; let y; const x = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.popup.settings, o) : e.extend({}, e.fn.popup.settings); const C = x.selector; const w = x.className; const k = x.error; const T = x.metadata; const S = x.namespace; const A = `.${x.namespace}`; const D = `module-${S}`; const R = e(this); const E = e(x.context); const P = x.target ? e(x.target) : R; let F = 0; let O = !1; let q = !1; const j = this; let I = R.data(D); y = {
        initialize() { y.debug('Initializing', R), y.createID(), y.bind.events(), !y.exists() && x.preserve && y.create(), y.instantiate(); },
        instantiate() { y.verbose('Storing instance', y), I = y, R.data(D, I); },
        refresh() { x.popup ? n = e(x.popup).eq(0) : x.inline && (n = P.nextAll(C.popup).eq(0), x.popup = n), x.popup ? (n.addClass(w.loading), r = y.get.offsetParent(), n.removeClass(w.loading), x.movePopup && y.has.popup() && y.get.offsetParent(n)[0] !== r[0] && (y.debug('Moving popup to the same offset parent as activating element'), n.detach().appendTo(r))) : r = x.inline ? y.get.offsetParent(P) : y.has.popup() ? y.get.offsetParent(n) : l, r.is('html') && r[0] !== l[0] && (y.debug('Setting page as offset parent'), r = l), y.get.variation() && y.set.variation(); },
        reposition() { y.refresh(), y.set.position(); },
        destroy() { y.debug('Destroying previous module'), n && !x.preserve && y.removePopup(), clearTimeout(y.hideTimer), clearTimeout(y.showTimer), c.off(v), R.off(A).removeData(D); },
        event: {
          start(t) { const n = e.isPlainObject(x.delay) ? x.delay.show : x.delay; clearTimeout(y.hideTimer), q || (y.showTimer = setTimeout(y.show, n)); }, end() { const t = e.isPlainObject(x.delay) ? x.delay.hide : x.delay; clearTimeout(y.showTimer), y.hideTimer = setTimeout(y.hide, t); }, touchstart(e) { q = !0, y.show(); }, resize() { y.is.visible() && y.set.position(); }, hideGracefully(t) { t && e(t.target).closest(C.popup).length === 0 ? (y.debug('Click occurred outside popup hiding popup'), y.hide()) : y.debug('Click was inside popup, keeping popup open'); },
        },
        create() { let t = y.get.html(); const i = y.get.title(); const o = y.get.content(); t || o || i ? (y.debug('Creating pop-up html'), t || (t = x.templates.popup({ title: i, content: o })), n = e('<div/>').addClass(w.popup).data(T.activator, R).html(t), x.inline ? (y.verbose('Inserting popup element inline', n), n.insertAfter(R)) : (y.verbose('Appending popup element to body', n), n.appendTo(E)), y.refresh(), y.set.variation(), x.hoverable && y.bind.popup(), x.onCreate.call(n, j)) : P.next(C.popup).length !== 0 ? (y.verbose('Pre-existing popup found'), x.inline = !0, x.popups = P.next(C.popup).data(T.activator, R), y.refresh(), x.hoverable && y.bind.popup()) : x.popup ? (e(x.popup).data(T.activator, R), y.verbose('Used popup specified in settings'), y.refresh(), x.hoverable && y.bind.popup()) : y.debug('No content specified skipping display', j); },
        createID() { b = (`${Math.random().toString(16)}000000000`).substr(2, 8), v = `.${b}`, y.verbose('Creating unique id for element', b); },
        toggle() { y.debug('Toggling pop-up'), y.is.hidden() ? (y.debug('Popup is hidden, showing pop-up'), y.unbind.close(), y.show()) : (y.debug('Popup is visible, hiding pop-up'), y.hide()); },
        show(e) { if (e = e || function () {}, y.debug('Showing pop-up', x.transition), y.is.hidden() && (!y.is.active() || !y.is.dropdown())) { if (y.exists() || y.create(), x.onShow.call(n, j) === !1) return void y.debug('onShow callback returned false, cancelling popup animation'); x.preserve || x.popup || y.refresh(), n && y.set.position() && (y.save.conditions(), x.exclusive && y.hideAll(), y.animate.show(e)); } },
        hide(e) { if (e = e || function () {}, y.is.visible() || y.is.animating()) { if (x.onHide.call(n, j) === !1) return void y.debug('onHide callback returned false, cancelling popup animation'); y.remove.visible(), y.unbind.close(), y.restore.conditions(), y.animate.hide(e); } },
        hideAll() { e(C.popup).filter(`.${w.visible}`).each(function () { e(this).data(T.activator).popup('hide'); }); },
        exists() { return n ? x.inline || x.popup ? y.has.popup() : n.closest(E).length >= 1 ? !0 : !1 : !1; },
        removePopup() { y.has.popup() && !x.popup && (y.debug('Removing popup', n), n.remove(), n = i, x.onRemove.call(n, j)); },
        save: { conditions() { y.cache = { title: R.attr('title') }, y.cache.title && R.removeAttr('title'), y.verbose('Saving original attributes', y.cache.title); } },
        restore: { conditions() { return y.cache && y.cache.title && (R.attr('title', y.cache.title), y.verbose('Restoring original attributes', y.cache.title)), !0; } },
        animate: {
          show(t) {
            t = e.isFunction(t) ? t : function () {}, x.transition && e.fn.transition !== i && R.transition('is supported') ? (y.set.visible(), n.transition({
              animation: `${x.transition} in`, queue: !1, debug: x.debug, verbose: x.verbose, duration: x.duration, onComplete() { y.bind.close(), t.call(n, j), x.onVisible.call(n, j); },
            })) : y.error(k.noTransition);
          },
          hide(t) {
            return t = e.isFunction(t) ? t : function () {}, y.debug('Hiding pop-up'), x.onHide.call(n, j) === !1 ? void y.debug('onHide callback returned false, cancelling popup animation') : void (x.transition && e.fn.transition !== i && R.transition('is supported') ? n.transition({
              animation: `${x.transition} out`, queue: !1, duration: x.duration, debug: x.debug, verbose: x.verbose, onComplete() { y.reset(), t.call(n, j), x.onHidden.call(n, j); },
            }) : y.error(k.noTransition));
          },
        },
        get: {
          html() { return R.removeData(T.html), R.data(T.html) || x.html; },
          title() { return R.removeData(T.title), R.data(T.title) || x.title; },
          content() { return R.removeData(T.content), R.data(T.content) || R.attr('title') || x.content; },
          variation() { return R.removeData(T.variation), R.data(T.variation) || x.variation; },
          popupOffset() { return n.offset(); },
          calculations() {
            let e; const i = P[0]; const o = x.inline || x.popup ? P.position() : P.offset(); let a = {}; return a = {
              target: {
                element: P[0], width: P.outerWidth(), height: P.outerHeight(), top: o.top, left: o.left, margin: {},
              },
              popup: { width: n.outerWidth(), height: n.outerHeight() },
              parent: { width: r.outerWidth(), height: r.outerHeight() },
              screen: { scroll: { top: c.scrollTop(), left: c.scrollLeft() }, width: c.width(), height: c.height() },
            }, x.setFluidWidth && y.is.fluid() && (a.container = { width: n.parent().outerWidth() }, a.popup.width = a.container.width), a.target.margin.top = x.inline ? parseInt(t.getComputedStyle(i).getPropertyValue('margin-top'), 10) : 0, a.target.margin.left = x.inline ? y.is.rtl() ? parseInt(t.getComputedStyle(i).getPropertyValue('margin-right'), 10) : parseInt(t.getComputedStyle(i).getPropertyValue('margin-left'), 10) : 0, e = a.screen, a.boundary = {
              top: e.scroll.top, bottom: e.scroll.top + e.height, left: e.scroll.left, right: e.scroll.left + e.width,
            }, a;
          },
          id() { return b; },
          startEvent() { return x.on == 'hover' ? 'mouseenter' : x.on == 'focus' ? 'focus' : !1; },
          scrollEvent() { return 'scroll'; },
          endEvent() { return x.on == 'hover' ? 'mouseleave' : x.on == 'focus' ? 'blur' : !1; },
          distanceFromBoundary(e, t) {
            let n; let i; let o = {}; return e = e || y.get.offset(), t = t || y.get.calculations(), n = t.popup, i = t.boundary, e && (o = {
              top: e.top - i.top, left: e.left - i.left, right: i.right - (e.left + n.width), bottom: i.bottom - (e.top + n.height),
            }, y.verbose('Distance from boundaries determined', e, o)), o;
          },
          offsetParent(t) { const n = t !== i ? t[0] : R[0]; let o = n.parentNode; let a = e(o); if (o) for (let r = a.css('transform') === 'none', s = a.css('position') === 'static', c = a.is('html'); o && !c && s && r;)o = o.parentNode, a = e(o), r = a.css('transform') === 'none', s = a.css('position') === 'static', c = a.is('html'); return a && a.length > 0 ? a : e(); },
          positions() {
            return {
              'top left': !1, 'top center': !1, 'top right': !1, 'bottom left': !1, 'bottom center': !1, 'bottom right': !1, 'left center': !1, 'right center': !1,
            };
          },
          nextPosition(e) {
            const t = e.split(' '); const n = t[0]; const i = t[1]; const o = {
              top: 'bottom', bottom: 'top', left: 'right', right: 'left',
            }; const a = { left: 'center', center: 'right', right: 'left' }; const r = {
              'top left': 'top center', 'top center': 'top right', 'top right': 'right center', 'right center': 'bottom right', 'bottom right': 'bottom center', 'bottom center': 'bottom left', 'bottom left': 'left center', 'left center': 'top left',
            }; const s = n == 'top' || n == 'bottom'; let c = !1; let l = !1; let u = !1; return O || (y.verbose('All available positions available'), O = y.get.positions()), y.debug('Recording last position tried', e), O[e] = !0, x.prefer === 'opposite' && (u = [o[n], i], u = u.join(' '), c = O[u] === !0, y.debug('Trying opposite strategy', u)), x.prefer === 'adjacent' && s && (u = [n, a[i]], u = u.join(' '), l = O[u] === !0, y.debug('Trying adjacent strategy', u)), (l || c) && (y.debug('Using backup position', u), u = r[e]), u;
          },
        },
        set: {
          position(e, t) {
            if (P.length === 0 || n.length === 0) return void y.error(k.notFound); let o; let a; let r; let s; let c; let l; let u; let d; if (t = t || y.get.calculations(), e = e || R.data(T.position) || x.position, o = R.data(T.offset) || x.offset, a = x.distanceAway, r = t.target, s = t.popup, c = t.parent, r.width === 0 && r.height === 0) return y.debug('Popup target is hidden, no action taken'), !1; switch (x.inline && (y.debug('Adding margin to calculation', r.margin), e == 'left center' || e == 'right center' ? (o += r.margin.top, a += -r.margin.left) : e == 'top left' || e == 'top center' || e == 'top right' ? (o += r.margin.left, a -= r.margin.top) : (o += r.margin.left, a += r.margin.top)), y.debug('Determining popup position from calculations', e, t), y.is.rtl() && (e = e.replace(/left|right/g, (e) => (e == 'left' ? 'right' : 'left')), y.debug('RTL: Popup position updated', e)), F == x.maxSearchDepth && typeof x.lastResort === 'string' && (e = x.lastResort), e) {
              case 'top left': l = {
                top: 'auto', bottom: c.height - r.top + a, left: r.left + o, right: 'auto',
              }; break; case 'top center': l = {
                bottom: c.height - r.top + a, left: r.left + r.width / 2 - s.width / 2 + o, top: 'auto', right: 'auto',
              }; break; case 'top right': l = {
                bottom: c.height - r.top + a, right: c.width - r.left - r.width - o, top: 'auto', left: 'auto',
              }; break; case 'left center': l = {
                top: r.top + r.height / 2 - s.height / 2 + o, right: c.width - r.left + a, left: 'auto', bottom: 'auto',
              }; break; case 'right center': l = {
                top: r.top + r.height / 2 - s.height / 2 + o, left: r.left + r.width + a, bottom: 'auto', right: 'auto',
              }; break; case 'bottom left': l = {
                top: r.top + r.height + a, left: r.left + o, bottom: 'auto', right: 'auto',
              }; break; case 'bottom center': l = {
                top: r.top + r.height + a, left: r.left + r.width / 2 - s.width / 2 + o, bottom: 'auto', right: 'auto',
              }; break; case 'bottom right': l = {
                top: r.top + r.height + a, right: c.width - r.left - r.width - o, left: 'auto', bottom: 'auto',
              };
            } if (l === i && y.error(k.invalidPosition, e), y.debug('Calculated popup positioning values', l), n.css(l).removeClass(w.position).addClass(e).addClass(w.loading), u = y.get.popupOffset(), d = y.get.distanceFromBoundary(u, t), y.is.offstage(d, e)) { if (y.debug('Position is outside viewport', e), F < x.maxSearchDepth) return F++, e = y.get.nextPosition(e), y.debug('Trying new position', e), n ? y.set.position(e, t) : !1; if (!x.lastResort) return y.debug('Popup could not find a position to display', n), y.error(k.cannotPlace, j), y.remove.attempts(), y.remove.loading(), y.reset(), !1; y.debug('No position found, showing with last position'); } return y.debug('Position is on stage', e), y.remove.attempts(), y.remove.loading(), x.setFluidWidth && y.is.fluid() && y.set.fluidWidth(t), !0;
          },
          fluidWidth(e) { e = e || y.get.calculations(), y.debug('Automatically setting element width to parent width', e.parent.width), n.css('width', e.container.width); },
          variation(e) { e = e || y.get.variation(), e && y.has.popup() && (y.verbose('Adding variation to popup', e), n.addClass(e)); },
          visible() { R.addClass(w.visible); },
        },
        remove: {
          loading() { n.removeClass(w.loading); }, variation(e) { e = e || y.get.variation(), e && (y.verbose('Removing variation', e), n.removeClass(e)); }, visible() { R.removeClass(w.visible); }, attempts() { y.verbose('Resetting all searched positions'), F = 0, O = !1; },
        },
        bind: { events() { y.debug('Binding popup events to module'), x.on == 'click' && R.on(`click${A}`, y.toggle), x.on == 'hover' && d && R.on(`touchstart${A}`, y.event.touchstart), y.get.startEvent() && R.on(y.get.startEvent() + A, y.event.start).on(y.get.endEvent() + A, y.event.end), x.target && y.debug('Target set to element', P), c.on(`resize${v}`, y.event.resize); }, popup() { y.verbose('Allowing hover events on popup to prevent closing'), n && y.has.popup() && n.on(`mouseenter${A}`, y.event.start).on(`mouseleave${A}`, y.event.end); }, close() { (x.hideOnScroll === !0 || x.hideOnScroll == 'auto' && x.on != 'click') && (s.one(y.get.scrollEvent() + v, y.event.hideGracefully), E.one(y.get.scrollEvent() + v, y.event.hideGracefully)), x.on == 'hover' && q && (y.verbose('Binding popup close event to document'), s.on(`touchstart${v}`, (e) => { y.verbose('Touched away from popup'), y.event.hideGracefully.call(j, e); })), x.on == 'click' && x.closable && (y.verbose('Binding popup close event to document'), s.on(`click${v}`, (e) => { y.verbose('Clicked away from popup'), y.event.hideGracefully.call(j, e); })); } },
        unbind: { close() { (x.hideOnScroll === !0 || x.hideOnScroll == 'auto' && x.on != 'click') && (s.off(`scroll${v}`, y.hide), E.off(`scroll${v}`, y.hide)), x.on == 'hover' && q && (s.off(`touchstart${v}`), q = !1), x.on == 'click' && x.closable && (y.verbose('Removing close event from document'), s.off(`click${v}`)); } },
        has: { popup() { return n && n.length > 0; } },
        is: {
          offstage(t, n) { const i = []; return e.each(t, (e, t) => { t < -x.jitter && (y.debug('Position exceeds allowable distance from edge', e, t, n), i.push(e)); }), i.length > 0 ? !0 : !1; }, active() { return R.hasClass(w.active); }, animating() { return n && n.hasClass(w.animating); }, fluid() { return n && n.hasClass(w.fluid); }, visible() { return n && n.hasClass(w.visible); }, dropdown() { return R.hasClass(w.dropdown); }, hidden() { return !y.is.visible(); }, rtl() { return R.css('direction') == 'rtl'; },
        },
        reset() { y.remove.visible(), x.preserve ? e.fn.transition !== i && n.transition('remove transition') : y.removePopup(); },
        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (n === i) return x[t]; x[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (n === i) return y[t]; y[t] = n; } },
        debug() { x.debug && (x.performance ? y.performance.log(arguments) : (y.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.debug.apply(console, arguments))); },
        verbose() { x.verbose && x.debug && (x.performance ? y.performance.log(arguments) : (y.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.verbose.apply(console, arguments))); },
        error() { y.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), y.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; x.performance && (t = (new Date()).getTime(), i = f || t, n = t - i, f = t, m.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: j, 'Execution Time': n,
            })), clearTimeout(y.performance.timer), y.performance.timer = setTimeout(y.performance.display, 500);
          },
          display() { let t = `${x.name}:`; let n = 0; f = !1, clearTimeout(y.performance.timer), e.each(m, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, u && (t += ` '${u}'`), (console.group !== i || console.table !== i) && m.length > 0 && (console.groupCollapsed(t), console.table ? console.table(m) : e.each(m, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), m = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = I; return n = n || h, o = j || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, p ? (I === i && y.initialize(), y.invoke(g)) : (I !== i && I.invoke('destroy'), y.initialize());
    }), a !== i ? a : this;
  }, e.fn.popup.settings = {
    name: 'Popup',
    debug: !1,
    verbose: !1,
    performance: !0,
    namespace: 'popup',
    onCreate() {},
    onRemove() {},
    onShow() {},
    onVisible() {},
    onHide() {},
    onHidden() {},
    on: 'hover',
    addTouchEvents: !0,
    position: 'top left',
    variation: '',
    movePopup: !0,
    target: !1,
    popup: !1,
    inline: !1,
    preserve: !1,
    hoverable: !1,
    content: !1,
    html: !1,
    title: !1,
    closable: !0,
    hideOnScroll: 'auto',
    exclusive: !1,
    context: 'body',
    prefer: 'opposite',
    lastResort: !1,
    delay: { show: 50, hide: 70 },
    setFluidWidth: !0,
    duration: 200,
    transition: 'scale',
    distanceAway: 0,
    jitter: 2,
    offset: 0,
    maxSearchDepth: 15,
    error: {
      invalidPosition: 'The position you specified is not a valid position', cannotPlace: 'Popup does not fit within the boundaries of the viewport', method: 'The method you called is not defined.', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>', notFound: 'The target or popup you specified does not exist on the page',
    },
    metadata: {
      activator: 'activator', content: 'content', html: 'html', offset: 'offset', position: 'position', title: 'title', variation: 'variation',
    },
    className: {
      active: 'active', animating: 'animating', dropdown: 'dropdown', fluid: 'fluid', loading: 'loading', popup: 'ui popup', position: 'top left center bottom right', visible: 'visible',
    },
    selector: { popup: '.ui.popup' },
    templates: {
      escape(e) {
        const t = /[&<>"'`]/g; const n = /[&<>"'`]/; const i = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
        }; const o = function (e) { return i[e]; }; return n.test(e) ? e.replace(t, o) : e;
      },
      popup(t) { let n = ''; const o = e.fn.popup.settings.templates.escape; return typeof t !== i && (typeof t.title !== i && t.title && (t.title = o(t.title), n += `<div class="header">${t.title}</div>`), typeof t.content !== i && t.content && (t.content = o(t.content), n += `<div class="content">${t.content}</div>`)), n; },
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.progress = function (t) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; let f; const m = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.progress.settings, t) : e.extend({}, e.fn.progress.settings); const g = m.className; const p = m.metadata; const h = m.namespace; const v = m.selector; const b = m.error; const y = `.${h}`; const x = `module-${h}`; const C = e(this); const w = e(this).find(v.bar); const k = e(this).find(v.progress); const T = e(this).find(v.label); const S = this; let A = C.data(x); let D = !1; f = {
        initialize() { f.debug('Initializing progress bar', m), f.set.duration(), f.set.transitionEvent(), f.read.metadata(), f.read.settings(), f.instantiate(); },
        instantiate() { f.verbose('Storing instance of progress', f), A = f, C.data(x, f); },
        destroy() { f.verbose('Destroying previous progress for', C), clearInterval(A.interval), f.remove.state(), C.removeData(x), A = i; },
        reset() { f.set.percent(0); },
        complete() { (f.percent === i || f.percent < 100) && f.set.percent(100); },
        read: { metadata() { const e = { percent: C.data(p.percent), total: C.data(p.total), value: C.data(p.value) }; e.percent && (f.debug('Current percent value set from metadata', e.percent), f.set.percent(e.percent)), e.total && (f.debug('Total value set from metadata', e.total), f.set.total(e.total)), e.value && (f.debug('Current value set from metadata', e.value), f.set.value(e.value), f.set.progress(e.value)); }, settings() { m.total !== !1 && (f.debug('Current total set in settings', m.total), f.set.total(m.total)), m.value !== !1 && (f.debug('Current value set in settings', m.value), f.set.value(m.value), f.set.progress(f.value)), m.percent !== !1 && (f.debug('Current percent set in settings', m.percent), f.set.percent(m.percent)); } },
        increment(e) { let t; let n; let i; f.has.total() ? (n = f.get.value(), e = e || 1, i = n + e, t = f.get.total(), f.debug('Incrementing value', n, i, t), i > t && (f.debug('Value cannot increment above total', t), i = t)) : (n = f.get.percent(), e = e || f.get.randomValue(), i = n + e, t = 100, f.debug('Incrementing percentage by', n, i), i > t && (f.debug('Value cannot increment above 100 percent'), i = t)), f.set.progress(i); },
        decrement(e) { let t; let n; const i = f.get.total(); i ? (t = f.get.value(), e = e || 1, n = t - e, f.debug('Decrementing value by', e, t)) : (t = f.get.percent(), e = e || f.get.randomValue(), n = t - e, f.debug('Decrementing percentage by', e, t)), n < 0 && (f.debug('Value cannot decrement below 0'), n = 0), f.set.progress(n); },
        has: { total() { return f.get.total() !== !1; } },
        get: {
          text(e) { const t = f.value || 0; const n = f.total || 0; const i = D ? f.get.displayPercent() : f.percent || 0; const o = f.total > 0 ? n - t : 100 - i; return e = e || '', e = e.replace('{value}', t).replace('{total}', n).replace('{left}', o).replace('{percent}', i), f.debug('Adding variables to progress bar text', e), e; },
          randomValue() { return f.debug('Generating random increment percentage'), Math.floor(Math.random() * m.random.max + m.random.min); },
          numericValue(e) { return typeof e === 'string' ? e.replace(/[^\d.]/g, '') !== '' ? +e.replace(/[^\d.]/g, '') : !1 : e; },
          transitionEnd() {
            let e; const t = n.createElement('element'); const o = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in o) if (t.style[e] !== i) return o[e];
          },
          displayPercent() { const e = w.width(); const t = C.width(); const n = parseInt(w.css('min-width'), 10); const i = e > n ? e / t * 100 : f.percent; return m.precision > 0 ? Math.round(i * (10 * m.precision)) / (10 * m.precision) : Math.round(i); },
          percent() { return f.percent || 0; },
          value() { return f.value || 0; },
          total() { return f.total || !1; },
        },
        is: {
          success() { return C.hasClass(g.success); }, warning() { return C.hasClass(g.warning); }, error() { return C.hasClass(g.error); }, active() { return C.hasClass(g.active); }, visible() { return C.is(':visible'); },
        },
        remove: {
          state() { f.verbose('Removing stored state'), delete f.total, delete f.percent, delete f.value; }, active() { f.verbose('Removing active state'), C.removeClass(g.active); }, success() { f.verbose('Removing success state'), C.removeClass(g.success); }, warning() { f.verbose('Removing warning state'), C.removeClass(g.warning); }, error() { f.verbose('Removing error state'), C.removeClass(g.error); },
        },
        set: {
          barWidth(e) { e > 100 ? f.error(b.tooHigh, e) : e < 0 ? f.error(b.tooLow, e) : (w.css('width', `${e}%`), C.attr('data-percent', parseInt(e, 10))); }, duration(e) { e = e || m.duration, e = typeof e === 'number' ? `${e}ms` : e, f.verbose('Setting progress bar transition duration', e), w.css({ 'transition-duration': e }); }, percent(e) { e = typeof e === 'string' ? +e.replace('%', '') : e, e = m.precision > 0 ? Math.round(e * (10 * m.precision)) / (10 * m.precision) : Math.round(e), f.percent = e, f.has.total() || (f.value = m.precision > 0 ? Math.round(e / 100 * f.total * (10 * m.precision)) / (10 * m.precision) : Math.round(e / 100 * f.total * 10) / 10, m.limitValues && (f.value = f.value > 100 ? 100 : f.value < 0 ? 0 : f.value)), f.set.barWidth(e), f.set.labelInterval(), f.set.labels(), m.onChange.call(S, e, f.value, f.total); }, labelInterval() { const e = function () { f.verbose('Bar finished animating, removing continuous label updates'), clearInterval(f.interval), D = !1, f.set.labels(); }; clearInterval(f.interval), w.one(a + y, e), f.timer = setTimeout(e, m.duration + 100), D = !0, f.interval = setInterval(f.set.labels, m.framerate); }, labels() { f.verbose('Setting both bar progress and outer label text'), f.set.barLabel(), f.set.state(); }, label(e) { e = e || '', e && (e = f.get.text(e), f.debug('Setting label to text', e), T.text(e)); }, state(e) { e = e !== i ? e : f.percent, e === 100 ? !m.autoSuccess || f.is.warning() || f.is.error() ? (f.verbose('Reached 100% removing active state'), f.remove.active()) : (f.set.success(), f.debug('Automatically triggering success at 100%')) : e > 0 ? (f.verbose('Adjusting active progress bar label', e), f.set.active()) : (f.remove.active(), f.set.label(m.text.active)); }, barLabel(e) { e !== i ? k.text(f.get.text(e)) : m.label == 'ratio' && f.total ? (f.debug('Adding ratio to bar label'), k.text(f.get.text(m.text.ratio))) : m.label == 'percent' && (f.debug('Adding percentage to bar label'), k.text(f.get.text(m.text.percent))); }, active(e) { e = e || m.text.active, f.debug('Setting active state'), m.showActivity && !f.is.active() && C.addClass(g.active), f.remove.warning(), f.remove.error(), f.remove.success(), e && f.set.label(e), m.onActive.call(S, f.value, f.total); }, success(e) { e = e || m.text.success, f.debug('Setting success state'), C.addClass(g.success), f.remove.active(), f.remove.warning(), f.remove.error(), f.complete(), e && f.set.label(e), m.onSuccess.call(S, f.total); }, warning(e) { e = e || m.text.warning, f.debug('Setting warning state'), C.addClass(g.warning), f.remove.active(), f.remove.success(), f.remove.error(), f.complete(), e && f.set.label(e), m.onWarning.call(S, f.value, f.total); }, error(e) { e = e || m.text.error, f.debug('Setting error state'), C.addClass(g.error), f.remove.active(), f.remove.success(), f.remove.warning(), f.complete(), e && f.set.label(e), m.onError.call(S, f.value, f.total); }, transitionEvent() { a = f.get.transitionEnd(); }, total(e) { f.total = e; }, value(e) { f.value = e; }, progress(e) { let t; const n = f.get.numericValue(e); n === !1 && f.error(b.nonNumeric, e), f.has.total() ? (f.set.value(n), t = n / f.total * 100, f.debug('Calculating percent complete from total', t), f.set.percent(t)) : (t = n, f.debug('Setting value to exact percentage value', t), f.set.percent(t)); },
        },
        setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        debug() { m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
        error() { f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: S, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) {
          let r; let s; let c; let l = A; return n = n || d, a = S || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/),
          r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (f.error(b.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s;
        },
      }, u ? (A === i && f.initialize(), f.invoke(l)) : (A !== i && A.invoke('destroy'), f.initialize());
    }), o !== i ? o : this;
  }, e.fn.progress.settings = {
    name: 'Progress',
    namespace: 'progress',
    debug: !1,
    verbose: !1,
    performance: !0,
    random: { min: 2, max: 5 },
    duration: 300,
    autoSuccess: !0,
    showActivity: !0,
    limitValues: !0,
    label: 'percent',
    precision: 0,
    framerate: 1e3 / 30,
    percent: !1,
    total: !1,
    value: !1,
    onChange(e, t, n) {},
    onSuccess(e) {},
    onActive(e, t) {},
    onError(e, t) {},
    onWarning(e, t) {},
    error: {
      method: 'The method you called is not defined.', nonNumeric: 'Progress value is non numeric', tooHigh: 'Value specified is above 100%', tooLow: 'Value specified is below 0%',
    },
    regExp: { variable: /\{\$*[A-z0-9]+\}/g },
    metadata: { percent: 'percent', total: 'total', value: 'value' },
    selector: { bar: '> .bar', label: '> .label', progress: '.bar > .progress' },
    text: {
      active: !1, error: !1, success: !1, warning: !1, percent: '{percent}%', ratio: '{value} of {total}',
    },
    className: {
      active: 'active', error: 'error', success: 'success', warning: 'warning',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.rating = function (t) {
    let n; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const c = arguments[0]; const l = typeof c === 'string'; const u = [].slice.call(arguments, 1); return o.each(function () {
      let d; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.rating.settings, t) : e.extend({}, e.fn.rating.settings); const m = f.namespace; const g = f.className; const p = f.metadata; const h = f.selector; const v = (f.error, `.${m}`); const b = `module-${m}`; const y = this; let x = e(this).data(b); const C = e(this); let w = C.find(h.icon); d = {
        initialize() { d.verbose('Initializing rating module', f), w.length === 0 && d.setup.layout(), f.interactive ? d.enable() : d.disable(), d.set.rating(d.get.initialRating()), d.instantiate(); },
        instantiate() { d.verbose('Instantiating module', f), x = d, C.data(b, d); },
        destroy() { d.verbose('Destroying previous instance', x), d.remove.events(), C.removeData(b); },
        refresh() { w = C.find(h.icon); },
        setup: { layout() { const t = d.get.maxRating(); const n = e.fn.rating.settings.templates.icon(t); d.debug('Generating icon html dynamically'), C.html(n), d.refresh(); } },
        event: { mouseenter() { const t = e(this); t.nextAll().removeClass(g.selected), C.addClass(g.selected), t.addClass(g.selected).prevAll().addClass(g.selected); }, mouseleave() { C.removeClass(g.selected), w.removeClass(g.selected); }, click() { const t = e(this); const n = d.get.rating(); const i = w.index(t) + 1; const o = f.clearable == 'auto' ? w.length === 1 : f.clearable; o && n == i ? d.clearRating() : d.set.rating(i); } },
        clearRating() { d.debug('Clearing current rating'), d.set.rating(0); },
        bind: { events() { d.verbose('Binding events'), C.on(`mouseenter${v}`, h.icon, d.event.mouseenter).on(`mouseleave${v}`, h.icon, d.event.mouseleave).on(`click${v}`, h.icon, d.event.click); } },
        remove: { events() { d.verbose('Removing events'), C.off(v); } },
        enable() { d.debug('Setting rating to interactive mode'), d.bind.events(), C.removeClass(g.disabled); },
        disable() { d.debug('Setting rating to read-only mode'), d.remove.events(), C.addClass(g.disabled); },
        get: { initialRating() { return C.data(p.rating) !== i ? (C.removeData(p.rating), C.data(p.rating)) : f.initialRating; }, maxRating() { return C.data(p.maxRating) !== i ? (C.removeData(p.maxRating), C.data(p.maxRating)) : f.maxRating; }, rating() { const e = w.filter(`.${g.active}`).length; return d.verbose('Current rating retrieved', e), e; } },
        set: { rating(e) { const t = e - 1 >= 0 ? e - 1 : 0; const n = w.eq(t); C.removeClass(g.selected), w.removeClass(g.selected).removeClass(g.active), e > 0 && (d.verbose('Setting current rating to', e), n.prevAll().andSelf().addClass(g.active)), f.onRate.call(y, e); } },
        setting(t, n) { if (d.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (n === i) return f[t]; f[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (n === i) return d[t]; d[t] = n; } },
        debug() { f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
        verbose() { f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
        error() { d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: y, 'Execution Time': n,
            })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
          },
          display() { let t = `${f.name}:`; let n = 0; r = !1, clearTimeout(d.performance.timer), e.each(s, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (console.group !== i || console.table !== i) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
        },
        invoke(t, o, a) { let r; let s; let c; let l = x; return o = o || u, a = y || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, o) : s !== i && (c = s), e.isArray(n) ? n.push(c) : n !== i ? n = [n, c] : c !== i && (n = c), s; },
      }, l ? (x === i && d.initialize(), d.invoke(c)) : (x !== i && x.invoke('destroy'), d.initialize());
    }), n !== i ? n : this;
  }, e.fn.rating.settings = {
    name: 'Rating',
    namespace: 'rating',
    debug: !1,
    verbose: !1,
    performance: !0,
    initialRating: 0,
    interactive: !0,
    maxRating: 4,
    clearable: 'auto',
    onRate(e) {},
    error: { method: 'The method you called is not defined', noMaximum: 'No maximum rating specified. Cannot generate HTML automatically' },
    metadata: { rating: 'rating', maxRating: 'maxRating' },
    className: {
      active: 'active', disabled: 'disabled', selected: 'selected', loading: 'loading',
    },
    selector: { icon: '.icon' },
    templates: { icon(e) { for (var t = 1, n = ''; e >= t;)n += '<i class="icon"></i>', t++; return n; } },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.search = function (o) {
    let a; const r = e(this); const s = r.selector || ''; let c = (new Date()).getTime(); let l = []; const u = arguments[0]; const d = typeof u === 'string'; const f = [].slice.call(arguments, 1); return e(this).each(function () {
      let m; const g = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.search.settings, o) : e.extend({}, e.fn.search.settings); const p = g.className; const h = g.metadata; const v = g.regExp; const b = g.fields; const y = g.selector; const x = g.error; const C = g.namespace; const w = `.${C}`; const k = `${C}-module`; const T = e(this); const S = T.find(y.prompt); const A = T.find(y.searchButton); let D = T.find(y.results); const R = (T.find(y.result), T.find(y.category), this); let E = T.data(k); m = {
        initialize() { m.verbose('Initializing module'), m.determine.searchFields(), m.bind.events(), m.set.type(), m.create.results(), m.instantiate(); },
        instantiate() { m.verbose('Storing instance of module', m), E = m, T.data(k, m); },
        destroy() { m.verbose('Destroying instance'), T.off(w).removeData(k); },
        bind: {
          events() {
            m.verbose('Binding events to search'), g.automatic && (T.on(m.get.inputEvent() + w, y.prompt, m.event.input), S.attr('autocomplete', 'off')), T.on(`focus${w}`, y.prompt, m.event.focus).on(`blur${w}`, y.prompt, m.event.blur).on(`keydown${w}`, y.prompt, m.handleKeyboard).on(`click${w}`, y.searchButton, m.query)
              .on(`mousedown${w}`, y.results, m.event.result.mousedown)
              .on(`mouseup${w}`, y.results, m.event.result.mouseup)
              .on(`click${w}`, y.result, m.event.result.click);
          },
        },
        determine: { searchFields() { o && o.searchFields !== i && (g.searchFields = o.searchFields); } },
        event: {
          input() { clearTimeout(m.timer), m.timer = setTimeout(m.query, g.searchDelay); }, focus() { m.set.focus(), m.has.minimumCharacters() && (m.query(), m.can.show() && m.showResults()); }, blur(e) { const t = n.activeElement === this; t || m.resultsClicked || (m.cancel.query(), m.remove.focus(), m.timer = setTimeout(m.hideResults, g.hideDelay)); }, result: { mousedown() { m.resultsClicked = !0; }, mouseup() { m.resultsClicked = !1; }, click(n) { m.debug('Search result selected'); const i = e(this); const o = i.find(y.title).eq(0); const a = i.find('a[href]').eq(0); const r = a.attr('href') || !1; const s = a.attr('target') || !1; const c = (o.html(), o.length > 0 ? o.text() : !1); const l = m.get.results(); const u = i.data(h.result) || m.get.result(c, l); return e.isFunction(g.onSelect) && g.onSelect.call(R, u, l) === !1 ? void m.debug('Custom onSelect callback cancelled default select action') : (m.hideResults(), c && m.set.value(c), void (r && (m.verbose('Opening search link found in result', a), s == '_blank' || n.ctrlKey ? t.open(r) : t.location.href = r))); } },
        },
        handleKeyboard(e) {
          let t; const n = T.find(y.result); const i = T.find(y.category); const o = n.index(n.filter(`.${p.active}`)); const a = n.length; const r = e.which; const s = {
            backspace: 8, enter: 13, escape: 27, upArrow: 38, downArrow: 40,
          }; if (r == s.escape && (m.verbose('Escape key pressed, blurring search field'), S.trigger('blur')), m.is.visible()) {
            if (r == s.enter) { if (m.verbose('Enter key pressed, selecting active result'), n.filter(`.${p.active}`).length > 0) return m.event.result.click.call(n.filter(`.${p.active}`), e), e.preventDefault(), !1; } else {
              r == s.upArrow ? (m.verbose('Up key pressed, changing active result'), t = o - 1 < 0 ? o : o - 1, i.removeClass(p.active), n.removeClass(p.active).eq(t).addClass(p.active).closest(i)
                .addClass(p.active), e.preventDefault()) : r == s.downArrow && (m.verbose('Down key pressed, changing active result'), t = o + 1 >= a ? o : o + 1, i.removeClass(p.active), n.removeClass(p.active).eq(t).addClass(p.active).closest(i)
                .addClass(p.active), e.preventDefault());
            }
          } else r == s.enter && (m.verbose('Enter key pressed, executing query'), m.query(), m.set.buttonPressed(), S.one('keyup', m.remove.buttonFocus));
        },
        setup: {
          api() {
            const e = {
              debug: g.debug, on: !1, cache: 'local', action: 'search', onError: m.error,
            }; m.verbose('First request, initializing API'), T.api(e);
          },
        },
        can: { useAPI() { return e.fn.api !== i; }, show() { return m.is.focused() && !m.is.visible() && !m.is.empty(); }, transition() { return g.transition && e.fn.transition !== i && T.transition('is supported'); } },
        is: { empty() { return D.html() === ''; }, visible() { return D.filter(':visible').length > 0; }, focused() { return S.filter(':focus').length > 0; } },
        get: {
          inputEvent() { const e = S[0]; const t = e !== i && e.oninput !== i ? 'input' : e !== i && e.onpropertychange !== i ? 'propertychange' : 'keyup'; return t; }, value() { return S.val(); }, results() { const e = T.data(h.results); return e; }, result(t, n) { const o = ['title', 'id']; let a = !1; return t = t !== i ? t : m.get.value(), n = n !== i ? n : m.get.results(), g.type === 'category' ? (m.debug('Finding result that matches', t), e.each(n, (n, i) => (e.isArray(i.results) && (a = m.search.object(t, i.results, o)[0]) ? !1 : void 0))) : (m.debug('Finding result in results object', t), a = m.search.object(t, n, o)[0]), a || !1; },
        },
        set: {
          focus() { T.addClass(p.focus); }, loading() { T.addClass(p.loading); }, value(e) { m.verbose('Setting search input value', e), S.val(e); }, type(e) { e = e || g.type, g.type == 'category' && T.addClass(g.type); }, buttonPressed() { A.addClass(p.pressed); },
        },
        remove: { loading() { T.removeClass(p.loading); }, focus() { T.removeClass(p.focus); }, buttonPressed() { A.removeClass(p.pressed); } },
        query() { const t = m.get.value(); const n = m.read.cache(t); m.has.minimumCharacters() ? n ? (m.debug('Reading result from cache', t), m.save.results(n.results), m.addResults(n.html), m.inject.id(n.results)) : (m.debug('Querying for', t), e.isPlainObject(g.source) || e.isArray(g.source) ? m.search.local(t) : m.can.useAPI() ? m.search.remote(t) : m.error(x.source), g.onSearchQuery.call(R, t)) : m.hideResults(); },
        search: { local(e) { let t; const n = m.search.object(e, g.content); m.set.loading(), m.save.results(n), m.debug('Returned local search results', n), t = m.generateResults({ results: n }), m.remove.loading(), m.addResults(t), m.inject.id(n), m.write.cache(e, { html: t, results: n }); }, remote(t) { const n = { onSuccess(e) { m.parse.response.call(R, e, t); }, onFailure() { m.displayMessage(x.serverError); }, urlData: { query: t } }; T.api('get request') || m.setup.api(), e.extend(!0, n, g.apiSettings), m.debug('Executing search', n), m.cancel.query(), T.api('setting', n).api('query'); }, object(t, n, o) { const a = []; const r = []; const s = t.toString().replace(v.escape, '\\$&'); const c = new RegExp(v.beginsWith + s, 'i'); const l = function (t, n) { const i = e.inArray(n, a) == -1; const o = e.inArray(n, r) == -1; i && o && t.push(n); }; return n = n || g.source, o = o !== i ? o : g.searchFields, e.isArray(o) || (o = [o]), n === i || n === !1 ? (m.error(x.source), []) : (e.each(o, (i, o) => { e.each(n, (e, n) => { const i = typeof n[o] === 'string'; i && (n[o].search(c) !== -1 ? l(a, n) : g.searchFullText && m.fuzzySearch(t, n[o]) && l(r, n)); }); }), e.merge(a, r)); } },
        fuzzySearch(e, t) { const n = t.length; const i = e.length; if (typeof e !== 'string') return !1; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; i > o; o++) { for (let r = e.charCodeAt(o); n > a;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
        parse: { response(e, t) { const n = m.generateResults(e); m.verbose('Parsing server response', e), e !== i && t !== i && e[b.results] !== i && (m.addResults(n), m.inject.id(e[b.results]), m.write.cache(t, { html: n, results: e[b.results] }), m.save.results(e[b.results])); } },
        cancel: { query() { m.can.useAPI() && T.api('abort'); } },
        has: { minimumCharacters() { const e = m.get.value(); const t = e.length; return t >= g.minCharacters; } },
        clear: { cache(e) { const t = T.data(h.cache); e ? e && t && t[e] && (m.debug('Removing value from cache', e), delete t[e], T.data(h.cache, t)) : (m.debug('Clearing cache', e), T.removeData(h.cache)); } },
        read: { cache(e) { const t = T.data(h.cache); return g.cache ? (m.verbose('Checking cache for generated html for query', e), typeof t === 'object' && t[e] !== i ? t[e] : !1) : !1; } },
        create: { id(e, t) { let n; let o; const a = e + 1; return t !== i ? (n = String.fromCharCode(97 + t), o = n + a, m.verbose('Creating category result id', o)) : (o = a, m.verbose('Creating result id', o)), o; }, results() { D.length === 0 && (D = e('<div />').addClass(p.results).appendTo(T)); } },
        inject: { result(e, t, n) { m.verbose('Injecting result into results'); const o = n !== i ? D.children().eq(n).children(y.result).eq(t) : D.children(y.result).eq(t); m.verbose('Injecting results metadata', o), o.data(h.result, e); }, id(t) { m.debug('Injecting unique ids into results'); let n = 0; let o = 0; return g.type === 'category' ? e.each(t, (t, a) => { o = 0, e.each(a.results, (e, t) => { const r = a.results[e]; r.id === i && (r.id = m.create.id(o, n)), m.inject.result(r, o, n), o++; }), n++; }) : e.each(t, (e, n) => { const a = t[e]; a.id === i && (a.id = m.create.id(o)), m.inject.result(a, o), o++; }), t; } },
        save: { results(e) { m.verbose('Saving current search results to metadata', e), T.data(h.results, e); } },
        write: { cache(e, t) { const n = T.data(h.cache) !== i ? T.data(h.cache) : {}; g.cache && (m.verbose('Writing generated html to cache', e, t), n[e] = t, T.data(h.cache, n)); } },
        addResults(t) { return e.isFunction(g.onResultsAdd) && g.onResultsAdd.call(D, t) === !1 ? (m.debug('onResultsAdd callback cancelled default action'), !1) : (D.html(t), void (m.can.show() && m.showResults())); },
        showResults() {
          m.is.visible() || (m.can.transition() ? (m.debug('Showing results with css animations'), D.transition({
            animation: `${g.transition} in`, debug: g.debug, verbose: g.verbose, duration: g.duration, queue: !0,
          })) : (m.debug('Showing results with javascript'), D.stop().fadeIn(g.duration, g.easing)), g.onResultsOpen.call(D));
        },
        hideResults() {
          m.is.visible() && (m.can.transition() ? (m.debug('Hiding results with css animations'), D.transition({
            animation: `${g.transition} out`, debug: g.debug, verbose: g.verbose, duration: g.duration, queue: !0,
          })) : (m.debug('Hiding results with javascript'), D.stop().fadeOut(g.duration, g.easing)), g.onResultsClose.call(D));
        },
        generateResults(t) { m.debug('Generating html from response', t); const n = g.templates[g.type]; const i = e.isPlainObject(t[b.results]) && !e.isEmptyObject(t[b.results]); const o = e.isArray(t[b.results]) && t[b.results].length > 0; let a = ''; return i || o ? (g.maxResults > 0 && (i ? g.type == 'standard' && m.error(x.maxResults) : t[b.results] = t[b.results].slice(0, g.maxResults)), e.isFunction(n) ? a = n(t, b) : m.error(x.noTemplate, !1)) : a = m.displayMessage(x.noResults, 'empty'), g.onResults.call(R, t), a; },
        displayMessage(e, t) { return t = t || 'standard', m.debug('Displaying message', e, t), m.addResults(g.templates.message(e, t)), g.templates.message(e, t); },
        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (n === i) return g[t]; g[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        debug() { g.debug && (g.performance ? m.performance.log(arguments) : (m.debug = Function.prototype.bind.call(console.info, console, `${g.name}:`), m.debug.apply(console, arguments))); },
        verbose() { g.verbose && g.debug && (g.performance ? m.performance.log(arguments) : (m.verbose = Function.prototype.bind.call(console.info, console, `${g.name}:`), m.verbose.apply(console, arguments))); },
        error() { m.error = Function.prototype.bind.call(console.error, console, `${g.name}:`), m.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; g.performance && (t = (new Date()).getTime(), i = c || t, n = t - i, c = t, l.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: R, 'Execution Time': n,
            })), clearTimeout(m.performance.timer), m.performance.timer = setTimeout(m.performance.display, 500);
          },
          display() { let t = `${g.name}:`; let n = 0; c = !1, clearTimeout(m.performance.timer), e.each(l, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, s && (t += ` '${s}'`), r.length > 1 && (t += ` (${r.length})`), (console.group !== i || console.table !== i) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = E; return n = n || f, o = R || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, d ? (E === i && m.initialize(), m.invoke(u)) : (E !== i && E.invoke('destroy'), m.initialize());
    }), a !== i ? a : this;
  }, e.fn.search.settings = {
    name: 'Search',
    namespace: 'search',
    debug: !1,
    verbose: !1,
    performance: !0,
    type: 'standard',
    minCharacters: 1,
    apiSettings: !1,
    source: !1,
    searchFields: ['title', 'description'],
    displayField: '',
    searchFullText: !0,
    automatic: !0,
    hideDelay: 0,
    searchDelay: 200,
    maxResults: 7,
    cache: !0,
    transition: 'scale',
    duration: 200,
    easing: 'easeOutExpo',
    onSelect: !1,
    onResultsAdd: !1,
    onSearchQuery(e) {},
    onResults(e) {},
    onResultsOpen() {},
    onResultsClose() {},
    className: {
      active: 'active', empty: 'empty', focus: 'focus', loading: 'loading', results: 'results', pressed: 'down',
    },
    error: {
      source: 'Cannot search. No source used, and Semantic API module was not included', noResults: 'Your search returned no results', logging: 'Error in debug logging, exiting.', noEndpoint: 'No search endpoint was specified', noTemplate: 'A valid template name was not specified.', serverError: 'There was an issue querying the server.', maxResults: 'Results must be an array to use maxResults setting', method: 'The method you called is not defined.',
    },
    metadata: { cache: 'cache', results: 'results', result: 'result' },
    regExp: { escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, beginsWith: '(?:s|^)' },
    fields: {
      categories: 'results', categoryName: 'name', categoryResults: 'results', description: 'description', image: 'image', price: 'price', results: 'results', title: 'title', url: 'url', action: 'action', actionText: 'text', actionURL: 'url',
    },
    selector: {
      prompt: '.prompt', searchButton: '.search.button', results: '.results', category: '.category', result: '.result', title: '.title, .name',
    },
    templates: {
      escape(e) {
        const t = /[&<>"'`]/g; const n = /[&<>"'`]/; const i = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
        }; const o = function (e) { return i[e]; }; return n.test(e) ? e.replace(t, o) : e;
      },
      message(e, t) { let n = ''; return e !== i && t !== i && (n += `<div class="message ${t}">`, n += t == 'empty' ? `<div class="header">No Results</div class="header"><div class="description">${e}</div class="description">` : ` <div class="description">${e}</div>`, n += '</div>'), n; },
      category(t, n) { let o = ''; e.fn.search.settings.templates.escape; return t[n.categoryResults] !== i ? (e.each(t[n.categoryResults], (t, a) => { a[n.results] !== i && a.results.length > 0 && (o += '<div class="category">', a[n.categoryName] !== i && (o += `<div class="name">${a[n.categoryName]}</div>`), e.each(a.results, (e, t) => { o += t[n.url] ? `<a class="result" href="${t[n.url]}">` : '<a class="result">', t[n.image] !== i && (o += `<div class="image"> <img src="${t[n.image]}"></div>`), o += '<div class="content">', t[n.price] !== i && (o += `<div class="price">${t[n.price]}</div>`), t[n.title] !== i && (o += `<div class="title">${t[n.title]}</div>`), t[n.description] !== i && (o += `<div class="description">${t[n.description]}</div>`), o += '</div>', o += '</a>'; }), o += '</div>'); }), t[n.action] && (o += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), o) : !1; },
      standard(t, n) { let o = ''; return t[n.results] !== i ? (e.each(t[n.results], (e, t) => { o += t[n.url] ? `<a class="result" href="${t[n.url]}">` : '<a class="result">', t[n.image] !== i && (o += `<div class="image"> <img src="${t[n.image]}"></div>`), o += '<div class="content">', t[n.price] !== i && (o += `<div class="price">${t[n.price]}</div>`), t[n.title] !== i && (o += `<div class="title">${t[n.title]}</div>`), t[n.description] !== i && (o += `<div class="description">${t[n.description]}</div>`), o += '</div>', o += '</a>'; }), t[n.action] && (o += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), o) : !1; },
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.shape = function (o) {
    let a; const r = e(this); let s = (e('body'), (new Date()).getTime()); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); const f = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return r.each(function () {
      let t; let m; let g; const p = r.selector || ''; const h = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.shape.settings, o) : e.extend({}, e.fn.shape.settings); const v = h.namespace; const b = h.selector; const y = h.error; const x = h.className; const C = `.${v}`; const w = `module-${v}`; let k = e(this); let T = k.find(b.sides); let S = k.find(b.side); let A = !1; const D = this; let R = k.data(w); g = {
        initialize() { g.verbose('Initializing module for', D), g.set.defaultSide(), g.instantiate(); },
        instantiate() { g.verbose('Storing instance of module', g), R = g, k.data(w, R); },
        destroy() { g.verbose('Destroying previous module for', D), k.removeData(w).off(C); },
        refresh() { g.verbose('Refreshing selector cache for', D), k = e(D), T = e(this).find(b.shape), S = e(this).find(b.side); },
        repaint() { g.verbose('Forcing repaint event'); const e = T[0] || n.createElement('div'); e.offsetWidth; },
        animate(e, n) { g.verbose('Animating box with properties', e), n = n || function (e) { g.verbose('Executing animation callback'), e !== i && e.stopPropagation(), g.reset(), g.set.active(); }, h.beforeChange.call(m[0]), g.get.transitionEvent() ? (g.verbose('Starting CSS animation'), k.addClass(x.animating), T.css(e).one(g.get.transitionEvent(), n), g.set.duration(h.duration), f(() => { k.addClass(x.animating), t.addClass(x.hidden); })) : n(); },
        queue(e) { g.debug('Queueing animation of', e), T.one(g.get.transitionEvent(), () => { g.debug('Executing queued animation'), setTimeout(() => { k.shape(e); }, 0); }); },
        reset() { g.verbose('Animating states reset'), k.removeClass(x.animating).attr('style', '').removeAttr('style'), T.attr('style', '').removeAttr('style'), S.attr('style', '').removeAttr('style').removeClass(x.hidden), m.removeClass(x.animating).attr('style', '').removeAttr('style'); },
        is: { complete() { return S.filter(`.${x.active}`)[0] == m[0]; }, animating() { return k.hasClass(x.animating); } },
        set: {
          defaultSide() { t = k.find(`.${h.className.active}`), m = t.next(b.side).length > 0 ? t.next(b.side) : k.find(b.side).first(), A = !1, g.verbose('Active side set to', t), g.verbose('Next side set to', m); },
          duration(e) {
            e = e || h.duration, e = typeof e === 'number' ? `${e}ms` : e, g.verbose('Setting animation duration', e), (h.duration || h.duration === 0) && T.add(S).css({
              '-webkit-transition-duration': e, '-moz-transition-duration': e, '-ms-transition-duration': e, '-o-transition-duration': e, 'transition-duration': e,
            });
          },
          currentStageSize() { const e = k.find(`.${h.className.active}`); const t = e.outerWidth(!0); const n = e.outerHeight(!0); k.css({ width: t, height: n }); },
          stageSize() { const e = k.clone().addClass(x.loading); const t = e.find(`.${h.className.active}`); const n = A ? e.find(b.side).eq(A) : t.next(b.side).length > 0 ? t.next(b.side) : e.find(b.side).first(); let i = {}; g.set.currentStageSize(), t.removeClass(x.active), n.addClass(x.active), e.insertAfter(k), i = { width: n.outerWidth(!0), height: n.outerHeight(!0) }, e.remove(), k.css(i), g.verbose('Resizing stage to fit new content', i); },
          nextSide(e) { A = e, m = S.filter(e), A = S.index(m), m.length === 0 && (g.set.defaultSide(), g.error(y.side)), g.verbose('Next side manually set to', m); },
          active() { g.verbose('Setting new side to active', m), S.removeClass(x.active), m.addClass(x.active), h.onChange.call(m[0]), g.set.defaultSide(); },
        },
        flip: {
          up() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip up') : (g.debug('Flipping up', m), g.set.stageSize(), g.stage.above(), g.animate(g.get.transform.up()))) : void g.debug('Side already visible', m); }, down() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip down') : (g.debug('Flipping down', m), g.set.stageSize(), g.stage.below(), g.animate(g.get.transform.down()))) : void g.debug('Side already visible', m); }, left() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip left') : (g.debug('Flipping left', m), g.set.stageSize(), g.stage.left(), g.animate(g.get.transform.left()))) : void g.debug('Side already visible', m); }, right() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip right') : (g.debug('Flipping right', m), g.set.stageSize(), g.stage.right(), g.animate(g.get.transform.right()))) : void g.debug('Side already visible', m); }, over() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip over') : (g.debug('Flipping over', m), g.set.stageSize(), g.stage.behind(), g.animate(g.get.transform.over()))) : void g.debug('Side already visible', m); }, back() { return !g.is.complete() || g.is.animating() || h.allowRepeats ? void (g.is.animating() ? g.queue('flip back') : (g.debug('Flipping back', m), g.set.stageSize(), g.stage.behind(), g.animate(g.get.transform.back()))) : void g.debug('Side already visible', m); },
        },
        get: {
          transform: {
            up() { const e = { y: -((t.outerHeight(!0) - m.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(-90deg)` }; }, down() { const e = { y: -((t.outerHeight(!0) - m.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(90deg)` }; }, left() { const e = { x: -((t.outerWidth(!0) - m.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(90deg)` }; }, right() { const e = { x: -((t.outerWidth(!0) - m.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(-90deg)` }; }, over() { const e = { x: -((t.outerWidth(!0) - m.outerWidth(!0)) / 2) }; return { transform: `translateX(${e.x}px) rotateY(180deg)` }; }, back() { const e = { x: -((t.outerWidth(!0) - m.outerWidth(!0)) / 2) }; return { transform: `translateX(${e.x}px) rotateY(-180deg)` }; },
          },
          transitionEvent() {
            let e; const t = n.createElement('element'); const o = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in o) if (t.style[e] !== i) return o[e];
          },
          nextSide() { return t.next(b.side).length > 0 ? t.next(b.side) : k.find(b.side).first(); },
        },
        stage: {
          above() { const e = { origin: (t.outerHeight(!0) - m.outerHeight(!0)) / 2, depth: { active: m.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; g.verbose('Setting the initial animation position as above', m, e), T.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), m.addClass(x.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); }, below() { const e = { origin: (t.outerHeight(!0) - m.outerHeight(!0)) / 2, depth: { active: m.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; g.verbose('Setting the initial animation position as below', m, e), T.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), m.addClass(x.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); }, left() { const e = { active: t.outerWidth(!0), next: m.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; g.verbose('Setting the initial animation position as left', m, n), T.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), m.addClass(x.animating).css({ left: `${n.origin}px`, transform: `rotateY(-90deg) translateZ(${n.depth.next}px)` }); }, right() { const e = { active: t.outerWidth(!0), next: m.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; g.verbose('Setting the initial animation position as left', m, n), T.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), m.addClass(x.animating).css({ left: `${n.origin}px`, transform: `rotateY(90deg) translateZ(${n.depth.next}px)` }); }, behind() { const e = { active: t.outerWidth(!0), next: m.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; g.verbose('Setting the initial animation position as behind', m, n), t.css({ transform: 'rotateY(0deg)' }), m.addClass(x.animating).css({ left: `${n.origin}px`, transform: 'rotateY(-180deg)' }); },
        },
        setting(t, n) { if (g.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, h, t); else { if (n === i) return h[t]; h[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (n === i) return g[t]; g[t] = n; } },
        debug() { h.debug && (h.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), g.debug.apply(console, arguments))); },
        verbose() { h.verbose && h.debug && (h.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), g.verbose.apply(console, arguments))); },
        error() { g.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), g.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; h.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
            })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
          },
          display() { let t = `${h.name}:`; let n = 0; s = !1, clearTimeout(g.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, p && (t += ` '${p}'`), r.length > 1 && (t += ` (${r.length})`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = R; return n = n || d, o = D || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, u ? (R === i && g.initialize(), g.invoke(l)) : (R !== i && R.invoke('destroy'), g.initialize());
    }), a !== i ? a : this;
  }, e.fn.shape.settings = {
    name: 'Shape',
    debug: !1,
    verbose: !1,
    performance: !0,
    namespace: 'shape',
    beforeChange() {},
    onChange() {},
    allowRepeats: !1,
    duration: !1,
    error: { side: 'You tried to switch to a side that does not exist.', method: 'The method you called is not defined' },
    className: {
      animating: 'animating', hidden: 'hidden', loading: 'loading', active: 'active',
    },
    selector: { sides: '.sides', side: '.side' },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.sidebar = function (o) {
    let a; const r = e(this); const s = e(t); const c = e(n); const l = e('html'); const u = e('head'); const d = r.selector || ''; let f = (new Date()).getTime(); let m = []; const g = arguments[0]; const p = typeof g === 'string'; const h = [].slice.call(arguments, 1); const v = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return r.each(function () {
      let r; let b; let y; let x; let C; let w; const k = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.sidebar.settings, o) : e.extend({}, e.fn.sidebar.settings); const T = k.selector; const S = k.className; const A = k.namespace; const D = k.regExp; const R = k.error; const E = `.${A}`; const P = `module-${A}`; const F = e(this); let O = e(k.context); let q = F.children(T.sidebar); let j = O.children(T.fixed); let I = O.children(T.pusher); const z = this; let N = F.data(P); w = {
        initialize() { w.debug('Initializing sidebar', o), w.create.id(), C = w.get.transitionEvent(), w.is.ios() && w.set.ios(), k.delaySetup ? v(w.setup.layout) : w.setup.layout(), v(() => { w.setup.cache(); }), w.instantiate(); },
        instantiate() { w.verbose('Storing instance of module', w), N = w, F.data(P, w); },
        create: { id() { y = (`${Math.random().toString(16)}000000000`).substr(2, 8), b = `.${y}`, w.verbose('Creating unique id for element', y); } },
        destroy() { w.verbose('Destroying previous module for', F), F.off(E).removeData(P), w.is.ios() && w.remove.ios(), O.off(b), s.off(b), c.off(b); },
        event: {
          clickaway(e) { const t = I.find(e.target).length > 0 || I.is(e.target); const n = O.is(e.target); t && (w.verbose('User clicked on dimmed page'), w.hide()), n && (w.verbose('User clicked on dimmable context (scaled out page)'), w.hide()); }, touch(e) {}, containScroll(e) { z.scrollTop <= 0 && (z.scrollTop = 1), z.scrollTop + z.offsetHeight >= z.scrollHeight && (z.scrollTop = z.scrollHeight - z.offsetHeight - 1); }, scroll(t) { e(t.target).closest(T.sidebar).length === 0 && t.preventDefault(); },
        },
        bind: { clickaway() { w.verbose('Adding clickaway events to context', O), k.closable && O.on(`click${b}`, w.event.clickaway).on(`touchend${b}`, w.event.clickaway); }, scrollLock() { k.scrollLock && (w.debug('Disabling page scroll'), s.on(`DOMMouseScroll${b}`, w.event.scroll)), w.verbose('Adding events to contain sidebar scroll'), c.on(`touchmove${b}`, w.event.touch), F.on(`scroll${E}`, w.event.containScroll); } },
        unbind: { clickaway() { w.verbose('Removing clickaway events from context', O), O.off(b); }, scrollLock() { w.verbose('Removing scroll lock from page'), c.off(b), s.off(b), F.off(`scroll${E}`); } },
        add: {
          inlineCSS() {
            let t; const n = w.cache.width || F.outerWidth(); const i = w.cache.height || F.outerHeight(); const o = w.is.rtl(); const a = w.get.direction(); const s = {
              left: n, right: -n, top: i, bottom: -i,
            }; o && (w.verbose('RTL detected, flipping widths'), s.left = -n, s.right = n), t = '<style>', a === 'left' || a === 'right' ? (w.debug('Adding CSS rules for animation distance', n), t += ` .ui.visible.${a}.sidebar ~ .fixed, .ui.visible.${a}.sidebar ~ .pusher {   -webkit-transform: translate3d(${s[a]}px, 0, 0);           transform: translate3d(${s[a]}px, 0, 0); }`) : (a === 'top' || a == 'bottom') && (t += ` .ui.visible.${a}.sidebar ~ .fixed, .ui.visible.${a}.sidebar ~ .pusher {   -webkit-transform: translate3d(0, ${s[a]}px, 0);           transform: translate3d(0, ${s[a]}px, 0); }`), w.is.ie() && (a === 'left' || a === 'right' ? (w.debug('Adding CSS rules for animation distance', n), t += ` body.pushable > .ui.visible.${a}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(${s[a]}px, 0, 0);           transform: translate3d(${s[a]}px, 0, 0); }`) : (a === 'top' || a == 'bottom') && (t += ` body.pushable > .ui.visible.${a}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0, ${s[a]}px, 0);           transform: translate3d(0, ${s[a]}px, 0); }`), t += ' body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0px, 0, 0);           transform: translate3d(0px, 0, 0); }'), t += '</style>', r = e(t).appendTo(u), w.debug('Adding sizing css to head', r);
          },
        },
        refresh() { w.verbose('Refreshing selector cache'), O = e(k.context), q = O.children(T.sidebar), I = O.children(T.pusher), j = O.children(T.fixed), w.clear.cache(); },
        refreshSidebars() { w.verbose('Refreshing other sidebars'), q = O.children(T.sidebar); },
        repaint() { w.verbose('Forcing repaint event'), z.style.display = 'none'; z.offsetHeight; z.scrollTop = z.scrollTop, z.style.display = ''; },
        setup: { cache() { w.cache = { width: F.outerWidth(), height: F.outerHeight(), rtl: F.css('direction') == 'rtl' }; }, layout() { O.children(T.pusher).length === 0 && (w.debug('Adding wrapper element for sidebar'), w.error(R.pusher), I = e('<div class="pusher" />'), O.children().not(T.omitted).not(q).wrapAll(I), w.refresh()), (F.nextAll(T.pusher).length === 0 || F.nextAll(T.pusher)[0] !== I[0]) && (w.debug('Moved sidebar to correct parent element'), w.error(R.movedSidebar, z), F.detach().prependTo(O), w.refresh()), w.clear.cache(), w.set.pushable(), w.set.direction(); } },
        attachEvents(t, n) { const i = e(t); n = e.isFunction(w[n]) ? w[n] : w.toggle, i.length > 0 ? (w.debug('Attaching sidebar events to element', t, n), i.on(`click${E}`, n)) : w.error(R.notFound, t); },
        show(t) { if (t = e.isFunction(t) ? t : function () {}, w.is.hidden()) { if (w.refreshSidebars(), k.overlay && (w.error(R.overlay), k.transition = 'overlay'), w.refresh(), w.othersActive()) if (w.debug('Other sidebars currently visible'), k.exclusive) { if (k.transition != 'overlay') return void w.hideOthers(w.show); w.hideOthers(); } else k.transition = 'overlay'; w.pushPage(() => { t.call(z), k.onShow.call(z); }), k.onChange.call(z), k.onVisible.call(z); } else w.debug('Sidebar is already visible'); },
        hide(t) { t = e.isFunction(t) ? t : function () {}, (w.is.visible() || w.is.animating()) && (w.debug('Hiding sidebar', t), w.refreshSidebars(), w.pullPage(() => { t.call(z), k.onHidden.call(z); }), k.onChange.call(z), k.onHide.call(z)); },
        othersAnimating() { return q.not(F).filter(`.${S.animating}`).length > 0; },
        othersVisible() { return q.not(F).filter(`.${S.visible}`).length > 0; },
        othersActive() { return w.othersVisible() || w.othersAnimating(); },
        hideOthers(e) { const t = q.not(F).filter(`.${S.visible}`); const n = t.length; let i = 0; e = e || function () {}, t.sidebar('hide', () => { i++, i == n && e(); }); },
        toggle() { w.verbose('Determining toggled direction'), w.is.hidden() ? w.show() : w.hide(); },
        pushPage(t) { let n; let i; let o; const a = w.get.transition(); const r = a === 'overlay' || w.othersActive() ? F : I; t = e.isFunction(t) ? t : function () {}, k.transition == 'scale down' && w.scrollToTop(), w.set.transition(a), w.repaint(), n = function () { w.bind.clickaway(), w.add.inlineCSS(), w.set.animating(), w.set.visible(); }, i = function () { w.set.dimmed(); }, o = function (e) { e.target == r[0] && (r.off(C + b, o), w.remove.animating(), w.bind.scrollLock(), t.call(z)); }, r.off(C + b), r.on(C + b, o), v(n), k.dimPage && !w.othersVisible() && v(i); },
        pullPage(t) { let n; let i; const o = w.get.transition(); const a = o == 'overlay' || w.othersActive() ? F : I; t = e.isFunction(t) ? t : function () {}, w.verbose('Removing context push state', w.get.direction()), w.unbind.clickaway(), w.unbind.scrollLock(), n = function () { w.set.transition(o), w.set.animating(), w.remove.visible(), k.dimPage && !w.othersVisible() && I.removeClass(S.dimmed); }, i = function (e) { e.target == a[0] && (a.off(C + b, i), w.remove.animating(), w.remove.transition(), w.remove.inlineCSS(), (o == 'scale down' || k.returnScroll && w.is.mobile()) && w.scrollBack(), t.call(z)); }, a.off(C + b), a.on(C + b, i), v(n); },
        scrollToTop() { w.verbose('Scrolling to top of page to avoid animation issues'), x = e(t).scrollTop(), F.scrollTop(0), t.scrollTo(0, 0); },
        scrollBack() { w.verbose('Scrolling back to original page position'), t.scrollTo(0, x); },
        clear: { cache() { w.verbose('Clearing cached dimensions'), w.cache = {}; } },
        set: {
          ios() { l.addClass(S.ios); }, pushed() { O.addClass(S.pushed); }, pushable() { O.addClass(S.pushable); }, dimmed() { I.addClass(S.dimmed); }, active() { F.addClass(S.active); }, animating() { F.addClass(S.animating); }, transition(e) { e = e || w.get.transition(), F.addClass(e); }, direction(e) { e = e || w.get.direction(), F.addClass(S[e]); }, visible() { F.addClass(S.visible); }, overlay() { F.addClass(S.overlay); },
        },
        remove: {
          inlineCSS() { w.debug('Removing inline css styles', r), r && r.length > 0 && r.remove(); }, ios() { l.removeClass(S.ios); }, pushed() { O.removeClass(S.pushed); }, pushable() { O.removeClass(S.pushable); }, active() { F.removeClass(S.active); }, animating() { F.removeClass(S.animating); }, transition(e) { e = e || w.get.transition(), F.removeClass(e); }, direction(e) { e = e || w.get.direction(), F.removeClass(S[e]); }, visible() { F.removeClass(S.visible); }, overlay() { F.removeClass(S.overlay); },
        },
        get: {
          direction() { return F.hasClass(S.top) ? S.top : F.hasClass(S.right) ? S.right : F.hasClass(S.bottom) ? S.bottom : S.left; },
          transition() { let e; const t = w.get.direction(); return e = w.is.mobile() ? k.mobileTransition == 'auto' ? k.defaultTransition.mobile[t] : k.mobileTransition : k.transition == 'auto' ? k.defaultTransition.computer[t] : k.transition, w.verbose('Determined transition', e), e; },
          transitionEvent() {
            let e; const t = n.createElement('element'); const o = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in o) if (t.style[e] !== i) return o[e];
          },
        },
        is: {
          ie() { const e = !t.ActiveXObject && 'ActiveXObject' in t; const n = 'ActiveXObject' in t; return e || n; }, ios() { const e = navigator.userAgent; const t = e.match(D.ios); const n = e.match(D.mobileChrome); return t && !n ? (w.verbose('Browser was found to be iOS', e), !0) : !1; }, mobile() { const e = navigator.userAgent; const t = e.match(D.mobile); return t ? (w.verbose('Browser was found to be mobile', e), !0) : (w.verbose('Browser is not mobile, using regular transition', e), !1); }, hidden() { return !w.is.visible(); }, visible() { return F.hasClass(S.visible); }, open() { return w.is.visible(); }, closed() { return w.is.hidden(); }, vertical() { return F.hasClass(S.top); }, animating() { return O.hasClass(S.animating); }, rtl() { return w.cache.rtl === i && (w.cache.rtl = F.css('direction') == 'rtl'), w.cache.rtl; },
        },
        setting(t, n) { if (w.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, k, t); else { if (n === i) return k[t]; k[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, w, t); else { if (n === i) return w[t]; w[t] = n; } },
        debug() { k.debug && (k.performance ? w.performance.log(arguments) : (w.debug = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.debug.apply(console, arguments))); },
        verbose() { k.verbose && k.debug && (k.performance ? w.performance.log(arguments) : (w.verbose = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.verbose.apply(console, arguments))); },
        error() { w.error = Function.prototype.bind.call(console.error, console, `${k.name}:`), w.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; k.performance && (t = (new Date()).getTime(), i = f || t, n = t - i, f = t, m.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: z, 'Execution Time': n,
            })), clearTimeout(w.performance.timer), w.performance.timer = setTimeout(w.performance.display, 500);
          },
          display() { let t = `${k.name}:`; let n = 0; f = !1, clearTimeout(w.performance.timer), e.each(m, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, d && (t += ` '${d}'`), (console.group !== i || console.table !== i) && m.length > 0 && (console.groupCollapsed(t), console.table ? console.table(m) : e.each(m, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), m = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = N; return n = n || h, o = z || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (w.error(R.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, p ? (N === i && w.initialize(), w.invoke(g)) : (N !== i && w.invoke('destroy'), w.initialize());
    }), a !== i ? a : this;
  }, e.fn.sidebar.settings = {
    name: 'Sidebar',
    namespace: 'sidebar',
    debug: !1,
    verbose: !1,
    performance: !0,
    transition: 'auto',
    mobileTransition: 'auto',
    defaultTransition: {
      computer: {
        left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
      },
      mobile: {
        left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
      },
    },
    context: 'body',
    exclusive: !1,
    closable: !0,
    dimPage: !0,
    scrollLock: !1,
    returnScroll: !1,
    delaySetup: !1,
    duration: 500,
    onChange() {},
    onShow() {},
    onHide() {},
    onHidden() {},
    onVisible() {},
    className: {
      active: 'active', animating: 'animating', dimmed: 'dimmed', ios: 'ios', pushable: 'pushable', pushed: 'pushed', right: 'right', top: 'top', left: 'left', bottom: 'bottom', visible: 'visible',
    },
    selector: {
      fixed: '.fixed', omitted: 'script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed', pusher: '.pusher', sidebar: '.ui.sidebar',
    },
    regExp: { ios: /(iPad|iPhone|iPod)/g, mobileChrome: /(CriOS)/g, mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g },
    error: {
      method: 'The method you called is not defined.', pusher: 'Had to add pusher element. For optimal performance make sure body content is inside a pusher element', movedSidebar: 'Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag', overlay: 'The overlay setting is no longer supported, use animation: overlay', notFound: 'There were no elements that matched the specified selector',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.sticky = function (n) {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; let f; let m; let g; const p = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.sticky.settings, n) : e.extend({}, e.fn.sticky.settings); const h = p.className; const v = p.namespace; const b = p.error; const y = `.${v}`; const x = `module-${v}`; const C = e(this); const w = e(t); const k = e(p.scrollContext); let T = (C.selector || '', C.data(x)); const S = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; const A = this; g = {
        initialize() { g.determineContainer(), g.determineContext(), g.verbose('Initializing sticky', p, a), g.save.positions(), g.checkErrors(), g.bind.events(), p.observeChanges && g.observeChanges(), g.instantiate(); },
        instantiate() { g.verbose('Storing instance of module', g), T = g, C.data(x, g); },
        destroy() { g.verbose('Destroying previous instance'), g.reset(), m && m.disconnect(), w.off(`load${y}`, g.event.load).off(`resize${y}`, g.event.resize), k.off(`scrollchange${y}`, g.event.scrollchange), C.removeData(x); },
        observeChanges() { const e = f[0]; 'MutationObserver' in t && (m = new MutationObserver((e) => { clearTimeout(g.timer), g.timer = setTimeout(() => { g.verbose('DOM tree modified, updating sticky menu', e), g.refresh(); }, 100); }), m.observe(A, { childList: !0, subtree: !0 }), m.observe(e, { childList: !0, subtree: !0 }), g.debug('Setting up mutation observer', m)); },
        determineContainer() { a = C.offsetParent(); },
        determineContext() { return f = p.context ? e(p.context) : a, f.length === 0 ? void g.error(b.invalidContext, p.context, C) : void 0; },
        checkErrors() { return g.is.hidden() && g.error(b.visible, C), g.cache.element.height > g.cache.context.height ? (g.reset(), void g.error(b.elementSize, C)) : void 0; },
        bind: { events() { w.on(`load${y}`, g.event.load).on(`resize${y}`, g.event.resize), k.off(`scroll${y}`).on(`scroll${y}`, g.event.scroll).on(`scrollchange${y}`, g.event.scrollchange); } },
        event: {
          load() { g.verbose('Page contents finished loading'), S(g.refresh); }, resize() { g.verbose('Window resized'), S(g.refresh); }, scroll() { S(() => { k.triggerHandler(`scrollchange${y}`, k.scrollTop()); }); }, scrollchange(e, t) { g.stick(t), p.onScroll.call(A); },
        },
        refresh(e) { g.reset(), p.context || g.determineContext(), e && g.determineContainer(), g.save.positions(), g.stick(), p.onReposition.call(A); },
        supports: { sticky() { const t = e('<div/>'); t[0]; return t.addClass(h.supported), t.css('position').match('sticky'); } },
        save: {
          lastScroll(e) { g.lastScroll = e; },
          elementScroll(e) { g.elementScroll = e; },
          positions() {
            const e = { height: w.height() }; const t = {
              margin: { top: parseInt(C.css('margin-top'), 10), bottom: parseInt(C.css('margin-bottom'), 10) }, offset: C.offset(), width: C.outerWidth(), height: C.outerHeight(),
            }; const n = { offset: f.offset(), height: f.outerHeight() }; ({ height: a.outerHeight() }); g.cache = {
              fits: t.height < e.height,
              window: { height: e.height },
              element: {
                margin: t.margin, top: t.offset.top - t.margin.top, left: t.offset.left, width: t.width, height: t.height, bottom: t.offset.top + t.height,
              },
              context: { top: n.offset.top, height: n.height, bottom: n.offset.top + n.height },
            }, g.set.containerSize(), g.set.size(), g.stick(), g.debug('Caching element positions', g.cache);
          },
        },
        get: {
          direction(e) { let t = 'down'; return e = e || k.scrollTop(), g.lastScroll !== i && (g.lastScroll < e ? t = 'down' : g.lastScroll > e && (t = 'up')), t; }, scrollChange(e) { return e = e || k.scrollTop(), g.lastScroll ? e - g.lastScroll : 0; }, currentElementScroll() { return g.elementScroll ? g.elementScroll : g.is.top() ? Math.abs(parseInt(C.css('top'), 10)) || 0 : Math.abs(parseInt(C.css('bottom'), 10)) || 0; }, elementScroll(e) { e = e || k.scrollTop(); const t = g.cache.element; const n = g.cache.window; const i = g.get.scrollChange(e); const o = t.height - n.height + p.offset; let a = g.get.currentElementScroll(); const r = a + i; return a = g.cache.fits || r < 0 ? 0 : r > o ? o : r; },
        },
        remove: { lastScroll() { delete g.lastScroll; }, elementScroll(e) { delete g.elementScroll; }, offset() { C.css('margin-top', ''); } },
        set: {
          offset() { g.verbose('Setting offset on element', p.offset), C.css('margin-top', p.offset); }, containerSize() { const e = a.get(0).tagName; e === 'HTML' || e == 'body' ? g.determineContainer() : Math.abs(a.outerHeight() - g.cache.context.height) > p.jitter && (g.debug('Context has padding, specifying exact height for container', g.cache.context.height), a.css({ height: g.cache.context.height })); }, minimumSize() { const e = g.cache.element; a.css('min-height', e.height); }, scroll(e) { g.debug('Setting scroll on element', e), g.elementScroll != e && (g.is.top() && C.css('bottom', '').css('top', -e), g.is.bottom() && C.css('top', '').css('bottom', e)); }, size() { g.cache.element.height !== 0 && g.cache.element.width !== 0 && (A.style.setProperty('width', `${g.cache.element.width}px`, 'important'), A.style.setProperty('height', `${g.cache.element.height}px`, 'important')); },
        },
        is: {
          top() { return C.hasClass(h.top); }, bottom() { return C.hasClass(h.bottom); }, initialPosition() { return !g.is.fixed() && !g.is.bound(); }, hidden() { return !C.is(':visible'); }, bound() { return C.hasClass(h.bound); }, fixed() { return C.hasClass(h.fixed); },
        },
        stick(e) { const t = e || k.scrollTop(); const n = g.cache; const i = n.fits; const o = n.element; const a = n.window; const r = n.context; const s = g.is.bottom() && p.pushing ? p.bottomOffset : p.offset; var e = { top: t + s, bottom: t + s + a.height }; const c = (g.get.direction(e.top), i ? 0 : g.get.elementScroll(e.top)); const l = !i; const u = o.height !== 0; u && (g.is.initialPosition() ? e.top >= r.bottom ? (g.debug('Initial element position is bottom of container'), g.bindBottom()) : e.top > o.top && (o.height + e.top - c >= r.bottom ? (g.debug('Initial element position is bottom of container'), g.bindBottom()) : (g.debug('Initial element position is fixed'), g.fixTop())) : g.is.fixed() ? g.is.top() ? e.top <= o.top ? (g.debug('Fixed element reached top of container'), g.setInitialPosition()) : o.height + e.top - c >= r.bottom ? (g.debug('Fixed element reached bottom of container'), g.bindBottom()) : l && (g.set.scroll(c), g.save.lastScroll(e.top), g.save.elementScroll(c)) : g.is.bottom() && (e.bottom - o.height <= o.top ? (g.debug('Bottom fixed rail has reached top of container'), g.setInitialPosition()) : e.bottom >= r.bottom ? (g.debug('Bottom fixed rail has reached bottom of container'), g.bindBottom()) : l && (g.set.scroll(c), g.save.lastScroll(e.top), g.save.elementScroll(c))) : g.is.bottom() && (p.pushing ? g.is.bound() && e.bottom <= r.bottom && (g.debug('Fixing bottom attached element to bottom of browser.'), g.fixBottom()) : g.is.bound() && e.top <= r.bottom - o.height && (g.debug('Fixing bottom attached element to top of browser.'), g.fixTop()))); },
        bindTop() {
          g.debug('Binding element to top of parent container'), g.remove.offset(), C.css({ left: '', top: '', marginBottom: '' }).removeClass(h.fixed).removeClass(h.bottom).addClass(h.bound)
            .addClass(h.top), p.onTop.call(A), p.onUnstick.call(A);
        },
        bindBottom() {
          g.debug('Binding element to bottom of parent container'), g.remove.offset(), C.css({ left: '', top: '' }).removeClass(h.fixed).removeClass(h.top).addClass(h.bound)
            .addClass(h.bottom), p.onBottom.call(A), p.onUnstick.call(A);
        },
        setInitialPosition() { g.debug('Returning to initial position'), g.unfix(), g.unbind(); },
        fixTop() {
          g.debug('Fixing element to top of page'), g.set.minimumSize(), g.set.offset(), C.css({ left: g.cache.element.left, bottom: '', marginBottom: '' }).removeClass(h.bound).removeClass(h.bottom).addClass(h.fixed)
            .addClass(h.top), p.onStick.call(A);
        },
        fixBottom() {
          g.debug('Sticking element to bottom of page'), g.set.minimumSize(), g.set.offset(), C.css({ left: g.cache.element.left, bottom: '', marginBottom: '' }).removeClass(h.bound).removeClass(h.top).addClass(h.fixed)
            .addClass(h.bottom), p.onStick.call(A);
        },
        unbind() { g.is.bound() && (g.debug('Removing container bound position on element'), g.remove.offset(), C.removeClass(h.bound).removeClass(h.top).removeClass(h.bottom)); },
        unfix() { g.is.fixed() && (g.debug('Removing fixed position on element'), g.remove.offset(), C.removeClass(h.fixed).removeClass(h.top).removeClass(h.bottom), p.onUnstick.call(A)); },
        reset() { g.debug('Reseting elements position'), g.unbind(), g.unfix(), g.resetCSS(), g.remove.offset(), g.remove.lastScroll(); },
        resetCSS() { C.css({ width: '', height: '' }), a.css({ height: '' }); },
        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (n === i) return p[t]; p[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (n === i) return g[t]; g[t] = n; } },
        debug() { p.debug && (p.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.debug.apply(console, arguments))); },
        verbose() { p.verbose && p.debug && (p.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.verbose.apply(console, arguments))); },
        error() { g.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), g.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; p.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: A, 'Execution Time': n,
            })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 0);
          },
          display() { let t = `${p.name}:`; let n = 0; s = !1, clearTimeout(g.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = T; return n = n || d, a = A || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, u ? (T === i && g.initialize(), g.invoke(l)) : (T !== i && T.invoke('destroy'), g.initialize());
    }), o !== i ? o : this;
  }, e.fn.sticky.settings = {
    name: 'Sticky',
    namespace: 'sticky',
    debug: !1,
    verbose: !0,
    performance: !0,
    pushing: !1,
    context: !1,
    scrollContext: t,
    offset: 0,
    bottomOffset: 0,
    jitter: 5,
    observeChanges: !1,
    onReposition() {},
    onScroll() {},
    onStick() {},
    onUnstick() {},
    onTop() {},
    onBottom() {},
    error: {
      container: 'Sticky element must be inside a relative container', visible: 'Element is hidden, you must call refresh after element becomes visible', method: 'The method you called is not defined.', invalidContext: 'Context specified does not exist', elementSize: 'Sticky element is larger than its container, cannot create sticky.',
    },
    className: {
      bound: 'bound', fixed: 'fixed', supported: 'native', top: 'top', bottom: 'bottom',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.tab = function (o) {
    let a; const r = e(e.isFunction(this) ? t : this); const s = r.selector || ''; let c = (new Date()).getTime(); let l = []; const u = arguments[0]; const d = typeof u === 'string'; const f = [].slice.call(arguments, 1); let m = !1; return r.each(function () {
      let g; let p; let h; let v; let b; let y; let x = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.tab.settings, o) : e.extend({}, e.fn.tab.settings); const C = x.className; const w = x.metadata; const k = x.selector; const T = x.error; const S = `.${x.namespace}`; const A = `module-${x.namespace}`; const D = e(this); const R = {}; let E = !0; let P = 0; const F = this; let O = D.data(A); b = {
        initialize() { b.debug('Initializing tab menu item', D), b.fix.callbacks(), b.determineTabs(), b.debug('Determining tabs', x.context, p), x.auto && b.set.auto(), b.bind.events(), x.history && !m && (b.initializeHistory(), m = !0), b.instantiate(); },
        instantiate() { b.verbose('Storing instance of module', b), O = b, D.data(A, b); },
        destroy() { b.debug('Destroying tabs', D), D.removeData(A).off(S); },
        bind: { events() { e.isWindow(F) || (b.debug('Attaching tab activation events to element', D), D.on(`click${S}`, b.event.click)); } },
        determineTabs() { let t; x.context === 'parent' ? (D.closest(k.ui).length > 0 ? (t = D.closest(k.ui), b.verbose('Using closest UI element as parent', t)) : t = D, g = t.parent(), b.verbose('Determined parent element for creating context', g)) : x.context ? (g = e(x.context), b.verbose('Using selector for tab context', x.context, g)) : g = e('body'), x.childrenOnly ? (p = g.children(k.tabs), b.debug('Searching tab context children for tabs', g, p)) : (p = g.find(k.tabs), b.debug('Searching tab context for tabs', g, p)); },
        fix: { callbacks() { e.isPlainObject(o) && (o.onTabLoad || o.onTabInit) && (o.onTabLoad && (o.onLoad = o.onTabLoad, delete o.onTabLoad, b.error(T.legacyLoad, o.onLoad)), o.onTabInit && (o.onFirstLoad = o.onTabInit, delete o.onTabInit, b.error(T.legacyInit, o.onFirstLoad)), x = e.extend(!0, {}, e.fn.tab.settings, o)); } },
        initializeHistory() { if (b.debug('Initializing page state'), e.address === i) return b.error(T.state), !1; if (x.historyType == 'state') { if (b.debug('Using HTML5 to manage state'), x.path === !1) return b.error(T.path), !1; e.address.history(!0).state(x.path); }e.address.bind('change', b.event.history.change); },
        event: { click(t) { const n = e(this).data(w.tab); n !== i ? (x.history ? (b.verbose('Updating page state', t), e.address.value(n)) : (b.verbose('Changing tab', t), b.changeTab(n)), t.preventDefault()) : b.debug('No tab specified'); }, history: { change(t) { const n = t.pathNames.join('/') || b.get.initialPath(); const o = x.templates.determineTitle(n) || !1; b.performance.display(), b.debug('History change event', n, t), y = t, n !== i && b.changeTab(n), o && e.address.title(o); } } },
        refresh() { h && (b.debug('Refreshing tab', h), b.changeTab(h)); },
        cache: { read(e) { return e !== i ? R[e] : !1; }, add(e, t) { e = e || h, b.debug('Adding cached content for', e), R[e] = t; }, remove(e) { e = e || h, b.debug('Removing cached content for', e), delete R[e]; } },
        set: { auto() { const t = typeof x.path === 'string' ? `${x.path.replace(/\/$/, '')}/{$tab}` : '/{$tab}'; b.verbose('Setting up automatic tab retrieval from server', t), e.isPlainObject(x.apiSettings) ? x.apiSettings.url = t : x.apiSettings = { url: t }; }, loading(e) { const t = b.get.tabElement(e); const n = t.hasClass(C.loading); n || (b.verbose('Setting loading state for', t), t.addClass(C.loading).siblings(p).removeClass(`${C.active} ${C.loading}`), t.length > 0 && x.onRequest.call(t[0], e)); }, state(t) { e.address.value(t); } },
        changeTab(n) { const i = t.history && t.history.pushState; const o = i && x.ignoreFirstLoad && E; const a = x.auto || e.isPlainObject(x.apiSettings); const r = a && !o ? b.utilities.pathToArray(n) : b.get.defaultPathArray(n); n = b.utilities.arrayToPath(r), e.each(r, (t, i) => { let s; let c; let l; let u; const d = r.slice(0, t + 1); let f = b.utilities.arrayToPath(d); const m = b.is.tab(f); const p = t + 1 == r.length; let k = b.get.tabElement(f); if (b.verbose('Looking for tab', i), m) { if (b.verbose('Tab was found', i), h = f, v = b.utilities.filterArray(r, d), p ? u = !0 : (c = r.slice(0, t + 2), l = b.utilities.arrayToPath(c), u = !b.is.tab(l), u && b.verbose('Tab parameters found', c)), u && a) return o ? (b.debug('Ignoring remote content on first tab load', f), E = !1, b.cache.add(n, k.html()), b.activate.all(f), x.onFirstLoad.call(k[0], f, v, y), x.onLoad.call(k[0], f, v, y)) : (b.activate.navigation(f), b.fetch.content(f, n)), !1; b.debug('Opened local tab', f), b.activate.all(f), b.cache.read(f) || (b.cache.add(f, !0), b.debug('First time tab loaded calling tab init'), x.onFirstLoad.call(k[0], f, v, y)), x.onLoad.call(k[0], f, v, y); } else { if (n.search('/') != -1 || n === '') return b.error(T.missingTab, D, g, f), !1; if (s = e(`#${n}, a[name="${n}"]`), f = s.closest('[data-tab]').data(w.tab), k = b.get.tabElement(f), s && s.length > 0 && f) return b.debug('Anchor link used, opening parent tab', k, s), k.hasClass(C.active) || setTimeout(() => { b.scrollTo(s); }, 0), b.activate.all(f), b.cache.read(f) || (b.cache.add(f, !0), b.debug('First time tab loaded calling tab init'), x.onFirstLoad.call(k[0], f, v, y)), x.onLoad.call(k[0], f, v, y), !1; } }); },
        scrollTo(t) { const i = t && t.length > 0 ? t.offset().top : !1; i !== !1 && (b.debug('Forcing scroll to an in-page link in a hidden tab', i, t), e(n).scrollTop(i)); },
        update: { content(e, t, n) { const o = b.get.tabElement(e); const a = o[0]; n = n !== i ? n : x.evaluateScripts, n ? (b.debug('Updating HTML and evaluating inline scripts', e, t), o.html(t)) : (b.debug('Updating HTML', e, t), a.innerHTML = t); } },
        fetch: {
          content(t, n) {
            let o; let a; const r = b.get.tabElement(t); const s = {
              dataType: 'html', encodeParameters: !1, on: 'now', cache: x.alwaysRefresh, headers: { 'X-Remote': !0 }, onSuccess(e) { b.cache.add(n, e), b.update.content(t, e), t == h ? (b.debug('Content loaded', t), b.activate.tab(t)) : b.debug('Content loaded in background', t), x.onFirstLoad.call(r[0], t, v, y), x.onLoad.call(r[0], t, v, y); }, urlData: { tab: n },
            }; const c = r.api('get request') || !1; const l = c && c.state() === 'pending'; n = n || t, a = b.cache.read(n), x.cache && a ? (b.activate.tab(t), b.debug('Adding cached content', n), x.evaluateScripts == 'once' ? b.update.content(t, a, !1) : b.update.content(t, a), x.onLoad.call(r[0], t, v, y)) : l ? (b.set.loading(t), b.debug('Content is already loading', n)) : e.api !== i ? (o = e.extend(!0, {}, x.apiSettings, s), b.debug('Retrieving remote content', n, o), b.set.loading(t), r.api(o)) : b.error(T.api);
          },
        },
        activate: { all(e) { b.activate.tab(e), b.activate.navigation(e); }, tab(e) { const t = b.get.tabElement(e); const n = t.hasClass(C.active); b.verbose('Showing tab content for', t), n || (t.addClass(C.active).siblings(p).removeClass(`${C.active} ${C.loading}`), t.length > 0 && x.onVisible.call(t[0], e)); }, navigation(e) { const t = b.get.navElement(e); const n = t.hasClass(C.active); b.verbose('Activating tab navigation for', t, e), n || t.addClass(C.active).siblings(r).removeClass(`${C.active} ${C.loading}`); } },
        deactivate: { all() { b.deactivate.navigation(), b.deactivate.tabs(); }, navigation() { r.removeClass(C.active); }, tabs() { p.removeClass(`${C.active} ${C.loading}`); } },
        is: { tab(e) { return e !== i ? b.get.tabElement(e).length > 0 : !1; } },
        get: {
          initialPath() { return r.eq(0).data(w.tab) || p.eq(0).data(w.tab); }, path() { return e.address.value(); }, defaultPathArray(e) { return b.utilities.pathToArray(b.get.defaultPath(e)); }, defaultPath(e) { const t = r.filter(`[data-${w.tab}^="${e}/"]`).eq(0); const n = t.data(w.tab) || !1; if (n) { if (b.debug('Found default tab', n), P < x.maxDepth) return P++, b.get.defaultPath(n); b.error(T.recursion); } else b.debug('No default tabs found for', e, p); return P = 0, e; }, navElement(e) { return e = e || h, r.filter(`[data-${w.tab}="${e}"]`); }, tabElement(e) { let t; let n; let i; let o; return e = e || h, i = b.utilities.pathToArray(e), o = b.utilities.last(i), t = p.filter(`[data-${w.tab}="${e}"]`), n = p.filter(`[data-${w.tab}="${o}"]`), t.length > 0 ? t : n; }, tab() { return h; },
        },
        utilities: {
          filterArray(t, n) { return e.grep(t, (t) => e.inArray(t, n) == -1); },
          last(t) { return e.isArray(t) ? t[t.length - 1] : !1; },
          pathToArray(e) { return e === i && (e = h), typeof e === 'string' ? e.split('/') : [e]; },
          arrayToPath(t) {
            return e.isArray(t) ? t.join('/') : !1;
          },
        },
        setting(t, n) { if (b.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, x, t); else { if (n === i) return x[t]; x[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, b, t); else { if (n === i) return b[t]; b[t] = n; } },
        debug() { x.debug && (x.performance ? b.performance.log(arguments) : (b.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), b.debug.apply(console, arguments))); },
        verbose() { x.verbose && x.debug && (x.performance ? b.performance.log(arguments) : (b.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), b.verbose.apply(console, arguments))); },
        error() { b.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), b.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; x.performance && (t = (new Date()).getTime(), i = c || t, n = t - i, c = t, l.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: F, 'Execution Time': n,
            })), clearTimeout(b.performance.timer), b.performance.timer = setTimeout(b.performance.display, 500);
          },
          display() { let t = `${x.name}:`; let n = 0; c = !1, clearTimeout(b.performance.timer), e.each(l, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, s && (t += ` '${s}'`), (console.group !== i || console.table !== i) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = O; return n = n || f, o = F || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (b.error(T.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, d ? (O === i && b.initialize(), b.invoke(u)) : (O !== i && O.invoke('destroy'), b.initialize());
    }), a !== i ? a : this;
  }, e.tab = function () { e(t).tab.apply(this, arguments); }, e.fn.tab.settings = {
    name: 'Tab',
    namespace: 'tab',
    debug: !1,
    verbose: !1,
    performance: !0,
    auto: !1,
    history: !1,
    historyType: 'hash',
    path: !1,
    context: !1,
    childrenOnly: !1,
    maxDepth: 25,
    alwaysRefresh: !1,
    cache: !0,
    ignoreFirstLoad: !1,
    apiSettings: !1,
    evaluateScripts: 'once',
    onFirstLoad(e, t, n) {},
    onLoad(e, t, n) {},
    onVisible(e, t, n) {},
    onRequest(e, t, n) {},
    templates: { determineTitle(e) {} },
    error: {
      api: 'You attempted to load content without API module', method: 'The method you called is not defined', missingTab: 'Activated tab cannot be found. Tabs are case-sensitive.', noContent: 'The tab you specified is missing a content url.', path: 'History enabled, but no path was specified', recursion: 'Max recursive depth reached', legacyInit: 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.', legacyLoad: 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code', state: "History requires Asual's Address library <https://github.com/asual/jquery-address>",
    },
    metadata: { tab: 'tab', loaded: 'loaded', promise: 'promise' },
    className: { loading: 'loading', active: 'active' },
    selector: { tabs: '.ui.tab', ui: '.ui' },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.transition = function () {
    let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments; const u = l[0]; const d = [].slice.call(arguments, 1); let f = typeof u === 'string'; t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return a.each(function (t) {
      let m; let g; let p; let h; let v; let b; let y; let x; let C; const w = e(this); const k = this; C = {
        initialize() { m = C.get.settings.apply(k, l), h = m.className, p = m.error, v = m.metadata, x = `.${m.namespace}`, y = `module-${m.namespace}`, g = w.data(y) || C, b = C.get.animationEndEvent(), f && (f = C.invoke(u)), f === !1 && (C.verbose('Converted arguments into settings object', m), m.interval ? C.delay(m.animate) : C.animate(), C.instantiate()); },
        instantiate() { C.verbose('Storing instance of module', C), g = C, w.data(y, g); },
        destroy() { C.verbose('Destroying previous module for', k), w.removeData(y); },
        refresh() { C.verbose('Refreshing display type on next animation'), delete C.displayType; },
        forceRepaint() { C.verbose('Forcing element repaint'); const e = w.parent(); const t = w.next(); t.length === 0 ? w.detach().appendTo(e) : w.detach().insertBefore(t); },
        repaint() { C.verbose('Repainting element'); k.offsetWidth; },
        delay(e) { let n; let o; let r = C.get.animationDirection(); r || (r = C.can.transition() ? C.get.direction() : 'static'), e = e !== i ? e : m.interval, n = m.reverse == 'auto' && r == h.outward, o = n || m.reverse == 1 ? (a.length - t) * m.interval : t * m.interval, C.debug('Delaying animation by', o), setTimeout(C.animate, o); },
        animate(e) { if (m = e || m, !C.is.supported()) return C.error(p.support), !1; if (C.debug('Preparing animation', m.animation), C.is.animating()) { if (m.queue) return !m.allowRepeats && C.has.direction() && C.is.occurring() && C.queuing !== !0 ? C.debug('Animation is currently occurring, preventing queueing same animation', m.animation) : C.queue(m.animation), !1; if (!m.allowRepeats && C.is.occurring()) return C.debug('Animation is already occurring, will not execute repeated animation', m.animation), !1; C.debug('New animation started, completing previous early', m.animation), g.complete(); }C.can.animate() ? C.set.animating(m.animation) : C.error(p.noAnimation, m.animation, k); },
        reset() { C.debug('Resetting animation to beginning conditions'), C.remove.animationCallbacks(), C.restore.conditions(), C.remove.animating(); },
        queue(e) { C.debug('Queueing animation of', e), C.queuing = !0, w.one(`${b}.queue${x}`, function () { C.queuing = !1, C.repaint(), C.animate.apply(this, m); }); },
        complete(e) { C.debug('Animation complete', m.animation), C.remove.completeCallback(), C.remove.failSafe(), C.is.looping() || (C.is.outward() ? (C.verbose('Animation is outward, hiding element'), C.restore.conditions(), C.hide()) : C.is.inward() ? (C.verbose('Animation is outward, showing element'), C.restore.conditions(), C.show()) : C.restore.conditions()); },
        force: { visible() { const e = w.attr('style'); const t = C.get.userStyle(); const n = C.get.displayType(); const o = `${t}display: ${n} !important;`; const a = w.css('display'); const r = e === i || e === ''; a !== n ? (C.verbose('Overriding default display to show element', n), w.attr('style', o)) : r && w.removeAttr('style'); }, hidden() { const e = w.attr('style'); const t = w.css('display'); const n = e === i || e === ''; t === 'none' || C.is.hidden() ? n && w.removeAttr('style') : (C.verbose('Overriding default display to hide element'), w.css('display', 'none')); } },
        has: { direction(t) { let n = !1; return t = t || m.animation, typeof t === 'string' && (t = t.split(' '), e.each(t, (e, t) => { (t === h.inward || t === h.outward) && (n = !0); })), n; }, inlineDisplay() { const t = w.attr('style') || ''; return e.isArray(t.match(/display.*?;/, '')); } },
        set: {
          animating(e) { let t; C.remove.completeCallback(), e = e || m.animation, t = C.get.animationClass(e), C.save.animation(t), C.force.visible(), C.remove.hidden(), C.remove.direction(), C.start.animation(t); }, duration(e, t) { t = t || m.duration, t = typeof t === 'number' ? `${t}ms` : t, (t || t === 0) && (C.verbose('Setting animation duration', t), w.css({ 'animation-duration': t })); }, direction(e) { e = e || C.get.direction(), e == h.inward ? C.set.inward() : C.set.outward(); }, looping() { C.debug('Transition set to loop'), w.addClass(h.looping); }, hidden() { w.addClass(h.transition).addClass(h.hidden); }, inward() { C.debug('Setting direction to inward'), w.removeClass(h.outward).addClass(h.inward); }, outward() { C.debug('Setting direction to outward'), w.removeClass(h.inward).addClass(h.outward); }, visible() { w.addClass(h.transition).addClass(h.visible); },
        },
        start: { animation(e) { e = e || C.get.animationClass(), C.debug('Starting tween', e), w.addClass(e).one(`${b}.complete${x}`, C.complete), m.useFailSafe && C.add.failSafe(), C.set.duration(m.duration), m.onStart.call(k); } },
        save: { animation(e) { C.cache || (C.cache = {}), C.cache.animation = e; }, displayType(e) { e !== 'none' && w.data(v.displayType, e); }, transitionExists(t, n) { e.fn.transition.exists[t] = n, C.verbose('Saving existence of transition', t, n); } },
        restore: { conditions() { const e = C.get.currentAnimation(); e && (w.removeClass(e), C.verbose('Removing animation class', C.cache)), C.remove.duration(); } },
        add: { failSafe() { const e = C.get.duration(); C.timer = setTimeout(() => { w.triggerHandler(b); }, e + m.failSafeDelay), C.verbose('Adding fail safe timer', C.timer); } },
        remove: {
          animating() { w.removeClass(h.animating); }, animationCallbacks() { C.remove.queueCallback(), C.remove.completeCallback(); }, queueCallback() { w.off(`.queue${x}`); }, completeCallback() { w.off(`.complete${x}`); }, display() { w.css('display', ''); }, direction() { w.removeClass(h.inward).removeClass(h.outward); }, duration() { w.css('animation-duration', ''); }, failSafe() { C.verbose('Removing fail safe timer', C.timer), C.timer && clearTimeout(C.timer); }, hidden() { w.removeClass(h.hidden); }, visible() { w.removeClass(h.visible); }, looping() { C.debug('Transitions are no longer looping'), C.is.looping() && (C.reset(), w.removeClass(h.looping)); }, transition() { w.removeClass(h.visible).removeClass(h.hidden); },
        },
        get: {
          settings(t, n, i) { return typeof t === 'object' ? e.extend(!0, {}, e.fn.transition.settings, t) : typeof i === 'function' ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: i, duration: n }) : typeof n === 'string' || typeof n === 'number' ? e.extend({}, e.fn.transition.settings, { animation: t, duration: n }) : typeof n === 'object' ? e.extend({}, e.fn.transition.settings, n, { animation: t }) : typeof n === 'function' ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: n }) : e.extend({}, e.fn.transition.settings, { animation: t }); },
          animationClass(e) { const t = e || m.animation; const n = C.can.transition() && !C.has.direction() ? `${C.get.direction()} ` : ''; return `${h.animating} ${h.transition} ${n}${t}`; },
          currentAnimation() { return C.cache && C.cache.animation !== i ? C.cache.animation : !1; },
          currentDirection() { return C.is.inward() ? h.inward : h.outward; },
          direction() { return C.is.hidden() || !C.is.visible() ? h.inward : h.outward; },
          animationDirection(t) { let n; return t = t || m.animation, typeof t === 'string' && (t = t.split(' '), e.each(t, (e, t) => { t === h.inward ? n = h.inward : t === h.outward && (n = h.outward); })), n || !1; },
          duration(e) { return e = e || m.duration, e === !1 && (e = w.css('animation-duration') || 0), typeof e === 'string' ? e.indexOf('ms') > -1 ? parseFloat(e) : 1e3 * parseFloat(e) : e; },
          displayType() { return m.displayType ? m.displayType : (w.data(v.displayType) === i && C.can.transition(!0), w.data(v.displayType)); },
          userStyle(e) { return e = e || w.attr('style') || '', e.replace(/display.*?;/, ''); },
          transitionExists(t) { return e.fn.transition.exists[t]; },
          animationStartEvent() {
            let e; const t = n.createElement('div'); const o = {
              animation: 'animationstart', OAnimation: 'oAnimationStart', MozAnimation: 'mozAnimationStart', WebkitAnimation: 'webkitAnimationStart',
            }; for (e in o) if (t.style[e] !== i) return o[e]; return !1;
          },
          animationEndEvent() {
            let e; const t = n.createElement('div'); const o = {
              animation: 'animationend', OAnimation: 'oAnimationEnd', MozAnimation: 'mozAnimationEnd', WebkitAnimation: 'webkitAnimationEnd',
            }; for (e in o) if (t.style[e] !== i) return o[e]; return !1;
          },
        },
        can: {
          transition(t) {
            let n; let o; let a; let r; let s; let c; let l; const u = m.animation; const d = C.get.transitionExists(u); if (d === i || t) {
              if (C.verbose('Determining whether animation exists'), n = w.attr('class'), o = w.prop('tagName'), a = e(`<${o} />`).addClass(n).insertAfter(w), r = a.addClass(u).removeClass(h.inward).removeClass(h.outward).addClass(h.animating)
                .addClass(h.transition)
                .css('animationName'), s = a.addClass(h.inward).css('animationName'), l = a.attr('class', n).removeAttr('style').removeClass(h.hidden).removeClass(h.visible)
                .show()
                .css('display'), C.verbose('Determining final display state', l), C.save.displayType(l), a.remove(), r != s)C.debug('Direction exists for animation', u), c = !0; else { if (r == 'none' || !r) return void C.debug('No animation defined in css', u); C.debug('Static animation found', u, l), c = !1; }C.save.transitionExists(u, c);
            } return d !== i ? d : c;
          },
          animate() { return C.can.transition() !== i; },
        },
        is: {
          animating() { return w.hasClass(h.animating); }, inward() { return w.hasClass(h.inward); }, outward() { return w.hasClass(h.outward); }, looping() { return w.hasClass(h.looping); }, occurring(e) { return e = e || m.animation, e = `.${e.replace(' ', '.')}`, w.filter(e).length > 0; }, visible() { return w.is(':visible'); }, hidden() { return w.css('visibility') === 'hidden'; }, supported() { return b !== !1; },
        },
        hide() { C.verbose('Hiding element'), C.is.animating() && C.reset(), k.blur(), C.remove.display(), C.remove.visible(), C.set.hidden(), C.force.hidden(), m.onHide.call(k), m.onComplete.call(k); },
        show(e) { C.verbose('Showing element', e), C.remove.hidden(), C.set.visible(), C.force.visible(), m.onShow.call(k), m.onComplete.call(k); },
        toggle() { C.is.visible() ? C.hide() : C.show(); },
        stop() { C.debug('Stopping current animation'), w.triggerHandler(b); },
        stopAll() { C.debug('Stopping all animation'), C.remove.queueCallback(), w.triggerHandler(b); },
        clear: { queue() { C.debug('Clearing animation queue'), C.remove.queueCallback(); } },
        enable() { C.verbose('Starting animation'), w.removeClass(h.disabled); },
        disable() { C.debug('Stopping animation'), w.addClass(h.disabled); },
        setting(t, n) { if (C.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (n === i) return m[t]; m[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, C, t); else { if (n === i) return C[t]; C[t] = n; } },
        debug() { m.debug && (m.performance ? C.performance.log(arguments) : (C.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), C.debug.apply(console, arguments))); },
        verbose() { m.verbose && m.debug && (m.performance ? C.performance.log(arguments) : (C.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), C.verbose.apply(console, arguments))); },
        error() { C.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), C.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: k, 'Execution Time': n,
            })), clearTimeout(C.performance.timer), C.performance.timer = setTimeout(C.performance.display, 500);
          },
          display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(C.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), a.length > 1 && (t += ` (${a.length})`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, n, a) { let r; let s; let c; let l = g; return n = n || d, a = k || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : !1; l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s !== i ? s : !1; },
      }, C.initialize();
    }), o !== i ? o : this;
  }, e.fn.transition.exists = {}, e.fn.transition.settings = {
    name: 'Transition',
    debug: !1,
    verbose: !1,
    performance: !0,
    namespace: 'transition',
    interval: 0,
    reverse: 'auto',
    onStart() {},
    onComplete() {},
    onShow() {},
    onHide() {},
    useFailSafe: !0,
    failSafeDelay: 100,
    allowRepeats: !1,
    displayType: !1,
    animation: 'fade',
    duration: !1,
    queue: !0,
    metadata: { displayType: 'display' },
    className: {
      animating: 'animating', disabled: 'disabled', hidden: 'hidden', inward: 'in', loading: 'loading', looping: 'looping', outward: 'out', transition: 'transition', visible: 'visible',
    },
    error: {
      noAnimation: 'There is no css animation matching the one you specified. Please make sure your css is vendor prefixed, and you have included transition css.', repeated: 'That animation is already occurring, cancelling repeated animation', method: 'The method you called is not defined', support: 'This browser does not support CSS animations',
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.api = e.fn.api = function (n) {
    let o; const a = e(e.isFunction(this) ? t : this); const r = a.selector || ''; let s = (new Date()).getTime(); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let a; let f; let m; let g; let p; let h; const v = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.api.settings, n) : e.extend({}, e.fn.api.settings); const b = v.namespace; const y = v.metadata; const x = v.selector; const C = v.error; const w = v.className; const k = `.${b}`; const T = `module-${b}`; const S = e(this); const A = S.closest(x.form); const D = v.stateContext ? e(v.stateContext) : S; const R = this; const E = D[0]; let P = S.data(T); h = {
        initialize() { u || h.bind.events(), h.instantiate(); },
        instantiate() { h.verbose('Storing instance of module', h), P = h, S.data(T, P); },
        destroy() { h.verbose('Destroying previous module for', R), S.removeData(T).off(k); },
        bind: { events() { const e = h.get.event(); e ? (h.verbose('Attaching API events to element', e), S.on(e + k, h.event.trigger)) : v.on == 'now' && (h.debug('Querying API endpoint immediately'), h.query()); } },
        decode: { json(e) { if (e !== i && typeof e === 'string') try { e = JSON.parse(e); } catch (t) {} return e; } },
        read: { cachedResponse(e) { let n; return t.Storage === i ? void h.error(C.noStorage) : (n = sessionStorage.getItem(e), h.debug('Using cached response', e, n), n = h.decode.json(n), !1); } },
        write: { cachedResponse(n, o) { return o && o === '' ? void h.debug('Response empty, not caching', o) : t.Storage === i ? void h.error(C.noStorage) : (e.isPlainObject(o) && (o = JSON.stringify(o)), sessionStorage.setItem(n, o), void h.verbose('Storing cached response for url', n, o)); } },
        query() {
          if (h.is.disabled()) return void h.debug('Element is disabled API request aborted'); if (h.is.loading()) { if (!v.interruptRequests) return void h.debug('Cancelling request, previous request is still pending'); h.debug('Interrupting previous request'), h.abort(); } return v.defaultData && e.extend(!0, v.urlData, h.get.defaultData()), v.serializeForm && (v.data = h.add.formData(v.data)), f = h.get.settings(), f === !1 ? (h.cancelled = !0, void h.error(C.beforeSend)) : (h.cancelled = !1, m = h.get.templatedURL(), m || h.is.mocked() ? (m = h.add.urlData(m), m || h.is.mocked() ? (a = e.extend(!0, {}, v, {
            type: v.method || v.type, data: g, url: v.base + m, beforeSend: v.beforeXHR, success() {}, failure() {}, complete() {},
          }), h.debug('Querying URL', a.url), h.verbose('Using AJAX settings', a), v.cache === 'local' && h.read.cachedResponse(m) ? (h.debug('Response returned from local cache'), h.request = h.create.request(), void h.request.resolveWith(E, [h.read.cachedResponse(m)])) : void (v.throttle ? v.throttleFirstRequest || h.timer ? (h.debug('Throttling request', v.throttle), clearTimeout(h.timer), h.timer = setTimeout(() => { h.timer && delete h.timer, h.debug('Sending throttled request', g, a.method), h.send.request(); }, v.throttle)) : (h.debug('Sending request', g, a.method), h.send.request(), h.timer = setTimeout(() => {}, v.throttle)) : (h.debug('Sending request', g, a.method), h.send.request()))) : void 0) : void h.error(C.missingURL));
        },
        should: { removeError() { return v.hideError === !0 || v.hideError === 'auto' && !h.is.form(); } },
        is: {
          disabled() { return S.filter(x.disabled).length > 0; }, form() { return S.is('form') || D.is('form'); }, mocked() { return v.mockResponse || v.mockResponseAsync; }, input() { return S.is('input'); }, loading() { return h.request && h.request.state() == 'pending'; }, abortedRequest(e) { return e && e.readyState !== i && e.readyState === 0 ? (h.verbose('XHR request determined to be aborted'), !0) : (h.verbose('XHR request was not aborted'), !1); }, validResponse(t) { return v.dataType !== 'json' && v.dataType !== 'jsonp' || !e.isFunction(v.successTest) ? (h.verbose('Response is not JSON, skipping validation', v.successTest, t), !0) : (h.debug('Checking JSON returned success', v.successTest, t), v.successTest(t) ? (h.debug('Response passed success test', t), !0) : (h.debug('Response failed success test', t), !1)); },
        },
        was: {
          cancelled() { return h.cancelled || !1; }, succesful() { return h.request && h.request.state() == 'resolved'; }, failure() { return h.request && h.request.state() == 'rejected'; }, complete() { return h.request && (h.request.state() == 'resolved' || h.request.state() == 'rejected'); },
        },
        add: { urlData(t, n) { let o; let a; return t && (o = t.match(v.regExp.required), a = t.match(v.regExp.optional), n = n || v.urlData, o && (h.debug('Looking for required URL variables', o), e.each(o, (o, a) => { const r = a.indexOf('$') !== -1 ? a.substr(2, a.length - 3) : a.substr(1, a.length - 2); let s = e.isPlainObject(n) && n[r] !== i ? n[r] : S.data(r) !== i ? S.data(r) : D.data(r) !== i ? D.data(r) : n[r]; return s === i ? (h.error(C.requiredParameter, r, t), t = !1, !1) : (h.verbose('Found required variable', r, s), s = v.encodeParameters ? h.get.urlEncodedValue(s) : s, t = t.replace(a, s), void 0); })), a && (h.debug('Looking for optional URL variables', o), e.each(a, (o, a) => { const r = a.indexOf('$') !== -1 ? a.substr(3, a.length - 4) : a.substr(2, a.length - 3); const s = e.isPlainObject(n) && n[r] !== i ? n[r] : S.data(r) !== i ? S.data(r) : D.data(r) !== i ? D.data(r) : n[r]; s !== i ? (h.verbose('Optional variable Found', r, s), t = t.replace(a, s)) : (h.verbose('Optional variable not found', r), t = t.indexOf(`/${a}`) !== -1 ? t.replace(`/${a}`, '') : t.replace(a, '')); }))), t; }, formData(t) { let n; const o = e.fn.serializeObject !== i; const a = o ? A.serializeObject() : A.serialize(); return t = t || v.data, n = e.isPlainObject(t), n ? o ? (h.debug('Extending existing data with form data', t, a), t = e.extend(!0, {}, t, a)) : (h.error(C.missingSerialize), h.debug('Cant extend data. Replacing data with form data', t, a), t = a) : (h.debug('Adding form data', a), t = a), t; } },
        send: { request() { h.set.loading(), h.request = h.create.request(), h.is.mocked() ? h.mockedXHR = h.create.mockedXHR() : h.xhr = h.create.xhr(), v.onRequest.call(E, h.request, h.xhr); } },
        event: { trigger(e) { h.query(), (e.type == 'submit' || e.type == 'click') && e.preventDefault(); }, xhr: { always() {}, done(t, n, i) { const o = this; const a = (new Date()).getTime() - p; let r = v.loadingDuration - a; const s = e.isFunction(v.onResponse) ? v.onResponse.call(o, e.extend(!0, {}, t)) : !1; r = r > 0 ? r : 0, s && (h.debug('Modified API response in onResponse callback', v.onResponse, s, t), t = s), r > 0 && h.debug('Response completed early delaying state change by', r), setTimeout(() => { h.is.validResponse(t) ? h.request.resolveWith(o, [t, i]) : h.request.rejectWith(o, [i, 'invalid']); }, r); }, fail(e, t, n) { const i = this; const o = (new Date()).getTime() - p; let a = v.loadingDuration - o; a = a > 0 ? a : 0, a > 0 && h.debug('Response completed early delaying state change by', a), setTimeout(() => { h.is.abortedRequest(e) ? h.request.rejectWith(i, [e, 'aborted', n]) : h.request.rejectWith(i, [e, 'error', t, n]); }, a); } }, request: { done(e, t) { h.debug('Successful API Response', e), v.cache === 'local' && m && (h.write.cachedResponse(m, e), h.debug('Saving server response locally', h.cache)), v.onSuccess.call(E, e, S, t); }, complete(e, t) { let n; let i; h.was.succesful() ? (i = e, n = t) : (n = e, i = h.get.responseFromXHR(n)), h.remove.loading(), v.onComplete.call(E, i, S, n); }, fail(e, t, n) { const o = h.get.responseFromXHR(e); const r = h.get.errorFromRequest(o, t, n); t == 'aborted' ? (h.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', t, n), v.onAbort.call(E, t, S, e)) : t == 'invalid' ? h.debug('JSON did not pass success test. A server-side error has most likely occurred', o) : t == 'error' && e !== i && (h.debug('XHR produced a server error', t, n), e.status != 200 && n !== i && n !== '' && h.error(C.statusMessage + n, a.url), v.onError.call(E, r, S, e)), v.errorDuration && t !== 'aborted' && (h.debug('Adding error state'), h.set.error(), h.should.removeError() && setTimeout(h.remove.error, v.errorDuration)), h.debug('API Request failed', r, e), v.onFailure.call(E, o, S, e); } } },
        create: { request() { return e.Deferred().always(h.event.request.complete).done(h.event.request.done).fail(h.event.request.fail); }, mockedXHR() { let t; let n; let i; const o = !1; const a = !1; const r = !1; return i = e.Deferred().always(h.event.xhr.complete).done(h.event.xhr.done).fail(h.event.xhr.fail), v.mockResponse ? (e.isFunction(v.mockResponse) ? (h.debug('Using mocked callback returning response', v.mockResponse), n = v.mockResponse.call(E, v)) : (h.debug('Using specified response', v.mockResponse), n = v.mockResponse), i.resolveWith(E, [n, o, { responseText: n }])) : e.isFunction(v.mockResponseAsync) && (t = function (e) { h.debug('Async callback returned response', e), e ? i.resolveWith(E, [e, o, { responseText: e }]) : i.rejectWith(E, [{ responseText: e }, a, r]); }, h.debug('Using async mocked response', v.mockResponseAsync), v.mockResponseAsync.call(E, v, t)), i; }, xhr() { let t; return t = e.ajax(a).always(h.event.xhr.always).done(h.event.xhr.done).fail(h.event.xhr.fail), h.verbose('Created server request', t), t; } },
        set: { error() { h.verbose('Adding error state to element', D), D.addClass(w.error); }, loading() { h.verbose('Adding loading state to element', D), D.addClass(w.loading), p = (new Date()).getTime(); } },
        remove: { error() { h.verbose('Removing error state from element', D), D.removeClass(w.error); }, loading() { h.verbose('Removing loading state from element', D), D.removeClass(w.loading); } },
        get: {
          responseFromXHR(t) { return e.isPlainObject(t) ? v.dataType == 'json' || v.dataType == 'jsonp' ? h.decode.json(t.responseText) : t.responseText : !1; }, errorFromRequest(t, n, o) { return e.isPlainObject(t) && t.error !== i ? t.error : v.error[n] !== i ? v.error[n] : o; }, request() { return h.request || !1; }, xhr() { return h.xhr || !1; }, settings() { let e; return e = v.beforeSend.call(E, v), e && (e.success !== i && (h.debug('Legacy success callback detected', e), h.error(C.legacyParameters, e.success), e.onSuccess = e.success), e.failure !== i && (h.debug('Legacy failure callback detected', e), h.error(C.legacyParameters, e.failure), e.onFailure = e.failure), e.complete !== i && (h.debug('Legacy complete callback detected', e), h.error(C.legacyParameters, e.complete), e.onComplete = e.complete)), e === i && h.error(C.noReturnedValue), e !== i ? e : v; }, urlEncodedValue(e) { const n = t.decodeURIComponent(e); const i = t.encodeURIComponent(e); const o = n !== e; return o ? (h.debug('URL value is already encoded, avoiding double encoding', e), e) : (h.verbose('Encoding value using encodeURIComponent', e, i), i); }, defaultData() { const t = {}; return e.isWindow(R) || (h.is.input() ? t.value = S.val() : h.is.form() && (t.text = S.text())), t; }, event() { return e.isWindow(R) || v.on == 'now' ? (h.debug('API called without element, no events attached'), !1) : v.on == 'auto' ? S.is('input') ? R.oninput !== i ? 'input' : R.onpropertychange !== i ? 'propertychange' : 'keyup' : S.is('form') ? 'submit' : 'click' : v.on; }, templatedURL(e) { if (e = e || S.data(y.action) || v.action || !1, m = S.data(y.url) || v.url || !1) return h.debug('Using specified url', m), m; if (e) { if (h.debug('Looking up url for action', e, v.api), v.api[e] === i && !h.is.mocked()) return void h.error(C.missingAction, v.action, v.api); m = v.api[e]; } else h.is.form() && (m = S.attr('action') || D.attr('action') || !1, h.debug('No url or action specified, defaulting to form action', m)); return m; },
        },
        abort() { const e = h.get.xhr(); e && e.state() !== 'resolved' && (h.debug('Cancelling API request'), e.abort()); },
        reset() { h.remove.error(), h.remove.loading(); },
        setting(t, n) { if (h.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, v, t); else { if (n === i) return v[t]; v[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, h, t); else { if (n === i) return h[t]; h[t] = n; } },
        debug() { v.debug && (v.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), h.debug.apply(console, arguments))); },
        verbose() { v.verbose && v.debug && (v.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), h.verbose.apply(console, arguments))); },
        error() { h.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), h.error.apply(console, arguments); },
        performance: { log(e) { let t; let n; let i; v.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, c.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500); }, display() { let t = `${v.name}:`; let n = 0; s = !1, clearTimeout(h.performance.timer), e.each(c, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; } },
        invoke(t, n, a) { let r; let s; let c; let l = P; return n = n || d, a = R || a, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (h.error(C.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(a, n) : s !== i && (c = s), e.isArray(o) ? o.push(c) : o !== i ? o = [o, c] : c !== i && (o = c), s; },
      }, u ? (P === i && h.initialize(), h.invoke(l)) : (P !== i && P.invoke('destroy'), h.initialize());
    }), o !== i ? o : this;
  }, e.api.settings = {
    name: 'API',
    namespace: 'api',
    debug: !1,
    verbose: !1,
    performance: !0,
    api: {},
    cache: !0,
    interruptRequests: !0,
    on: 'auto',
    stateContext: !1,
    loadingDuration: 0,
    hideError: 'auto',
    errorDuration: 2e3,
    encodeParameters: !0,
    action: !1,
    url: !1,
    base: '',
    urlData: {},
    defaultData: !0,
    serializeForm: !1,
    throttle: 0,
    throttleFirstRequest: !0,
    method: 'get',
    data: {},
    dataType: 'json',
    mockResponse: !1,
    mockResponseAsync: !1,
    beforeSend(e) { return e; },
    beforeXHR(e) {},
    onRequest(e, t) {},
    onResponse: !1,
    onSuccess(e, t) {},
    onComplete(e, t) {},
    onFailure(e, t) {},
    onError(e, t) {},
    onAbort(e, t) {},
    successTest: !1,
    error: {
      beforeSend: 'The before send function has aborted the request', error: 'There was an error with your request', exitConditions: 'API Request Aborted. Exit conditions met', JSONParse: 'JSON could not be parsed during error handling', legacyParameters: 'You are using legacy API success callback names', method: 'The method you called is not defined', missingAction: 'API action used but no url was defined', missingSerialize: 'jquery-serialize-object is required to add form data to an existing data object', missingURL: 'No URL specified for api event', noReturnedValue: 'The beforeSend callback must return a settings object, beforeSend ignored.', noStorage: 'Caching responses locally requires session storage', parseError: 'There was an error parsing your request', requiredParameter: 'Missing a required URL parameter: ', statusMessage: 'Server gave an error: ', timeout: 'Your request timed out',
    },
    regExp: { required: /\{\$*[A-z0-9]+\}/g, optional: /\{\/\$*[A-z0-9]+\}/g },
    className: { loading: 'loading', error: 'error' },
    selector: { disabled: '.disabled', form: 'form' },
    metadata: { action: 'action', url: 'url' },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.state = function (t) {
    let o; const a = e(this); const r = a.selector || ''; let s = ('ontouchstart' in n.documentElement, (new Date()).getTime()); let c = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return a.each(function () {
      let n; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings); const m = f.error; const g = f.metadata; const p = f.className; const h = f.namespace; const v = f.states; const b = f.text; const y = `.${h}`; const x = `${h}-module`; let C = e(this); const w = this; let k = C.data(x); n = {
        initialize() { n.verbose('Initializing module'), f.automatic && n.add.defaults(), f.context && r !== '' ? e(f.context).on(r, `mouseenter${y}`, n.change.text).on(r, `mouseleave${y}`, n.reset.text).on(r, `click${y}`, n.toggle.state) : C.on(`mouseenter${y}`, n.change.text).on(`mouseleave${y}`, n.reset.text).on(`click${y}`, n.toggle.state), n.instantiate(); },
        instantiate() { n.verbose('Storing instance of module', n), k = n, C.data(x, n); },
        destroy() { n.verbose('Destroying previous module', k), C.off(y).removeData(x); },
        refresh() { n.verbose('Refreshing selector cache'), C = e(w); },
        add: { defaults() { const o = t && e.isPlainObject(t.states) ? t.states : {}; e.each(f.defaults, (t, a) => { n.is[t] !== i && n.is[t]() && (n.verbose('Adding default states', t, w), e.extend(f.states, a, o)); }); } },
        is: {
          active() { return C.hasClass(p.active); },
          loading() { return C.hasClass(p.loading); },
          inactive() { return !C.hasClass(p.active); },
          state(e) { return p[e] === i ? !1 : C.hasClass(p[e]); },
          enabled() { return !C.is(f.filter.active); },
          disabled() { return C.is(f.filter.active); },
          textEnabled() { return !C.is(f.filter.text); },
          button() { return C.is('.button:not(a, .submit)'); },
          input() { return C.is('input'); },
          progress() {
            return C.is('.ui.progress');
          },
        },
        allow(e) { n.debug('Now allowing state', e), v[e] = !0; },
        disallow(e) { n.debug('No longer allowing', e), v[e] = !1; },
        allows(e) { return v[e] || !1; },
        enable() { C.removeClass(p.disabled); },
        disable() { C.addClass(p.disabled); },
        setState(e) { n.allows(e) && C.addClass(p[e]); },
        removeState(e) { n.allows(e) && C.removeClass(p[e]); },
        toggle: { state() { let t; let o; if (n.allows('active') && n.is.enabled()) { if (n.refresh(), e.fn.api !== i) if (t = C.api('get request'), o = C.api('was cancelled'))n.debug('API Request cancelled by beforesend'), f.activateTest = function () { return !1; }, f.deactivateTest = function () { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
        listenTo(t) { n.debug('API request detected, waiting for state signal', t), t && (b.loading && n.update.text(b.loading), e.when(t).then(() => { t.state() == 'resolved' ? (n.debug('API request succeeded'), f.activateTest = function () { return !0; }, f.deactivateTest = function () { return !0; }) : (n.debug('API request failed'), f.activateTest = function () { return !1; }, f.deactivateTest = function () { return !1; }), n.change.state(); })); },
        change: { state() { n.debug('Determining state change direction'), n.is.inactive() ? n.activate() : n.deactivate(), f.sync && n.sync(), f.onChange.call(w); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose('Changing text to disabled text', b.hover), n.update.text(b.disabled)) : n.is.active() ? b.hover ? (n.verbose('Changing text to hover text', b.hover), n.update.text(b.hover)) : b.deactivate && (n.verbose('Changing text to deactivating text', b.deactivate), n.update.text(b.deactivate)) : b.hover ? (n.verbose('Changing text to hover text', b.hover), n.update.text(b.hover)) : b.activate && (n.verbose('Changing text to activating text', b.activate), n.update.text(b.activate))); } },
        activate() { f.activateTest.call(w) && (n.debug('Setting state to active'), C.addClass(p.active), n.update.text(b.active), f.onActivate.call(w)); },
        deactivate() { f.deactivateTest.call(w) && (n.debug('Setting state to inactive'), C.removeClass(p.active), n.update.text(b.inactive), f.onDeactivate.call(w)); },
        sync() { n.verbose('Syncing other buttons to current state'), n.is.active() ? a.not(C).state('activate') : a.not(C).state('deactivate'); },
        get: { text() { return f.selector.text ? C.find(f.selector.text).text() : C.html(); }, textFor(e) { return b[e] || !1; } },
        flash: { text(e, t, i) { const o = n.get.text(); n.debug('Flashing text message', e, t), e = e || f.text.flash, t = t || f.flashDuration, i = i || function () {}, n.update.text(e), setTimeout(() => { n.update.text(o), i.call(w); }, t); } },
        reset: { text() { const e = b.active || C.data(g.storedText); const t = b.inactive || C.data(g.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose('Resetting active text', e), n.update.text(e)) : t && (n.verbose('Resetting inactive text', e), n.update.text(t))); } },
        update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug('Updating text', e), f.selector.text ? C.data(g.storedText, e).find(f.selector.text).text(e) : C.data(g.storedText, e).html(e)) : n.debug('Text is already set, ignoring update', e); } },
        setting(t, o) { if (n.debug('Changing setting', t, o), e.isPlainObject(t))e.extend(!0, f, t); else { if (o === i) return f[t]; f[t] = o; } },
        internal(t, o) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (o === i) return n[t]; n[t] = o; } },
        debug() { f.debug && (f.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.debug.apply(console, arguments))); },
        verbose() { f.verbose && f.debug && (f.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.verbose.apply(console, arguments))); },
        error() { n.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), n.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let i; let o; f.performance && (t = (new Date()).getTime(), o = s || t, i = t - o, s = t, c.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': i,
            })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
          },
          display() { let t = `${f.name}:`; let o = 0; s = !1, clearTimeout(n.performance.timer), e.each(c, (e, t) => { o += t['Execution Time']; }), t += ` ${o}ms`, r && (t += ` '${r}'`), (console.group !== i || console.table !== i) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
        },
        invoke(t, a, r) { let s; let c; let l; let u = k; return a = a || d, r = w || r, typeof t === 'string' && u !== i && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, (o, a) => { const r = o != s ? a + t[o + 1].charAt(0).toUpperCase() + t[o + 1].slice(1) : t; if (e.isPlainObject(u[r]) && o != s)u = u[r]; else { if (u[r] !== i) return c = u[r], !1; if (!e.isPlainObject(u[a]) || o == s) return u[a] !== i ? (c = u[a], !1) : (n.error(m.method, t), !1); u = u[a]; } })), e.isFunction(c) ? l = c.apply(r, a) : c !== i && (l = c), e.isArray(o) ? o.push(l) : o !== i ? o = [o, l] : l !== i && (o = l), c; },
      }, u ? (k === i && n.initialize(), n.invoke(l)) : (k !== i && k.invoke('destroy'), n.initialize());
    }), o !== i ? o : this;
  }, e.fn.state.settings = {
    name: 'State',
    debug: !1,
    verbose: !1,
    namespace: 'state',
    performance: !0,
    onActivate() {},
    onDeactivate() {},
    onChange() {},
    activateTest() { return !0; },
    deactivateTest() { return !0; },
    automatic: !0,
    sync: !1,
    flashDuration: 1e3,
    filter: { text: '.loading, .disabled', active: '.disabled' },
    context: !1,
    error: { beforeSend: 'The before send function has cancelled state change', method: 'The method you called is not defined.' },
    metadata: { promise: 'promise', storedText: 'stored-text' },
    className: {
      active: 'active', disabled: 'disabled', error: 'error', loading: 'loading', success: 'success', warning: 'warning',
    },
    selector: { text: !1 },
    defaults: {
      input: { disabled: !0, loading: !0, active: !0 },
      button: { disabled: !0, loading: !0, active: !0 },
      progress: {
        active: !0, success: !0, warning: !0, error: !0,
      },
    },
    states: {
      active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0,
    },
    text: {
      disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1,
    },
  };
}(jQuery, window, document)), (function (e, t, n, i) {
  'use strict';

  e.fn.visibility = function (o) {
    let a; const r = e(this); const s = r.selector || ''; let c = (new Date()).getTime(); let l = []; const u = arguments[0]; const d = typeof u === 'string'; const f = [].slice.call(arguments, 1); return r.each(function () {
      let r; let m; let g; const p = e.isPlainObject(o) ? e.extend(!0, {}, e.fn.visibility.settings, o) : e.extend({}, e.fn.visibility.settings); const h = p.className; const v = p.namespace; const b = p.error; const y = p.metadata; const x = `.${v}`; const C = `module-${v}`; const w = e(t); const k = e(this); const T = e(p.context); let S = (k.selector || '', k.data(C)); const A = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; const D = this; let R = !1; g = {
        initialize() { g.debug('Initializing', p), g.setup.cache(), g.should.trackChanges() && (p.type == 'image' && g.setup.image(), p.type == 'fixed' && g.setup.fixed(), p.observeChanges && g.observeChanges(), g.bind.events()), g.save.position(), g.is.visible() || g.error(b.visible, k), p.initialCheck && g.checkVisibility(), g.instantiate(); },
        instantiate() { g.debug('Storing instance', g), k.data(C, g), S = g; },
        destroy() { g.verbose('Destroying previous module'), m && m.disconnect(), w.off(`load${x}`, g.event.load).off(`resize${x}`, g.event.resize), T.off(`scrollchange${x}`, g.event.scrollchange), k.off(x).removeData(C); },
        observeChanges() { 'MutationObserver' in t && (m = new MutationObserver((e) => { g.verbose('DOM tree modified, updating visibility calculations'), g.timer = setTimeout(() => { g.verbose('DOM tree modified, updating sticky menu'), g.refresh(); }, 100); }), m.observe(D, { childList: !0, subtree: !0 }), g.debug('Setting up mutation observer', m)); },
        bind: { events() { g.verbose('Binding visibility events to scroll and resize'), p.refreshOnLoad && w.on(`load${x}`, g.event.load), w.on(`resize${x}`, g.event.resize), T.off(`scroll${x}`).on(`scroll${x}`, g.event.scroll).on(`scrollchange${x}`, g.event.scrollchange); } },
        event: {
          resize() { g.debug('Window resized'), p.refreshOnResize && A(g.refresh); }, load() { g.debug('Page finished loading'), A(g.refresh); }, scroll() { p.throttle ? (clearTimeout(g.timer), g.timer = setTimeout(() => { T.triggerHandler(`scrollchange${x}`, [T.scrollTop()]); }, p.throttle)) : A(() => { T.triggerHandler(`scrollchange${x}`, [T.scrollTop()]); }); }, scrollchange(e, t) { g.checkVisibility(t); },
        },
        precache(t, i) { t instanceof Array || (t = [t]); for (var o = t.length, a = 0, r = [], s = n.createElement('img'), c = function () { a++, a >= t.length && e.isFunction(i) && i(); }; o--;)s = n.createElement('img'), s.onload = c, s.onerror = c, s.src = t[o], r.push(s); },
        enableCallbacks() { g.debug('Allowing callbacks to occur'), R = !1; },
        disableCallbacks() { g.debug('Disabling all callbacks temporarily'), R = !0; },
        should: { trackChanges() { return d ? (g.debug('One time query, no need to bind events'), !1) : (g.debug('Callbacks being attached'), !0); } },
        setup: { cache() { g.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = k.data(y.src); e && (g.verbose('Lazy loading image', e), p.once = !0, p.observeChanges = !1, p.onOnScreen = function () { g.debug('Image on screen', D), g.precache(e, () => { g.set.image(e); }); }); }, fixed() { g.debug('Setting up fixed'), p.once = !1, p.observeChanges = !1, p.initialCheck = !0, p.refreshOnLoad = !0, o.transition || (p.transition = !1), g.create.placeholder(), g.debug('Added placeholder', r), p.onTopPassed = function () { g.debug('Element passed, adding fixed position', k), g.show.placeholder(), g.set.fixed(), p.transition && e.fn.transition !== i && k.transition(p.transition, p.duration); }, p.onTopPassedReverse = function () { g.debug('Element returned to position, removing fixed', k), g.hide.placeholder(), g.remove.fixed(); }; } },
        create: { placeholder() { g.verbose('Creating fixed position placeholder'), r = k.clone(!1).css('display', 'none').addClass(h.placeholder).insertAfter(k); } },
        show: { placeholder() { g.verbose('Showing placeholder'), r.css('display', 'block').css('visibility', 'hidden'); } },
        hide: { placeholder() { g.verbose('Hiding placeholder'), r.css('display', 'none').css('visibility', ''); } },
        set: {
          fixed() {
            g.verbose('Setting element to fixed position'), k.addClass(h.fixed).css({
              position: 'fixed', top: `${p.offset}px`, left: 'auto', zIndex: '1',
            });
          },
          image(t) { k.attr('src', t), p.transition ? e.fn.transition !== i ? k.transition(p.transition, p.duration) : k.fadeIn(p.duration) : k.show(); },
        },
        is: { onScreen() { const e = g.get.elementCalculations(); return e.onScreen; }, offScreen() { const e = g.get.elementCalculations(); return e.offScreen; }, visible() { return g.cache && g.cache.element ? !(g.cache.element.width === 0 && g.cache.element.offset.top === 0) : !1; } },
        refresh() { g.debug('Refreshing constants (width/height)'), p.type == 'fixed' && (g.remove.fixed(), g.remove.occurred()), g.reset(), g.save.position(), p.checkOnRefresh && g.checkVisibility(), p.onRefresh.call(D); },
        reset() { g.verbose('Reseting all cached values'), e.isPlainObject(g.cache) && (g.cache.screen = {}, g.cache.element = {}); },
        checkVisibility(e) { g.verbose('Checking visibility of element', g.cache.element), !R && g.is.visible() && (g.save.scroll(e), g.save.calculations(), g.passed(), g.passingReverse(), g.topVisibleReverse(), g.bottomVisibleReverse(), g.topPassedReverse(), g.bottomPassedReverse(), g.onScreen(), g.offScreen(), g.passing(), g.topVisible(), g.bottomVisible(), g.topPassed(), g.bottomPassed(), p.onUpdate && p.onUpdate.call(D, g.get.elementCalculations())); },
        passed(t, n) { const o = g.get.elementCalculations(); if (t && n)p.onPassed[t] = n; else { if (t !== i) return g.get.pixelsPassed(t) > o.pixelsPassed; o.passing && e.each(p.onPassed, (e, t) => { o.bottomVisible || o.pixelsPassed > g.get.pixelsPassed(e) ? g.execute(t, e) : p.once || g.remove.occurred(t); }); } },
        onScreen(e) { const t = g.get.elementCalculations(); const n = e || p.onOnScreen; const o = 'onScreen'; return e && (g.debug('Adding callback for onScreen', e), p.onOnScreen = e), t.onScreen ? g.execute(n, o) : p.once || g.remove.occurred(o), e !== i ? t.onOnScreen : void 0; },
        offScreen(e) { const t = g.get.elementCalculations(); const n = e || p.onOffScreen; const o = 'offScreen'; return e && (g.debug('Adding callback for offScreen', e), p.onOffScreen = e), t.offScreen ? g.execute(n, o) : p.once || g.remove.occurred(o), e !== i ? t.onOffScreen : void 0; },
        passing(e) { const t = g.get.elementCalculations(); const n = e || p.onPassing; const o = 'passing'; return e && (g.debug('Adding callback for passing', e), p.onPassing = e), t.passing ? g.execute(n, o) : p.once || g.remove.occurred(o), e !== i ? t.passing : void 0; },
        topVisible(e) { const t = g.get.elementCalculations(); const n = e || p.onTopVisible; const o = 'topVisible'; return e && (g.debug('Adding callback for top visible', e), p.onTopVisible = e), t.topVisible ? g.execute(n, o) : p.once || g.remove.occurred(o), e === i ? t.topVisible : void 0; },
        bottomVisible(e) { const t = g.get.elementCalculations(); const n = e || p.onBottomVisible; const o = 'bottomVisible'; return e && (g.debug('Adding callback for bottom visible', e), p.onBottomVisible = e), t.bottomVisible ? g.execute(n, o) : p.once || g.remove.occurred(o), e === i ? t.bottomVisible : void 0; },
        topPassed(e) { const t = g.get.elementCalculations(); const n = e || p.onTopPassed; const o = 'topPassed'; return e && (g.debug('Adding callback for top passed', e), p.onTopPassed = e), t.topPassed ? g.execute(n, o) : p.once || g.remove.occurred(o), e === i ? t.topPassed : void 0; },
        bottomPassed(e) { const t = g.get.elementCalculations(); const n = e || p.onBottomPassed; const o = 'bottomPassed'; return e && (g.debug('Adding callback for bottom passed', e), p.onBottomPassed = e), t.bottomPassed ? g.execute(n, o) : p.once || g.remove.occurred(o), e === i ? t.bottomPassed : void 0; },
        passingReverse(e) { const t = g.get.elementCalculations(); const n = e || p.onPassingReverse; const o = 'passingReverse'; return e && (g.debug('Adding callback for passing reverse', e), p.onPassingReverse = e), t.passing ? p.once || g.remove.occurred(o) : g.get.occurred('passing') && g.execute(n, o), e !== i ? !t.passing : void 0; },
        topVisibleReverse(e) { const t = g.get.elementCalculations(); const n = e || p.onTopVisibleReverse; const o = 'topVisibleReverse'; return e && (g.debug('Adding callback for top visible reverse', e), p.onTopVisibleReverse = e), t.topVisible ? p.once || g.remove.occurred(o) : g.get.occurred('topVisible') && g.execute(n, o), e === i ? !t.topVisible : void 0; },
        bottomVisibleReverse(e) { const t = g.get.elementCalculations(); const n = e || p.onBottomVisibleReverse; const o = 'bottomVisibleReverse'; return e && (g.debug('Adding callback for bottom visible reverse', e), p.onBottomVisibleReverse = e), t.bottomVisible ? p.once || g.remove.occurred(o) : g.get.occurred('bottomVisible') && g.execute(n, o), e === i ? !t.bottomVisible : void 0; },
        topPassedReverse(e) { const t = g.get.elementCalculations(); const n = e || p.onTopPassedReverse; const o = 'topPassedReverse'; return e && (g.debug('Adding callback for top passed reverse', e), p.onTopPassedReverse = e), t.topPassed ? p.once || g.remove.occurred(o) : g.get.occurred('topPassed') && g.execute(n, o), e === i ? !t.onTopPassed : void 0; },
        bottomPassedReverse(e) { const t = g.get.elementCalculations(); const n = e || p.onBottomPassedReverse; const o = 'bottomPassedReverse'; return e && (g.debug('Adding callback for bottom passed reverse', e), p.onBottomPassedReverse = e), t.bottomPassed ? p.once || g.remove.occurred(o) : g.get.occurred('bottomPassed') && g.execute(n, o), e === i ? !t.bottomPassed : void 0; },
        execute(e, t) { const n = g.get.elementCalculations(); const i = g.get.screenCalculations(); e = e || !1, e && (p.continuous ? (g.debug('Callback being called continuously', t, n), e.call(D, n, i)) : g.get.occurred(t) || (g.debug('Conditions met', t, n), e.call(D, n, i))), g.save.occurred(t); },
        remove: {
          fixed() {
            g.debug('Removing fixed position'), k.removeClass(h.fixed).css({
              position: '', top: '', left: '', zIndex: '',
            });
          },
          occurred(e) { if (e) { const t = g.cache.occurred; t[e] !== i && t[e] === !0 && (g.debug('Callback can now be called again', e), g.cache.occurred[e] = !1); } else g.cache.occurred = {}; },
        },
        save: {
          calculations() { g.verbose('Saving all calculations necessary to determine positioning'), g.save.direction(), g.save.screenCalculations(), g.save.elementCalculations(); }, occurred(e) { e && (g.cache.occurred[e] === i || g.cache.occurred[e] !== !0) && (g.verbose('Saving callback occurred', e), g.cache.occurred[e] = !0); }, scroll(e) { e = e + p.offset || T.scrollTop() + p.offset, g.cache.scroll = e; }, direction() { let e; const t = g.get.scroll(); const n = g.get.lastScroll(); return e = t > n && n ? 'down' : n > t && n ? 'up' : 'static', g.cache.direction = e, g.cache.direction; }, elementPosition() { const e = g.cache.element; const t = g.get.screenSize(); return g.verbose('Saving element position'), e.fits = e.height < t.height, e.offset = k.offset(), e.width = k.outerWidth(), e.height = k.outerHeight(), g.cache.element = e, e; }, elementCalculations() { const e = g.get.screenCalculations(); const t = g.get.elementPosition(); return p.includeMargin ? (t.margin = {}, t.margin.top = parseInt(k.css('margin-top'), 10), t.margin.bottom = parseInt(k.css('margin-bottom'), 10), t.top = t.offset.top - t.margin.top, t.bottom = t.offset.top + t.height + t.margin.bottom) : (t.top = t.offset.top, t.bottom = t.offset.top + t.height), t.topVisible = e.bottom >= t.top, t.topPassed = e.top >= t.top, t.bottomVisible = e.bottom >= t.bottom, t.bottomPassed = e.top >= t.bottom, t.pixelsPassed = 0, t.percentagePassed = 0, t.onScreen = t.topVisible && !t.bottomPassed, t.passing = t.topPassed && !t.bottomPassed, t.offScreen = !t.onScreen, t.passing && (t.pixelsPassed = e.top - t.top, t.percentagePassed = (e.top - t.top) / t.height), g.cache.element = t, g.verbose('Updated element calculations', t), t; }, screenCalculations() { const e = g.get.scroll(); return g.save.direction(), g.cache.screen.top = e, g.cache.screen.bottom = e + g.cache.screen.height, g.cache.screen; }, screenSize() { g.verbose('Saving window position'), g.cache.screen = { height: T.height() }; }, position() { g.save.screenSize(), g.save.elementPosition(); },
        },
        get: {
          pixelsPassed(e) { const t = g.get.elementCalculations(); return e.search('%') > -1 ? t.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return g.cache.occurred !== i ? g.cache.occurred[e] || !1 : !1; }, direction() { return g.cache.direction === i && g.save.direction(), g.cache.direction; }, elementPosition() { return g.cache.element === i && g.save.elementPosition(), g.cache.element; }, elementCalculations() { return g.cache.element === i && g.save.elementCalculations(), g.cache.element; }, screenCalculations() { return g.cache.screen === i && g.save.screenCalculations(), g.cache.screen; }, screenSize() { return g.cache.screen === i && g.save.screenSize(), g.cache.screen; }, scroll() { return g.cache.scroll === i && g.save.scroll(), g.cache.scroll; }, lastScroll() { return g.cache.screen === i ? (g.debug('First scroll event, no last scroll could be found'), !1) : g.cache.screen.top; },
        },
        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (n === i) return p[t]; p[t] = n; } },
        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (n === i) return g[t]; g[t] = n; } },
        debug() { p.debug && (p.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.debug.apply(console, arguments))); },
        verbose() { p.verbose && p.debug && (p.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.verbose.apply(console, arguments))); },
        error() { g.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), g.error.apply(console, arguments); },
        performance: {
          log(e) {
            let t; let n; let i; p.performance && (t = (new Date()).getTime(), i = c || t, n = t - i, c = t, l.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
            })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
          },
          display() { let t = `${p.name}:`; let n = 0; c = !1, clearTimeout(g.performance.timer), e.each(l, (e, t) => { n += t['Execution Time']; }), t += ` ${n}ms`, s && (t += ` '${s}'`), (console.group !== i || console.table !== i) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
        },
        invoke(t, n, o) { let r; let s; let c; let l = S; return n = n || f, o = D || o, typeof t === 'string' && l !== i && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, o) => { const a = n != r ? o + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[a]) && n != r)l = l[a]; else { if (l[a] !== i) return s = l[a], !1; if (!e.isPlainObject(l[o]) || n == r) return l[o] !== i ? (s = l[o], !1) : (g.error(b.method, t), !1); l = l[o]; } })), e.isFunction(s) ? c = s.apply(o, n) : s !== i && (c = s), e.isArray(a) ? a.push(c) : a !== i ? a = [a, c] : c !== i && (a = c), s; },
      }, d ? (S === i && g.initialize(), S.save.scroll(), S.save.calculations(), g.invoke(u)) : (S !== i && S.invoke('destroy'), g.initialize());
    }), a !== i ? a : this;
  }, e.fn.visibility.settings = {
    name: 'Visibility', namespace: 'visibility', debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: t, throttle: !1, type: !1, transition: 'fade in', duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onUpdate: !1, onRefresh() {}, metadata: { src: 'src' }, className: { fixed: 'fixed', placeholder: 'placeholder' }, error: { method: 'The method you called is not defined.', visible: 'Element is hidden, you must call refresh after element becomes visible' },
  };
}(jQuery, window, document));
